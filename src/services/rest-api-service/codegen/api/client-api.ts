/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiV1AdminsOrdersDestination } from '../models';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject1 } from '../models';
// @ts-ignore
import { InlineObject2 } from '../models';
// @ts-ignore
import { InlineObject44 } from '../models';
// @ts-ignore
import { InlineObject45 } from '../models';
// @ts-ignore
import { InlineObject46 } from '../models';
// @ts-ignore
import { InlineObject47 } from '../models';
// @ts-ignore
import { InlineObject48 } from '../models';
// @ts-ignore
import { InlineObject49 } from '../models';
// @ts-ignore
import { InlineObject50 } from '../models';
// @ts-ignore
import { InlineObject51 } from '../models';
// @ts-ignore
import { InlineObject52 } from '../models';
// @ts-ignore
import { InlineObject53 } from '../models';
// @ts-ignore
import { InlineObject54 } from '../models';
// @ts-ignore
import { InlineObject55 } from '../models';
// @ts-ignore
import { InlineObject56 } from '../models';
// @ts-ignore
import { InlineObject57 } from '../models';
// @ts-ignore
import { InlineObject58 } from '../models';
// @ts-ignore
import { InlineObject59 } from '../models';
// @ts-ignore
import { InlineObject60 } from '../models';
// @ts-ignore
import { InlineObject61 } from '../models';
// @ts-ignore
import { InlineObject62 } from '../models';
// @ts-ignore
import { InlineResponse200 } from '../models';
// @ts-ignore
import { InlineResponse2001 } from '../models';
// @ts-ignore
import { InlineResponse20033 } from '../models';
// @ts-ignore
import { InlineResponse20034 } from '../models';
// @ts-ignore
import { InlineResponse20035 } from '../models';
// @ts-ignore
import { InlineResponse20036 } from '../models';
// @ts-ignore
import { InlineResponse20037 } from '../models';
// @ts-ignore
import { InlineResponse20038 } from '../models';
// @ts-ignore
<<<<<<< HEAD
import { InlineResponse200 } from '../models';
// @ts-ignore
import { InlineResponse2001 } from '../models';
=======
import { InlineResponse20039 } from '../models';
// @ts-ignore
import { InlineResponse20040 } from '../models';
>>>>>>> pre-release
// @ts-ignore
import { InlineResponse20041 } from '../models';
// @ts-ignore
import { InlineResponse20042 } from '../models';
// @ts-ignore
import { InlineResponse20042Rows } from '../models';
// @ts-ignore
import { InlineResponse20043 } from '../models';
// @ts-ignore
import { InlineResponse20044 } from '../models';
// @ts-ignore
<<<<<<< HEAD
import { InlineResponse20045 } from '../models';
// @ts-ignore
import { InlineResponse20046 } from '../models';
// @ts-ignore
import { InlineResponse20047 } from '../models';
// @ts-ignore
import { InlineResponse20048 } from '../models';
// @ts-ignore
import { InlineResponse20049 } from '../models';
// @ts-ignore
import { InlineResponse20050 } from '../models';
// @ts-ignore
import { InlineResponse20050Rows } from '../models';
// @ts-ignore
import { InlineResponse20051 } from '../models';
// @ts-ignore
import { InlineResponse20052 } from '../models';
// @ts-ignore
=======
>>>>>>> pre-release
import { InlineResponse2006 } from '../models';
// @ts-ignore
import { InlineResponse2015 } from '../models';
// @ts-ignore
import { InlineResponse2016 } from '../models';
// @ts-ignore
import { InlineResponse2017 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Добавить рекомендацию.
         * @summary Добавить рекомендацию в storekeeper_product.
         * @param {InlineObject58} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesAddRecommendationForStockPost: async (body?: InlineObject58, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/boxes/add_recommendation_for_stock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Метод должен вычислять разницу между deliveryTotalPriceChanged и deliveryTotalPrice - (deliveryTotalPriceChanged-deliveryTotalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этой коробке из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа deliveryTotalPrice = deliveryTotalPriceChanged   ## Проверки:Только для коробок со статусом: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE
         * @summary # Подтвердить измение цены доставки за коробки.
         * @param {Array<InlineObject1>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesConfirmDeliveryPriceChangePost: async (body?: Array<InlineObject1>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/boxes/confirm_delivery_price_change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить рекомендацию.
         * @summary Изменить рекомендацию в storekeeper_product.
         * @param {string} guid GUID записи
         * @param {InlineObject59} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesEditRecommendationForStockGuidPatch: async (guid: string, body?: InlineObject59, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsBoxesEditRecommendationForStockGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/boxes/edit_recommendation_for_stock/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать shippingLabel в первый раз  Данный метод нужен чтобы отредактировать в первый раз shippingLabel коробки.         Проверки:         Доступен только для коробок ранее shippingLabel === null,         Доступен только для коробок со статусами IN_STOCK
         * @summary Редактировать shippingLabel в первый раз.
         * @param {string} guid GUID коробки
         * @param {InlineObject62} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch: async (guid: string, body?: InlineObject62, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/boxes/{guid}/edit_shippingLabel_first_time`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Вернуть коробки обратно на склад  Данный метод нужен чтобы отменить запрос на отправку в партию или при отказе клиентом изменения цены         У клиента будут разморожены средства на доставку.         У коробок статус вернется на статус IN_STOCK         затирается партия (batchId = null)         Проверки:         Доступен только для коробок со статусами REQUESTED_SEND_TO_BATCH, NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, NEED_TO_UPDATE_THE_TARIFF
         * @summary Вернуть коробки обратно на склад.
         * @param {Array<InlineObject2>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesReturnBoxesToStockPost: async (body?: Array<InlineObject2>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/boxes/return_boxes_to_stock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Обновить тариф если тариф был удален.  У коробок статус вернется на статус IN_BATCH или REQUESTED_SEND_TO_BATCH, в зависимости от того есть у коробки batchId         У клиента будут разморожены/разморожены средства на доставку в зависимости разницы стоимости.         Проверки:         Доступен только для коробок со статусами NEED_TO_UPDATE_THE_TARIFF
         * @summary Обновить тариф если тариф был удален.
         * @param {InlineObject57} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost: async (body?: InlineObject57, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/boxes/update_tariff_if_tariff_was_deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все склады назначения.   
         * @summary #  Получить все склады назначения.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsDestinationGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/destination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отдает дестинейшны со статусом коробки указаным в квери
         * @summary Отдает дестинейшны со статусом коробки указаным в квери
         * @param {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'} [status] Статус коробки, по которому будут отфильтрованы дестинейшны
         * @param {string} [storekeeperId] Гуид сторкипера дестинейшна
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsDestinationsGet: async (status?: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить заказы текущего клиента через id товара.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   вернет все незавершенные заказы клиента, гед есть указанный товар.
         * @summary # Получить заказы текущего клиента через id товара.
         * @param {string} guid GUID товара
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsGetOrdersByProductIdGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsGetOrdersByProductIdGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/get_orders_by_product_id/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Оплатить товары.   ## Данный эндпоинт выбросит ошибку если хотябы один из продуктов не будет валидным   ## Прижимаются товары со статусами [70, 110]  ## Товары со статусом 70 (созданные фрилансером) получают статус 275, товар полностью переходит к клиенту: createdById меняется на id клиента, isCreatedByClient меняется на true, needCheckBySupervisor меняется на true,  ## Проверка продуктов(валидация): Нельзя повторно покупать товар который был оплачен (product.status === 70 && product.paidById !== null)  ## Товары со статусом 110 (бесплатные от платформы) получают статус 76, клиент получает копию продукта без данных о ресерчере, баере и супервайзере.
         * @summary # Оплатить товары.
         * @param {InlineObject47} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsMakePaymentsPost: async (body?: InlineObject47, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/make_payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать заказ в статусе formed.   ## Статус автоматом ставиться formed: 0  Стоимость заказа = 0  Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
         * @summary # Создать заказ в статусе formed.
         * @param {InlineObject49} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersFormedPost: async (body?: InlineObject49, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/orders/formed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить заказы текущего клиента.   
         * @summary # Получить заказы текущего клиента.
         * @param {string} [status] GUID сторкипера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGet: async (status?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Этот метод должен устанавливать статус ордеру 40(отменен клиентом), а так же брать из заказа поле totalPrice и  вычитать эту сумму у привязанного к заказу, клиента из поля balanceFreeze и прибавлять в поле balance  ## Проверки:  Данный метод возможно вызвать только при статусах readyToProcess: 10  и needConfirmingToPriceChange: 19, // требуется подтверждение для изменения цены)
         * @summary Отменить заказ.
         * @param {string} guid Guid ордера
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidCancelPost: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsOrdersGuidCancelPost', 'guid', guid)
            const localVarPath = `/api/v1/clients/orders/{guid}/cancel`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Метод должен вычислять разницу между totalPriceChanged и totalPrice - (totalPriceChanged-totalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этому ордеру из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа totalPrice = totalPriceChanged   ## Проверки:Только для заказов со статусом needConfirmingToPriceChange: 19
         * @summary # Подтвердить измение цены.
         * @param {string} guid Guid ордера
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidConfirmPriceChangePost: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsOrdersGuidConfirmPriceChangePost', 'guid', guid)
            const localVarPath = `/api/v1/clients/orders/{guid}/confirm_price_change`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить заказ по его GUID.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   
         * @summary # Получить заказ по его GUID.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsOrdersGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/orders/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в заказ.   ## Обратить внимание - внутри заказа нельзя отдельно редактировать атрибуты товара.   ## Если изменился какой-то они товар, все равно нужно передать полностью новый массив с .   ## с товарами.   ## Данный метод возможно вызывать до выплат поставщику (пока paidAt === null)Проверки: тариф доставки должен принадлежать данному сторкиперу
         * @summary # Внести изменения в заказ.
         * @param {string} guid GUID заказа, который будет изменен
         * @param {InlineObject50} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidPatch: async (guid: string, body?: InlineObject50, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsOrdersGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/orders/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать заказ.   ## Статус автоматом ставиться readyToProcess: 10  Стоимость заказа = количество * (цена товара + (цена доставки паритии / количество товара в партии)):  Эта сумма будет заморожена у клиента. Курс записывается из админки Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
         * @summary # Создать заказ.
         * @param {InlineObject48} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersPost: async (body?: InlineObject48, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
         * @summary # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
         * @param {string} guid GUID заказа, который будет изменен
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersToReadyToProcessGuidPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsOrdersToReadyToProcessGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/orders/to_ready_to_process/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить заказы текущего клиента.   
         * @summary # Получить заказы текущего клиента.
         * @param {string} [status] Статусы заказов, по которым идет фильтрация, разделенные запятыми
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsPagOrdersGet: async (status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/pag/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Получить данные продукта по гуиду
         * @summary # Получить данные продукта по гуиду
         * @param {string} guid GUID продукта
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsDataGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsDataGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/data/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отправить  созданные клиентом товары на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
         * @summary # Отправить  созданные клиентом товары на проверку супервайзеру.
         * @param {InlineObject55} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch: async (body?: InlineObject55, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/from_client_ready_to_be_checked_by_supervisor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
         * @summary # Получить цену для клиента на поиск поставщика множества товаров
         * @param {InlineObject54} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGetPriceForClientPost: async (body?: InlineObject54, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/get_price_for_client`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в баркод товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в баркод товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidChangeBarCodePatch: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidChangeBarCodePatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/change_barCode`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в fourMonthesStock товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в fourMonthesStock товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidFourMonthesStockPatch: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidFourMonthesStockPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/fourMonthesStock`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отправить  созданный клиентом товар на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
         * @summary # Отправить  созданный клиентом товар на проверку супервайзеру.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject56} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch: async (guid: string, body?: InlineObject56, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/from_client_ready_to_be_checked_by_supervisor`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
         * @summary # Получить цену для клиента на поиск поставщика
         * @param {string} guid GUID продукта, который будет изменен
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidGetPriceForClientGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidGetPriceForClientGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/get_price_for_client`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в товар.   Если товар был создан ресерчером (статус до 100) менять можно только баркод (нет проверки).   ## Если товар был создан клиентом (статус от 200):  Вам разрешено редактировать свой товар или добавлять поставщика только если ранее товар имел статусы 200, 270, 275, 280, 290  
         * @summary # Внести изменения в товар.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject44} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidPatch: async (guid: string, body?: InlineObject44, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в stockUSA товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в stockUSA товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidStockUSAPatch: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidStockUSAPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/stockUSA`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в защиту листинга товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в защиту листинга товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject46} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidTransparencyPatch: async (guid: string, body?: InlineObject46, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidTransparencyPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/transparency`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в seo-файлы товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в seo-файлы товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject45} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidUpdateSeoFilesPatch: async (guid: string, body?: InlineObject45, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsGuidUpdateSeoFilesPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/{guid}/update_seo_files`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список продуктов для заказов. 
         * @summary # Получить список продуктов.
         * @param {string} productIds Гуиды продуктов
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsInfoForOrdersGet: async (productIds: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('apiV1ClientsProductsInfoForOrdersGet', 'productIds', productIds)
            const localVarPath = `/api/v1/clients/products/info_for_orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (productIds !== undefined) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить облегченный список товаров(archive = false)
         * @summary # Получить облегченный список товаров
         * @param {boolean} [isChild] Существуют ли у продукта родитель
         * @param {boolean} [isParent] Является ли продукт родителем
         * @param {string} [shopId] ID магазина для фильтрации по нему
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsLightGet: async (isChild?: boolean, isParent?: boolean, shopId?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/light`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isChild !== undefined) {
                localVarQueryParameter['isChild'] = isChild;
            }

            if (isParent !== undefined) {
                localVarQueryParameter['isParent'] = isParent;
            }

            if (shopId !== undefined) {
                localVarQueryParameter['shopId'] = shopId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## GET products_listing_reports с пагинацией по айди продукта.
         * @summary GET products_listing_reports с пагинацией по айди продукта.
         * @param {string} guid GUID продукта
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsByProductIdGuidGet: async (guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsListingReportsByProductIdGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/listing_reports_by_product_id/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## GET products_listing_reports с пагинацией.
         * @summary GET products_listing_reports с пагинацией.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/listing_reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить запись из products_listing_reports.
         * @summary Удалить запись из products_listing_reports.
         * @param {string} guid GUID report-a
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsListingReportsGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/listing_reports/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## GET products_listing_reports by guid.
         * @summary GET products_listing_reports by guid.
         * @param {string} guid GUID report-а
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGuidGet: async (guid: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsListingReportsGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/listing_reports/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить products_listing_reports по гуиду. В боди важно отправить _id лаунча для обновления
         * @summary Изменить запись в products_listing_reports.
         * @param {string} guid GUID report-a
         * @param {InlineObject61} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGuidPatch: async (guid: string, body?: InlineObject61, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsListingReportsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/listing_reports/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Добавить products_listing_reports.
         * @summary Добавить запись в products_listing_reports.
         * @param {InlineObject60} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsPost: async (body?: InlineObject60, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/listing_reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить медиа-файлы по продукту
         * @summary # Получить медиа-файлы по продукту.
         * @param {string} guid GUID продукта
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMediaGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsProductsMediaGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/clients/products/media/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopId] ID магазина для фильтрации по нему
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMyGet: async (filters?: string, shopId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (shopId !== undefined) {
                localVarQueryParameter['shopId'] = shopId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр (DEPRECATED)
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [purchaseQuantityAboveZero] purchaseQuantity &gt; 0 булевое выражение
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMyWithPagGet: async (filters?: string, shopIds?: string, purchaseQuantityAboveZero?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/my_with_pag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (shopIds !== undefined) {
                localVarQueryParameter['shopIds'] = shopIds;
            }

            if (purchaseQuantityAboveZero !== undefined) {
                localVarQueryParameter['purchaseQuantityAboveZero'] = purchaseQuantityAboveZero;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [purchaseQuantityAboveZero] purchaseQuantity &gt; 0 булевое выражение
         * @param {string} [storekeeper] Гуид Сторкипера для сортировки по складам
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [preset] Использовать пресеты для таблицы?
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMyWithPagV2Get: async (filters?: string, shopIds?: string, purchaseQuantityAboveZero?: boolean, storekeeper?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', preset?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/my_with_pag_v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (shopIds !== undefined) {
                localVarQueryParameter['shopIds'] = shopIds;
            }

            if (purchaseQuantityAboveZero !== undefined) {
                localVarQueryParameter['purchaseQuantityAboveZero'] = purchaseQuantityAboveZero;
            }

            if (storekeeper !== undefined) {
                localVarQueryParameter['storekeeper'] = storekeeper;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (preset !== undefined) {
                localVarQueryParameter['preset'] = preset;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Добавить новый продукт клиентом.  ## В отличии от метода ресерчера, статус продукта ставиться автоматом  CREATED_BY_CLIENT 
         * @summary # Добавить новый продукт клиентом.
         * @param {InlineObject53} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsPost: async (body?: InlineObject53, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список  вакантных товаров. статусы 70 и 110(скрыты данные о поставщике, байере, супервайзере, создателе и skuByClient)  
         * @summary # Получить список вакантных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsVacGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/products/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export shops-data
         * @summary Export shops-data
         * @param {'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES'} table Table name
         * @param {string} [shopIds] Array of shop guids, separated by \&quot;,\&quot;
         * @param {string} [statusGroup] Name of status group for table or statuses separated by \&quot;,\&quot;
         * @param {boolean} [onAmazon] Destination flag
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsShopsExportGet: async (table: 'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES', shopIds?: string, statusGroup?: string, onAmazon?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'table' is not null or undefined
            assertParamExists('apiV1ClientsShopsExportGet', 'table', table)
            const localVarPath = `/api/v1/clients/shops/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (shopIds !== undefined) {
                localVarQueryParameter['shopIds'] = shopIds;
            }

            if (table !== undefined) {
                localVarQueryParameter['table'] = table;
            }

            if (statusGroup !== undefined) {
                localVarQueryParameter['statusGroup'] = statusGroup;
            }

            if (onAmazon !== undefined) {
                localVarQueryParameter['onAmazon'] = onAmazon;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить все пермишшены по магазинам
         * @summary  Получить все пермишшены по магазинам
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsShopsPermissionsGet: async (limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/shops/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Показать все задачи с коробками данного юзера.   
         * @summary # Показать все задачи с коробками данного юзера
         * @param {string} [filters]                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [storekeeperId] GUID сторкипера
         * @param {string} [operationType] Тип операции
         * @param {string} [priority] Приоритет задачи
         * @param {string} [status] Статус задачи
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksByBoxesGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', storekeeperId?: string, operationType?: string, priority?: string, status?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/tasks/by_boxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отменить задачу. Выставляет задаче статус 30.  
         * @summary # Отменить задачу.
         * @param {string} guid guid отменяемой задачи
         * @param {InlineObject52} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksCancelGuidPost: async (guid: string, body?: InlineObject52, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ClientsTasksCancelGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/clients/tasks/cancel/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Показать все задачи данного пользователя в данном складе.   
         * @summary # Показать все задачи данного пользователя в данном складе.
         * @param {string} [storekeeperId] GUID сторкипера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksGet: async (storekeeperId?: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать задачу.   
         * @summary # Создать задачу.
         * @param {InlineObject51} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksPost: async (body?: InlineObject51, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновить данные по магазинам, не дожидаясь обновления в 7 утра
         * @summary Обновить данные по магазинам, не дожидаясь обновления в 7 утра
         * @param {Array<string>} [body] 
         * @param {boolean} [queue] Запустить задачу в фоновом режиме?
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsUpdateStoreDataPatch: async (body?: Array<string>, queue?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients/update_store_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (queue !== undefined) {
                localVarQueryParameter['queue'] = queue;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Добавить рекомендацию.
         * @summary Добавить рекомендацию в storekeeper_product.
         * @param {InlineObject58} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsBoxesAddRecommendationForStockPost(body?: InlineObject58, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsBoxesAddRecommendationForStockPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Метод должен вычислять разницу между deliveryTotalPriceChanged и deliveryTotalPrice - (deliveryTotalPriceChanged-deliveryTotalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этой коробке из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа deliveryTotalPrice = deliveryTotalPriceChanged   ## Проверки:Только для коробок со статусом: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE
         * @summary # Подтвердить измение цены доставки за коробки.
         * @param {Array<InlineObject1>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsBoxesConfirmDeliveryPriceChangePost(body?: Array<InlineObject1>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsBoxesConfirmDeliveryPriceChangePost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить рекомендацию.
         * @summary Изменить рекомендацию в storekeeper_product.
         * @param {string} guid GUID записи
         * @param {InlineObject59} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsBoxesEditRecommendationForStockGuidPatch(guid: string, body?: InlineObject59, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsBoxesEditRecommendationForStockGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать shippingLabel в первый раз  Данный метод нужен чтобы отредактировать в первый раз shippingLabel коробки.         Проверки:         Доступен только для коробок ранее shippingLabel === null,         Доступен только для коробок со статусами IN_STOCK
         * @summary Редактировать shippingLabel в первый раз.
         * @param {string} guid GUID коробки
         * @param {InlineObject62} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch(guid: string, body?: InlineObject62, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Вернуть коробки обратно на склад  Данный метод нужен чтобы отменить запрос на отправку в партию или при отказе клиентом изменения цены         У клиента будут разморожены средства на доставку.         У коробок статус вернется на статус IN_STOCK         затирается партия (batchId = null)         Проверки:         Доступен только для коробок со статусами REQUESTED_SEND_TO_BATCH, NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, NEED_TO_UPDATE_THE_TARIFF
         * @summary Вернуть коробки обратно на склад.
         * @param {Array<InlineObject2>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsBoxesReturnBoxesToStockPost(body?: Array<InlineObject2>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsBoxesReturnBoxesToStockPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Обновить тариф если тариф был удален.  У коробок статус вернется на статус IN_BATCH или REQUESTED_SEND_TO_BATCH, в зависимости от того есть у коробки batchId         У клиента будут разморожены/разморожены средства на доставку в зависимости разницы стоимости.         Проверки:         Доступен только для коробок со статусами NEED_TO_UPDATE_THE_TARIFF
         * @summary Обновить тариф если тариф был удален.
         * @param {InlineObject57} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost(body?: InlineObject57, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все склады назначения.   
         * @summary #  Получить все склады назначения.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsDestinationGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AdminsOrdersDestination>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsDestinationGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Отдает дестинейшны со статусом коробки указаным в квери
         * @summary Отдает дестинейшны со статусом коробки указаным в квери
         * @param {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'} [status] Статус коробки, по которому будут отфильтрованы дестинейшны
         * @param {string} [storekeeperId] Гуид сторкипера дестинейшна
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsDestinationsGet(status?: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AdminsOrdersDestination>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsDestinationsGet(status, storekeeperId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить заказы текущего клиента через id товара.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   вернет все незавершенные заказы клиента, гед есть указанный товар.
         * @summary # Получить заказы текущего клиента через id товара.
         * @param {string} guid GUID товара
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsGetOrdersByProductIdGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsGetOrdersByProductIdGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Оплатить товары.   ## Данный эндпоинт выбросит ошибку если хотябы один из продуктов не будет валидным   ## Прижимаются товары со статусами [70, 110]  ## Товары со статусом 70 (созданные фрилансером) получают статус 275, товар полностью переходит к клиенту: createdById меняется на id клиента, isCreatedByClient меняется на true, needCheckBySupervisor меняется на true,  ## Проверка продуктов(валидация): Нельзя повторно покупать товар который был оплачен (product.status === 70 && product.paidById !== null)  ## Товары со статусом 110 (бесплатные от платформы) получают статус 76, клиент получает копию продукта без данных о ресерчере, баере и супервайзере.
         * @summary # Оплатить товары.
         * @param {InlineObject47} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsMakePaymentsPost(body?: InlineObject47, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsMakePaymentsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать заказ в статусе formed.   ## Статус автоматом ставиться formed: 0  Стоимость заказа = 0  Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
         * @summary # Создать заказ в статусе formed.
         * @param {InlineObject49} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersFormedPost(body?: InlineObject49, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersFormedPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить заказы текущего клиента.   
         * @summary # Получить заказы текущего клиента.
         * @param {string} [status] GUID сторкипера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersGet(status?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersGet(status, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Этот метод должен устанавливать статус ордеру 40(отменен клиентом), а так же брать из заказа поле totalPrice и  вычитать эту сумму у привязанного к заказу, клиента из поля balanceFreeze и прибавлять в поле balance  ## Проверки:  Данный метод возможно вызвать только при статусах readyToProcess: 10  и needConfirmingToPriceChange: 19, // требуется подтверждение для изменения цены)
         * @summary Отменить заказ.
         * @param {string} guid Guid ордера
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersGuidCancelPost(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersGuidCancelPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Метод должен вычислять разницу между totalPriceChanged и totalPrice - (totalPriceChanged-totalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этому ордеру из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа totalPrice = totalPriceChanged   ## Проверки:Только для заказов со статусом needConfirmingToPriceChange: 19
         * @summary # Подтвердить измение цены.
         * @param {string} guid Guid ордера
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersGuidConfirmPriceChangePost(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersGuidConfirmPriceChangePost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить заказ по его GUID.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   
         * @summary # Получить заказ по его GUID.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в заказ.   ## Обратить внимание - внутри заказа нельзя отдельно редактировать атрибуты товара.   ## Если изменился какой-то они товар, все равно нужно передать полностью новый массив с .   ## с товарами.   ## Данный метод возможно вызывать до выплат поставщику (пока paidAt === null)Проверки: тариф доставки должен принадлежать данному сторкиперу
         * @summary # Внести изменения в заказ.
         * @param {string} guid GUID заказа, который будет изменен
         * @param {InlineObject50} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersGuidPatch(guid: string, body?: InlineObject50, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать заказ.   ## Статус автоматом ставиться readyToProcess: 10  Стоимость заказа = количество * (цена товара + (цена доставки паритии / количество товара в партии)):  Эта сумма будет заморожена у клиента. Курс записывается из админки Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
         * @summary # Создать заказ.
         * @param {InlineObject48} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersPost(body?: InlineObject48, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
         * @summary # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
         * @param {string} guid GUID заказа, который будет изменен
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsOrdersToReadyToProcessGuidPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsOrdersToReadyToProcessGuidPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить заказы текущего клиента.   
         * @summary # Получить заказы текущего клиента.
         * @param {string} [status] Статусы заказов, по которым идет фильтрация, разделенные запятыми
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsPagOrdersGet(status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsPagOrdersGet(status, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Получить данные продукта по гуиду
         * @summary # Получить данные продукта по гуиду
         * @param {string} guid GUID продукта
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsDataGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsDataGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отправить  созданные клиентом товары на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
         * @summary # Отправить  созданные клиентом товары на проверку супервайзеру.
         * @param {InlineObject55} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch(body?: InlineObject55, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
         * @summary # Получить цену для клиента на поиск поставщика множества товаров
         * @param {InlineObject54} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGetPriceForClientPost(body?: InlineObject54, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGetPriceForClientPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в баркод товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в баркод товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidChangeBarCodePatch(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidChangeBarCodePatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в fourMonthesStock товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в fourMonthesStock товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidFourMonthesStockPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidFourMonthesStockPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отправить  созданный клиентом товар на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
         * @summary # Отправить  созданный клиентом товар на проверку супервайзеру.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject56} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch(guid: string, body?: InlineObject56, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
         * @summary # Получить цену для клиента на поиск поставщика
         * @param {string} guid GUID продукта, который будет изменен
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidGetPriceForClientGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidGetPriceForClientGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в товар.   Если товар был создан ресерчером (статус до 100) менять можно только баркод (нет проверки).   ## Если товар был создан клиентом (статус от 200):  Вам разрешено редактировать свой товар или добавлять поставщика только если ранее товар имел статусы 200, 270, 275, 280, 290  
         * @summary # Внести изменения в товар.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject44} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidPatch(guid: string, body?: InlineObject44, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в stockUSA товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в stockUSA товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidStockUSAPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidStockUSAPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в защиту листинга товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в защиту листинга товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject46} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidTransparencyPatch(guid: string, body?: InlineObject46, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidTransparencyPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в seo-файлы товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в seo-файлы товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject45} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsGuidUpdateSeoFilesPatch(guid: string, body?: InlineObject45, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsGuidUpdateSeoFilesPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список продуктов для заказов. 
         * @summary # Получить список продуктов.
         * @param {string} productIds Гуиды продуктов
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsInfoForOrdersGet(productIds: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20033>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsInfoForOrdersGet(productIds, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить облегченный список товаров(archive = false)
         * @summary # Получить облегченный список товаров
         * @param {boolean} [isChild] Существуют ли у продукта родитель
         * @param {boolean} [isParent] Является ли продукт родителем
         * @param {string} [shopId] ID магазина для фильтрации по нему
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsLightGet(isChild?: boolean, isParent?: boolean, shopId?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsLightGet(isChild, isParent, shopId, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## GET products_listing_reports с пагинацией по айди продукта.
         * @summary GET products_listing_reports с пагинацией по айди продукта.
         * @param {string} guid GUID продукта
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsListingReportsByProductIdGuidGet(guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsListingReportsByProductIdGuidGet(guid, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## GET products_listing_reports с пагинацией.
         * @summary GET products_listing_reports с пагинацией.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsListingReportsGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsListingReportsGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить запись из products_listing_reports.
         * @summary Удалить запись из products_listing_reports.
         * @param {string} guid GUID report-a
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsListingReportsGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsListingReportsGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## GET products_listing_reports by guid.
         * @summary GET products_listing_reports by guid.
         * @param {string} guid GUID report-а
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsListingReportsGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042Rows>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsListingReportsGuidGet(guid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить products_listing_reports по гуиду. В боди важно отправить _id лаунча для обновления
         * @summary Изменить запись в products_listing_reports.
         * @param {string} guid GUID report-a
         * @param {InlineObject61} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsListingReportsGuidPatch(guid: string, body?: InlineObject61, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsListingReportsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Добавить products_listing_reports.
         * @summary Добавить запись в products_listing_reports.
         * @param {InlineObject60} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsListingReportsPost(body?: InlineObject60, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsListingReportsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить медиа-файлы по продукту
         * @summary # Получить медиа-файлы по продукту.
         * @param {string} guid GUID продукта
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsMediaGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsMediaGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopId] ID магазина для фильтрации по нему
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsMyGet(filters?: string, shopId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsMyGet(filters, shopId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр (DEPRECATED)
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [purchaseQuantityAboveZero] purchaseQuantity &gt; 0 булевое выражение
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsMyWithPagGet(filters?: string, shopIds?: string, purchaseQuantityAboveZero?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsMyWithPagGet(filters, shopIds, purchaseQuantityAboveZero, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [purchaseQuantityAboveZero] purchaseQuantity &gt; 0 булевое выражение
         * @param {string} [storekeeper] Гуид Сторкипера для сортировки по складам
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [preset] Использовать пресеты для таблицы?
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsMyWithPagV2Get(filters?: string, shopIds?: string, purchaseQuantityAboveZero?: boolean, storekeeper?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', preset?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsMyWithPagV2Get(filters, shopIds, purchaseQuantityAboveZero, storekeeper, limit, offset, sortField, sortType, preset, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Добавить новый продукт клиентом.  ## В отличии от метода ресерчера, статус продукта ставиться автоматом  CREATED_BY_CLIENT 
         * @summary # Добавить новый продукт клиентом.
         * @param {InlineObject53} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsPost(body?: InlineObject53, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список  вакантных товаров. статусы 70 и 110(скрыты данные о поставщике, байере, супервайзере, создателе и skuByClient)  
         * @summary # Получить список вакантных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsProductsVacGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20033>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsProductsVacGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export shops-data
         * @summary Export shops-data
         * @param {'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES'} table Table name
         * @param {string} [shopIds] Array of shop guids, separated by \&quot;,\&quot;
         * @param {string} [statusGroup] Name of status group for table or statuses separated by \&quot;,\&quot;
         * @param {boolean} [onAmazon] Destination flag
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsShopsExportGet(table: 'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES', shopIds?: string, statusGroup?: string, onAmazon?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AdminsOrdersDestination>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsShopsExportGet(table, shopIds, statusGroup, onAmazon, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить все пермишшены по магазинам
         * @summary  Получить все пермишшены по магазинам
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsShopsPermissionsGet(limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsShopsPermissionsGet(limit, offset, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Показать все задачи с коробками данного юзера.   
         * @summary # Показать все задачи с коробками данного юзера
         * @param {string} [filters]                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [storekeeperId] GUID сторкипера
         * @param {string} [operationType] Тип операции
         * @param {string} [priority] Приоритет задачи
         * @param {string} [status] Статус задачи
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsTasksByBoxesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', storekeeperId?: string, operationType?: string, priority?: string, status?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsTasksByBoxesGet(filters, limit, offset, sortField, sortType, storekeeperId, operationType, priority, status, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отменить задачу. Выставляет задаче статус 30.  
         * @summary # Отменить задачу.
         * @param {string} guid guid отменяемой задачи
         * @param {InlineObject52} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsTasksCancelGuidPost(guid: string, body?: InlineObject52, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsTasksCancelGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Показать все задачи данного пользователя в данном складе.   
         * @summary # Показать все задачи данного пользователя в данном складе.
         * @param {string} [storekeeperId] GUID сторкипера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsTasksGet(storekeeperId?: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsTasksGet(storekeeperId, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать задачу.   
         * @summary # Создать задачу.
         * @param {InlineObject51} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsTasksPost(body?: InlineObject51, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsTasksPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Обновить данные по магазинам, не дожидаясь обновления в 7 утра
         * @summary Обновить данные по магазинам, не дожидаясь обновления в 7 утра
         * @param {Array<string>} [body] 
         * @param {boolean} [queue] Запустить задачу в фоновом режиме?
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ClientsUpdateStoreDataPatch(body?: Array<string>, queue?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ClientsUpdateStoreDataPatch(body, queue, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * ## Добавить рекомендацию.
         * @summary Добавить рекомендацию в storekeeper_product.
         * @param {InlineObject58} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesAddRecommendationForStockPost(body?: InlineObject58, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsBoxesAddRecommendationForStockPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Метод должен вычислять разницу между deliveryTotalPriceChanged и deliveryTotalPrice - (deliveryTotalPriceChanged-deliveryTotalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этой коробке из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа deliveryTotalPrice = deliveryTotalPriceChanged   ## Проверки:Только для коробок со статусом: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE
         * @summary # Подтвердить измение цены доставки за коробки.
         * @param {Array<InlineObject1>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesConfirmDeliveryPriceChangePost(body?: Array<InlineObject1>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsBoxesConfirmDeliveryPriceChangePost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить рекомендацию.
         * @summary Изменить рекомендацию в storekeeper_product.
         * @param {string} guid GUID записи
         * @param {InlineObject59} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesEditRecommendationForStockGuidPatch(guid: string, body?: InlineObject59, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsBoxesEditRecommendationForStockGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать shippingLabel в первый раз  Данный метод нужен чтобы отредактировать в первый раз shippingLabel коробки.         Проверки:         Доступен только для коробок ранее shippingLabel === null,         Доступен только для коробок со статусами IN_STOCK
         * @summary Редактировать shippingLabel в первый раз.
         * @param {string} guid GUID коробки
         * @param {InlineObject62} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch(guid: string, body?: InlineObject62, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Вернуть коробки обратно на склад  Данный метод нужен чтобы отменить запрос на отправку в партию или при отказе клиентом изменения цены         У клиента будут разморожены средства на доставку.         У коробок статус вернется на статус IN_STOCK         затирается партия (batchId = null)         Проверки:         Доступен только для коробок со статусами REQUESTED_SEND_TO_BATCH, NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, NEED_TO_UPDATE_THE_TARIFF
         * @summary Вернуть коробки обратно на склад.
         * @param {Array<InlineObject2>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesReturnBoxesToStockPost(body?: Array<InlineObject2>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsBoxesReturnBoxesToStockPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Обновить тариф если тариф был удален.  У коробок статус вернется на статус IN_BATCH или REQUESTED_SEND_TO_BATCH, в зависимости от того есть у коробки batchId         У клиента будут разморожены/разморожены средства на доставку в зависимости разницы стоимости.         Проверки:         Доступен только для коробок со статусами NEED_TO_UPDATE_THE_TARIFF
         * @summary Обновить тариф если тариф был удален.
         * @param {InlineObject57} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost(body?: InlineObject57, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все склады назначения.   
         * @summary #  Получить все склады назначения.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsDestinationGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AdminsOrdersDestination>> {
            return localVarFp.apiV1ClientsDestinationGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Отдает дестинейшны со статусом коробки указаным в квери
         * @summary Отдает дестинейшны со статусом коробки указаным в квери
         * @param {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'} [status] Статус коробки, по которому будут отфильтрованы дестинейшны
         * @param {string} [storekeeperId] Гуид сторкипера дестинейшна
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsDestinationsGet(status?: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AdminsOrdersDestination>> {
            return localVarFp.apiV1ClientsDestinationsGet(status, storekeeperId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить заказы текущего клиента через id товара.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   вернет все незавершенные заказы клиента, гед есть указанный товар.
         * @summary # Получить заказы текущего клиента через id товара.
         * @param {string} guid GUID товара
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsGetOrdersByProductIdGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2001>> {
            return localVarFp.apiV1ClientsGetOrdersByProductIdGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Оплатить товары.   ## Данный эндпоинт выбросит ошибку если хотябы один из продуктов не будет валидным   ## Прижимаются товары со статусами [70, 110]  ## Товары со статусом 70 (созданные фрилансером) получают статус 275, товар полностью переходит к клиенту: createdById меняется на id клиента, isCreatedByClient меняется на true, needCheckBySupervisor меняется на true,  ## Проверка продуктов(валидация): Нельзя повторно покупать товар который был оплачен (product.status === 70 && product.paidById !== null)  ## Товары со статусом 110 (бесплатные от платформы) получают статус 76, клиент получает копию продукта без данных о ресерчере, баере и супервайзере.
         * @summary # Оплатить товары.
         * @param {InlineObject47} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsMakePaymentsPost(body?: InlineObject47, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsMakePaymentsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать заказ в статусе formed.   ## Статус автоматом ставиться formed: 0  Стоимость заказа = 0  Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
         * @summary # Создать заказ в статусе formed.
         * @param {InlineObject49} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersFormedPost(body?: InlineObject49, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.apiV1ClientsOrdersFormedPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить заказы текущего клиента.   
         * @summary # Получить заказы текущего клиента.
         * @param {string} [status] GUID сторкипера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGet(status?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2001>> {
            return localVarFp.apiV1ClientsOrdersGet(status, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Этот метод должен устанавливать статус ордеру 40(отменен клиентом), а так же брать из заказа поле totalPrice и  вычитать эту сумму у привязанного к заказу, клиента из поля balanceFreeze и прибавлять в поле balance  ## Проверки:  Данный метод возможно вызвать только при статусах readyToProcess: 10  и needConfirmingToPriceChange: 19, // требуется подтверждение для изменения цены)
         * @summary Отменить заказ.
         * @param {string} guid Guid ордера
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidCancelPost(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsOrdersGuidCancelPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Метод должен вычислять разницу между totalPriceChanged и totalPrice - (totalPriceChanged-totalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этому ордеру из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа totalPrice = totalPriceChanged   ## Проверки:Только для заказов со статусом needConfirmingToPriceChange: 19
         * @summary # Подтвердить измение цены.
         * @param {string} guid Guid ордера
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidConfirmPriceChangePost(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsOrdersGuidConfirmPriceChangePost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить заказ по его GUID.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   
         * @summary # Получить заказ по его GUID.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1ClientsOrdersGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в заказ.   ## Обратить внимание - внутри заказа нельзя отдельно редактировать атрибуты товара.   ## Если изменился какой-то они товар, все равно нужно передать полностью новый массив с .   ## с товарами.   ## Данный метод возможно вызывать до выплат поставщику (пока paidAt === null)Проверки: тариф доставки должен принадлежать данному сторкиперу
         * @summary # Внести изменения в заказ.
         * @param {string} guid GUID заказа, который будет изменен
         * @param {InlineObject50} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersGuidPatch(guid: string, body?: InlineObject50, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsOrdersGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать заказ.   ## Статус автоматом ставиться readyToProcess: 10  Стоимость заказа = количество * (цена товара + (цена доставки паритии / количество товара в партии)):  Эта сумма будет заморожена у клиента. Курс записывается из админки Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
         * @summary # Создать заказ.
         * @param {InlineObject48} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersPost(body?: InlineObject48, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.apiV1ClientsOrdersPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
         * @summary # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
         * @param {string} guid GUID заказа, который будет изменен
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsOrdersToReadyToProcessGuidPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsOrdersToReadyToProcessGuidPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить заказы текущего клиента.   
         * @summary # Получить заказы текущего клиента.
         * @param {string} [status] Статусы заказов, по которым идет фильтрация, разделенные запятыми
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsPagOrdersGet(status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20039> {
            return localVarFp.apiV1ClientsPagOrdersGet(status, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Получить данные продукта по гуиду
         * @summary # Получить данные продукта по гуиду
         * @param {string} guid GUID продукта
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsDataGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20038> {
            return localVarFp.apiV1ClientsProductsDataGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отправить  созданные клиентом товары на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
         * @summary # Отправить  созданные клиентом товары на проверку супервайзеру.
         * @param {InlineObject55} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch(body?: InlineObject55, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
         * @summary # Получить цену для клиента на поиск поставщика множества товаров
         * @param {InlineObject54} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGetPriceForClientPost(body?: InlineObject54, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.apiV1ClientsProductsGetPriceForClientPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в баркод товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в баркод товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidChangeBarCodePatch(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidChangeBarCodePatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в fourMonthesStock товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в fourMonthesStock товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidFourMonthesStockPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidFourMonthesStockPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отправить  созданный клиентом товар на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
         * @summary # Отправить  созданный клиентом товар на проверку супервайзеру.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject56} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch(guid: string, body?: InlineObject56, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
         * @summary # Получить цену для клиента на поиск поставщика
         * @param {string} guid GUID продукта, который будет изменен
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidGetPriceForClientGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.apiV1ClientsProductsGuidGetPriceForClientGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в товар.   Если товар был создан ресерчером (статус до 100) менять можно только баркод (нет проверки).   ## Если товар был создан клиентом (статус от 200):  Вам разрешено редактировать свой товар или добавлять поставщика только если ранее товар имел статусы 200, 270, 275, 280, 290  
         * @summary # Внести изменения в товар.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject44} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidPatch(guid: string, body?: InlineObject44, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в stockUSA товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в stockUSA товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidStockUSAPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidStockUSAPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в защиту листинга товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в защиту листинга товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject46} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidTransparencyPatch(guid: string, body?: InlineObject46, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidTransparencyPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в seo-файлы товара.   Проверки:  Данный товар не принадлежит вам.
         * @summary # Внести изменения в seo-файлы товара.
         * @param {string} guid GUID продукта, который будет изменен
         * @param {InlineObject45} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsGuidUpdateSeoFilesPatch(guid: string, body?: InlineObject45, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsGuidUpdateSeoFilesPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список продуктов для заказов. 
         * @summary # Получить список продуктов.
         * @param {string} productIds Гуиды продуктов
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsInfoForOrdersGet(productIds: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20033>> {
            return localVarFp.apiV1ClientsProductsInfoForOrdersGet(productIds, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить облегченный список товаров(archive = false)
         * @summary # Получить облегченный список товаров
         * @param {boolean} [isChild] Существуют ли у продукта родитель
         * @param {boolean} [isParent] Является ли продукт родителем
         * @param {string} [shopId] ID магазина для фильтрации по нему
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsLightGet(isChild?: boolean, isParent?: boolean, shopId?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.apiV1ClientsProductsLightGet(isChild, isParent, shopId, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## GET products_listing_reports с пагинацией по айди продукта.
         * @summary GET products_listing_reports с пагинацией по айди продукта.
         * @param {string} guid GUID продукта
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsByProductIdGuidGet(guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20043> {
            return localVarFp.apiV1ClientsProductsListingReportsByProductIdGuidGet(guid, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## GET products_listing_reports с пагинацией.
         * @summary GET products_listing_reports с пагинацией.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20042> {
            return localVarFp.apiV1ClientsProductsListingReportsGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить запись из products_listing_reports.
         * @summary Удалить запись из products_listing_reports.
         * @param {string} guid GUID report-a
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsListingReportsGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## GET products_listing_reports by guid.
         * @summary GET products_listing_reports by guid.
         * @param {string} guid GUID report-а
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20042Rows> {
            return localVarFp.apiV1ClientsProductsListingReportsGuidGet(guid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить products_listing_reports по гуиду. В боди важно отправить _id лаунча для обновления
         * @summary Изменить запись в products_listing_reports.
         * @param {string} guid GUID report-a
         * @param {InlineObject61} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsGuidPatch(guid: string, body?: InlineObject61, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsProductsListingReportsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Добавить products_listing_reports.
         * @summary Добавить запись в products_listing_reports.
         * @param {InlineObject60} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsListingReportsPost(body?: InlineObject60, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.apiV1ClientsProductsListingReportsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить медиа-файлы по продукту
         * @summary # Получить медиа-файлы по продукту.
         * @param {string} guid GUID продукта
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMediaGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.apiV1ClientsProductsMediaGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopId] ID магазина для фильтрации по нему
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMyGet(filters?: string, shopId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200>> {
            return localVarFp.apiV1ClientsProductsMyGet(filters, shopId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр (DEPRECATED)
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [purchaseQuantityAboveZero] purchaseQuantity &gt; 0 булевое выражение
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMyWithPagGet(filters?: string, shopIds?: string, purchaseQuantityAboveZero?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.apiV1ClientsProductsMyWithPagGet(filters, shopIds, purchaseQuantityAboveZero, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
         * @summary # Получить список товаров данного клиента используя фильтр
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [purchaseQuantityAboveZero] purchaseQuantity &gt; 0 булевое выражение
         * @param {string} [storekeeper] Гуид Сторкипера для сортировки по складам
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [preset] Использовать пресеты для таблицы?
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsMyWithPagV2Get(filters?: string, shopIds?: string, purchaseQuantityAboveZero?: boolean, storekeeper?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', preset?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20037> {
            return localVarFp.apiV1ClientsProductsMyWithPagV2Get(filters, shopIds, purchaseQuantityAboveZero, storekeeper, limit, offset, sortField, sortType, preset, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Добавить новый продукт клиентом.  ## В отличии от метода ресерчера, статус продукта ставиться автоматом  CREATED_BY_CLIENT 
         * @summary # Добавить новый продукт клиентом.
         * @param {InlineObject53} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsPost(body?: InlineObject53, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.apiV1ClientsProductsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список  вакантных товаров. статусы 70 и 110(скрыты данные о поставщике, байере, супервайзере, создателе и skuByClient)  
         * @summary # Получить список вакантных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsProductsVacGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20033>> {
            return localVarFp.apiV1ClientsProductsVacGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Export shops-data
         * @summary Export shops-data
         * @param {'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES'} table Table name
         * @param {string} [shopIds] Array of shop guids, separated by \&quot;,\&quot;
         * @param {string} [statusGroup] Name of status group for table or statuses separated by \&quot;,\&quot;
         * @param {boolean} [onAmazon] Destination flag
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsShopsExportGet(table: 'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES', shopIds?: string, statusGroup?: string, onAmazon?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AdminsOrdersDestination>> {
            return localVarFp.apiV1ClientsShopsExportGet(table, shopIds, statusGroup, onAmazon, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить все пермишшены по магазинам
         * @summary  Получить все пермишшены по магазинам
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsShopsPermissionsGet(limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20044> {
            return localVarFp.apiV1ClientsShopsPermissionsGet(limit, offset, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Показать все задачи с коробками данного юзера.   
         * @summary # Показать все задачи с коробками данного юзера
         * @param {string} [filters]                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [storekeeperId] GUID сторкипера
         * @param {string} [operationType] Тип операции
         * @param {string} [priority] Приоритет задачи
         * @param {string} [status] Статус задачи
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksByBoxesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', storekeeperId?: string, operationType?: string, priority?: string, status?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.apiV1ClientsTasksByBoxesGet(filters, limit, offset, sortField, sortType, storekeeperId, operationType, priority, status, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отменить задачу. Выставляет задаче статус 30.  
         * @summary # Отменить задачу.
         * @param {string} guid guid отменяемой задачи
         * @param {InlineObject52} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksCancelGuidPost(guid: string, body?: InlineObject52, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsTasksCancelGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Показать все задачи данного пользователя в данном складе.   
         * @summary # Показать все задачи данного пользователя в данном складе.
         * @param {string} [storekeeperId] GUID сторкипера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksGet(storekeeperId?: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.apiV1ClientsTasksGet(storekeeperId, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать задачу.   
         * @summary # Создать задачу.
         * @param {InlineObject51} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsTasksPost(body?: InlineObject51, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.apiV1ClientsTasksPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновить данные по магазинам, не дожидаясь обновления в 7 утра
         * @summary Обновить данные по магазинам, не дожидаясь обновления в 7 утра
         * @param {Array<string>} [body] 
         * @param {boolean} [queue] Запустить задачу в фоновом режиме?
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ClientsUpdateStoreDataPatch(body?: Array<string>, queue?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ClientsUpdateStoreDataPatch(body, queue, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1ClientsBoxesAddRecommendationForStockPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsBoxesAddRecommendationForStockPostRequest
 */
export interface ClientApiApiV1ClientsBoxesAddRecommendationForStockPostRequest {
    /**
     * 
     * @type {InlineObject58}
     * @memberof ClientApiApiV1ClientsBoxesAddRecommendationForStockPost
     */
    readonly body?: InlineObject58

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesAddRecommendationForStockPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsBoxesConfirmDeliveryPriceChangePost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsBoxesConfirmDeliveryPriceChangePostRequest
 */
export interface ClientApiApiV1ClientsBoxesConfirmDeliveryPriceChangePostRequest {
    /**
     * 
     * @type {Array<InlineObject1>}
     * @memberof ClientApiApiV1ClientsBoxesConfirmDeliveryPriceChangePost
     */
    readonly body?: Array<InlineObject1>

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesConfirmDeliveryPriceChangePost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsBoxesEditRecommendationForStockGuidPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatchRequest
 */
export interface ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatchRequest {
    /**
     * GUID записи
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject59}
     * @memberof ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatch
     */
    readonly body?: InlineObject59

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatchRequest
 */
export interface ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatchRequest {
    /**
     * GUID коробки
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject62}
     * @memberof ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch
     */
    readonly body?: InlineObject62

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsBoxesReturnBoxesToStockPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsBoxesReturnBoxesToStockPostRequest
 */
export interface ClientApiApiV1ClientsBoxesReturnBoxesToStockPostRequest {
    /**
     * 
     * @type {Array<InlineObject2>}
     * @memberof ClientApiApiV1ClientsBoxesReturnBoxesToStockPost
     */
    readonly body?: Array<InlineObject2>

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesReturnBoxesToStockPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPostRequest
 */
export interface ClientApiApiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPostRequest {
    /**
     * 
     * @type {InlineObject57}
     * @memberof ClientApiApiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost
     */
    readonly body?: InlineObject57

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsDestinationGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsDestinationGetRequest
 */
export interface ClientApiApiV1ClientsDestinationGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsDestinationGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsDestinationsGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsDestinationsGetRequest
 */
export interface ClientApiApiV1ClientsDestinationsGetRequest {
    /**
     * Статус коробки, по которому будут отфильтрованы дестинейшны
     * @type {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'}
     * @memberof ClientApiApiV1ClientsDestinationsGet
     */
    readonly status?: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'

    /**
     * Гуид сторкипера дестинейшна
     * @type {string}
     * @memberof ClientApiApiV1ClientsDestinationsGet
     */
    readonly storekeeperId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsDestinationsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsDestinationsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsGetOrdersByProductIdGuidGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsGetOrdersByProductIdGuidGetRequest
 */
export interface ClientApiApiV1ClientsGetOrdersByProductIdGuidGetRequest {
    /**
     * GUID товара
     * @type {string}
     * @memberof ClientApiApiV1ClientsGetOrdersByProductIdGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsGetOrdersByProductIdGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsMakePaymentsPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsMakePaymentsPostRequest
 */
export interface ClientApiApiV1ClientsMakePaymentsPostRequest {
    /**
     * 
     * @type {InlineObject47}
     * @memberof ClientApiApiV1ClientsMakePaymentsPost
     */
    readonly body?: InlineObject47

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsMakePaymentsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersFormedPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersFormedPostRequest
 */
export interface ClientApiApiV1ClientsOrdersFormedPostRequest {
    /**
     * 
     * @type {InlineObject49}
     * @memberof ClientApiApiV1ClientsOrdersFormedPost
     */
    readonly body?: InlineObject49

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersFormedPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersGetRequest
 */
export interface ClientApiApiV1ClientsOrdersGetRequest {
    /**
     * GUID сторкипера
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGet
     */
    readonly status?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsOrdersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersGuidCancelPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersGuidCancelPostRequest
 */
export interface ClientApiApiV1ClientsOrdersGuidCancelPostRequest {
    /**
     * Guid ордера
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidCancelPost
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof ClientApiApiV1ClientsOrdersGuidCancelPost
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidCancelPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersGuidConfirmPriceChangePost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePostRequest
 */
export interface ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePostRequest {
    /**
     * Guid ордера
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePost
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePost
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersGuidGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersGuidGetRequest
 */
export interface ClientApiApiV1ClientsOrdersGuidGetRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersGuidPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersGuidPatchRequest
 */
export interface ClientApiApiV1ClientsOrdersGuidPatchRequest {
    /**
     * GUID заказа, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject50}
     * @memberof ClientApiApiV1ClientsOrdersGuidPatch
     */
    readonly body?: InlineObject50

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersPostRequest
 */
export interface ClientApiApiV1ClientsOrdersPostRequest {
    /**
     * 
     * @type {InlineObject48}
     * @memberof ClientApiApiV1ClientsOrdersPost
     */
    readonly body?: InlineObject48

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsOrdersToReadyToProcessGuidPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsOrdersToReadyToProcessGuidPatchRequest
 */
export interface ClientApiApiV1ClientsOrdersToReadyToProcessGuidPatchRequest {
    /**
     * GUID заказа, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersToReadyToProcessGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsOrdersToReadyToProcessGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsPagOrdersGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsPagOrdersGetRequest
 */
export interface ClientApiApiV1ClientsPagOrdersGetRequest {
    /**
     * Статусы заказов, по которым идет фильтрация, разделенные запятыми
     * @type {string}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly status?: string

    /**
     *                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsPagOrdersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsDataGuidGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsDataGuidGetRequest
 */
export interface ClientApiApiV1ClientsProductsDataGuidGetRequest {
    /**
     * GUID продукта
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsDataGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsDataGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatchRequest
 */
export interface ClientApiApiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatchRequest {
    /**
     * 
     * @type {InlineObject55}
     * @memberof ClientApiApiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch
     */
    readonly body?: InlineObject55

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGetPriceForClientPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGetPriceForClientPostRequest
 */
export interface ClientApiApiV1ClientsProductsGetPriceForClientPostRequest {
    /**
     * 
     * @type {InlineObject54}
     * @memberof ClientApiApiV1ClientsProductsGetPriceForClientPost
     */
    readonly body?: InlineObject54

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGetPriceForClientPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidChangeBarCodePatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidChangeBarCodePatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidChangeBarCodePatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidChangeBarCodePatch
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof ClientApiApiV1ClientsProductsGuidChangeBarCodePatch
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidChangeBarCodePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidFourMonthesStockPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidFourMonthesStockPatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidFourMonthesStockPatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidFourMonthesStockPatch
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof ClientApiApiV1ClientsProductsGuidFourMonthesStockPatch
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidFourMonthesStockPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject56}
     * @memberof ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch
     */
    readonly body?: InlineObject56

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidGetPriceForClientGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidGetPriceForClientGetRequest
 */
export interface ClientApiApiV1ClientsProductsGuidGetPriceForClientGetRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidGetPriceForClientGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidGetPriceForClientGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidPatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidPatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject44}
     * @memberof ClientApiApiV1ClientsProductsGuidPatch
     */
    readonly body?: InlineObject44

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidStockUSAPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidStockUSAPatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidStockUSAPatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidStockUSAPatch
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof ClientApiApiV1ClientsProductsGuidStockUSAPatch
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidStockUSAPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidTransparencyPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidTransparencyPatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidTransparencyPatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidTransparencyPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject46}
     * @memberof ClientApiApiV1ClientsProductsGuidTransparencyPatch
     */
    readonly body?: InlineObject46

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidTransparencyPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsGuidUpdateSeoFilesPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatchRequest
 */
export interface ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatchRequest {
    /**
     * GUID продукта, который будет изменен
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject45}
     * @memberof ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatch
     */
    readonly body?: InlineObject45

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsInfoForOrdersGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsInfoForOrdersGetRequest
 */
export interface ClientApiApiV1ClientsProductsInfoForOrdersGetRequest {
    /**
     * Гуиды продуктов
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsInfoForOrdersGet
     */
    readonly productIds: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsInfoForOrdersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsLightGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsLightGetRequest
 */
export interface ClientApiApiV1ClientsProductsLightGetRequest {
    /**
     * Существуют ли у продукта родитель
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly isChild?: boolean

    /**
     * Является ли продукт родителем
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly isParent?: boolean

    /**
     * ID магазина для фильтрации по нему
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly shopId?: string

    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsLightGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsListingReportsByProductIdGuidGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGetRequest
 */
export interface ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGetRequest {
    /**
     * GUID продукта
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly guid: string

    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsListingReportsGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsListingReportsGetRequest
 */
export interface ClientApiApiV1ClientsProductsListingReportsGetRequest {
    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsListingReportsGuidDelete operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsListingReportsGuidDeleteRequest
 */
export interface ClientApiApiV1ClientsProductsListingReportsGuidDeleteRequest {
    /**
     * GUID report-a
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsListingReportsGuidGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsListingReportsGuidGetRequest
 */
export interface ClientApiApiV1ClientsProductsListingReportsGuidGetRequest {
    /**
     * GUID report-а
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsListingReportsGuidPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsListingReportsGuidPatchRequest
 */
export interface ClientApiApiV1ClientsProductsListingReportsGuidPatchRequest {
    /**
     * GUID report-a
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject61}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidPatch
     */
    readonly body?: InlineObject61

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsListingReportsPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsListingReportsPostRequest
 */
export interface ClientApiApiV1ClientsProductsListingReportsPostRequest {
    /**
     * 
     * @type {InlineObject60}
     * @memberof ClientApiApiV1ClientsProductsListingReportsPost
     */
    readonly body?: InlineObject60

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsListingReportsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsMediaGuidGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsMediaGuidGetRequest
 */
export interface ClientApiApiV1ClientsProductsMediaGuidGetRequest {
    /**
     * GUID продукта
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMediaGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMediaGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsMyGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsMyGetRequest
 */
export interface ClientApiApiV1ClientsProductsMyGetRequest {
    /**
     *                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyGet
     */
    readonly filters?: string

    /**
     * ID магазина для фильтрации по нему
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyGet
     */
    readonly shopId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsMyGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsMyWithPagGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsMyWithPagGetRequest
 */
export interface ClientApiApiV1ClientsProductsMyWithPagGetRequest {
    /**
     *                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly filters?: string

    /**
     * Гуиды магазинов
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly shopIds?: string

    /**
     * purchaseQuantity &gt; 0 булевое выражение
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly purchaseQuantityAboveZero?: boolean

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsMyWithPagV2Get operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsMyWithPagV2GetRequest
 */
export interface ClientApiApiV1ClientsProductsMyWithPagV2GetRequest {
    /**
     *                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly filters?: string

    /**
     * Гуиды магазинов
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly shopIds?: string

    /**
     * purchaseQuantity &gt; 0 булевое выражение
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly purchaseQuantityAboveZero?: boolean

    /**
     * Гуид Сторкипера для сортировки по складам
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly storekeeper?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Использовать пресеты для таблицы?
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly preset?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsMyWithPagV2Get
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsPostRequest
 */
export interface ClientApiApiV1ClientsProductsPostRequest {
    /**
     * 
     * @type {InlineObject53}
     * @memberof ClientApiApiV1ClientsProductsPost
     */
    readonly body?: InlineObject53

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsProductsVacGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsProductsVacGetRequest
 */
export interface ClientApiApiV1ClientsProductsVacGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsProductsVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsShopsExportGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsShopsExportGetRequest
 */
export interface ClientApiApiV1ClientsShopsExportGetRequest {
    /**
     * Table name
     * @type {'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES'}
     * @memberof ClientApiApiV1ClientsShopsExportGet
     */
    readonly table: 'INVENTORY' | 'ORDERS' | 'BATCHES' | 'BOXES'

    /**
     * Array of shop guids, separated by \&quot;,\&quot;
     * @type {string}
     * @memberof ClientApiApiV1ClientsShopsExportGet
     */
    readonly shopIds?: string

    /**
     * Name of status group for table or statuses separated by \&quot;,\&quot;
     * @type {string}
     * @memberof ClientApiApiV1ClientsShopsExportGet
     */
    readonly statusGroup?: string

    /**
     * Destination flag
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsShopsExportGet
     */
    readonly onAmazon?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsShopsExportGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsShopsPermissionsGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsShopsPermissionsGetRequest
 */
export interface ClientApiApiV1ClientsShopsPermissionsGetRequest {
    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsShopsPermissionsGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsShopsPermissionsGet
     */
    readonly offset?: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsShopsPermissionsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsShopsPermissionsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsTasksByBoxesGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsTasksByBoxesGetRequest
 */
export interface ClientApiApiV1ClientsTasksByBoxesGetRequest {
    /**
     *                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * GUID сторкипера
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly storekeeperId?: string

    /**
     * Тип операции
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly operationType?: string

    /**
     * Приоритет задачи
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly priority?: string

    /**
     * Статус задачи
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly status?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksByBoxesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsTasksCancelGuidPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsTasksCancelGuidPostRequest
 */
export interface ClientApiApiV1ClientsTasksCancelGuidPostRequest {
    /**
     * guid отменяемой задачи
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksCancelGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject52}
     * @memberof ClientApiApiV1ClientsTasksCancelGuidPost
     */
    readonly body?: InlineObject52

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksCancelGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsTasksGet operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsTasksGetRequest
 */
export interface ClientApiApiV1ClientsTasksGetRequest {
    /**
     * GUID сторкипера
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksGet
     */
    readonly storekeeperId?: string

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsTasksPost operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsTasksPostRequest
 */
export interface ClientApiApiV1ClientsTasksPostRequest {
    /**
     * 
     * @type {InlineObject51}
     * @memberof ClientApiApiV1ClientsTasksPost
     */
    readonly body?: InlineObject51

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsTasksPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ClientsUpdateStoreDataPatch operation in ClientApi.
 * @export
 * @interface ClientApiApiV1ClientsUpdateStoreDataPatchRequest
 */
export interface ClientApiApiV1ClientsUpdateStoreDataPatchRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientApiApiV1ClientsUpdateStoreDataPatch
     */
    readonly body?: Array<string>

    /**
     * Запустить задачу в фоновом режиме?
     * @type {boolean}
     * @memberof ClientApiApiV1ClientsUpdateStoreDataPatch
     */
    readonly queue?: boolean

    /**
     * 
     * @type {string}
     * @memberof ClientApiApiV1ClientsUpdateStoreDataPatch
     */
    readonly acceptEncoding?: string
}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * ## Добавить рекомендацию.
     * @summary Добавить рекомендацию в storekeeper_product.
     * @param {ClientApiApiV1ClientsBoxesAddRecommendationForStockPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsBoxesAddRecommendationForStockPost(requestParameters: ClientApiApiV1ClientsBoxesAddRecommendationForStockPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsBoxesAddRecommendationForStockPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Метод должен вычислять разницу между deliveryTotalPriceChanged и deliveryTotalPrice - (deliveryTotalPriceChanged-deliveryTotalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этой коробке из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа deliveryTotalPrice = deliveryTotalPriceChanged   ## Проверки:Только для коробок со статусом: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE
     * @summary # Подтвердить измение цены доставки за коробки.
     * @param {ClientApiApiV1ClientsBoxesConfirmDeliveryPriceChangePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsBoxesConfirmDeliveryPriceChangePost(requestParameters: ClientApiApiV1ClientsBoxesConfirmDeliveryPriceChangePostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsBoxesConfirmDeliveryPriceChangePost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить рекомендацию.
     * @summary Изменить рекомендацию в storekeeper_product.
     * @param {ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsBoxesEditRecommendationForStockGuidPatch(requestParameters: ClientApiApiV1ClientsBoxesEditRecommendationForStockGuidPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsBoxesEditRecommendationForStockGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать shippingLabel в первый раз  Данный метод нужен чтобы отредактировать в первый раз shippingLabel коробки.         Проверки:         Доступен только для коробок ранее shippingLabel === null,         Доступен только для коробок со статусами IN_STOCK
     * @summary Редактировать shippingLabel в первый раз.
     * @param {ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch(requestParameters: ClientApiApiV1ClientsBoxesGuidEditShippingLabelFirstTimePatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsBoxesGuidEditShippingLabelFirstTimePatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Вернуть коробки обратно на склад  Данный метод нужен чтобы отменить запрос на отправку в партию или при отказе клиентом изменения цены         У клиента будут разморожены средства на доставку.         У коробок статус вернется на статус IN_STOCK         затирается партия (batchId = null)         Проверки:         Доступен только для коробок со статусами REQUESTED_SEND_TO_BATCH, NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, NEED_TO_UPDATE_THE_TARIFF
     * @summary Вернуть коробки обратно на склад.
     * @param {ClientApiApiV1ClientsBoxesReturnBoxesToStockPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsBoxesReturnBoxesToStockPost(requestParameters: ClientApiApiV1ClientsBoxesReturnBoxesToStockPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsBoxesReturnBoxesToStockPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Обновить тариф если тариф был удален.  У коробок статус вернется на статус IN_BATCH или REQUESTED_SEND_TO_BATCH, в зависимости от того есть у коробки batchId         У клиента будут разморожены/разморожены средства на доставку в зависимости разницы стоимости.         Проверки:         Доступен только для коробок со статусами NEED_TO_UPDATE_THE_TARIFF
     * @summary Обновить тариф если тариф был удален.
     * @param {ClientApiApiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost(requestParameters: ClientApiApiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsBoxesUpdateTariffIfTariffWasDeletedPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все склады назначения.   
     * @summary #  Получить все склады назначения.
     * @param {ClientApiApiV1ClientsDestinationGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsDestinationGet(requestParameters: ClientApiApiV1ClientsDestinationGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsDestinationGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отдает дестинейшны со статусом коробки указаным в квери
     * @summary Отдает дестинейшны со статусом коробки указаным в квери
     * @param {ClientApiApiV1ClientsDestinationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsDestinationsGet(requestParameters: ClientApiApiV1ClientsDestinationsGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsDestinationsGet(requestParameters.status, requestParameters.storekeeperId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить заказы текущего клиента через id товара.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   вернет все незавершенные заказы клиента, гед есть указанный товар.
     * @summary # Получить заказы текущего клиента через id товара.
     * @param {ClientApiApiV1ClientsGetOrdersByProductIdGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsGetOrdersByProductIdGuidGet(requestParameters: ClientApiApiV1ClientsGetOrdersByProductIdGuidGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsGetOrdersByProductIdGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Оплатить товары.   ## Данный эндпоинт выбросит ошибку если хотябы один из продуктов не будет валидным   ## Прижимаются товары со статусами [70, 110]  ## Товары со статусом 70 (созданные фрилансером) получают статус 275, товар полностью переходит к клиенту: createdById меняется на id клиента, isCreatedByClient меняется на true, needCheckBySupervisor меняется на true,  ## Проверка продуктов(валидация): Нельзя повторно покупать товар который был оплачен (product.status === 70 && product.paidById !== null)  ## Товары со статусом 110 (бесплатные от платформы) получают статус 76, клиент получает копию продукта без данных о ресерчере, баере и супервайзере.
     * @summary # Оплатить товары.
     * @param {ClientApiApiV1ClientsMakePaymentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsMakePaymentsPost(requestParameters: ClientApiApiV1ClientsMakePaymentsPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsMakePaymentsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать заказ в статусе formed.   ## Статус автоматом ставиться formed: 0  Стоимость заказа = 0  Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
     * @summary # Создать заказ в статусе formed.
     * @param {ClientApiApiV1ClientsOrdersFormedPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersFormedPost(requestParameters: ClientApiApiV1ClientsOrdersFormedPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersFormedPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить заказы текущего клиента.   
     * @summary # Получить заказы текущего клиента.
     * @param {ClientApiApiV1ClientsOrdersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersGet(requestParameters: ClientApiApiV1ClientsOrdersGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersGet(requestParameters.status, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Этот метод должен устанавливать статус ордеру 40(отменен клиентом), а так же брать из заказа поле totalPrice и  вычитать эту сумму у привязанного к заказу, клиента из поля balanceFreeze и прибавлять в поле balance  ## Проверки:  Данный метод возможно вызвать только при статусах readyToProcess: 10  и needConfirmingToPriceChange: 19, // требуется подтверждение для изменения цены)
     * @summary Отменить заказ.
     * @param {ClientApiApiV1ClientsOrdersGuidCancelPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersGuidCancelPost(requestParameters: ClientApiApiV1ClientsOrdersGuidCancelPostRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersGuidCancelPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Метод должен вычислять разницу между totalPriceChanged и totalPrice - (totalPriceChanged-totalPrice).   ## Если разница больше 0 то нужно у клиента, который привязан к этому ордеру из поля balance вычесть эту разницу,  а в поле balanceFreeze прибавить  ## Если разница меньше 0 то нужно у клиента, который привязан к этому ордеру из поля balanceFreeze вычесть эту   разницу, а в поле balance прибавить   ## Далее нужно сделать у заказа totalPrice = totalPriceChanged   ## Проверки:Только для заказов со статусом needConfirmingToPriceChange: 19
     * @summary # Подтвердить измение цены.
     * @param {ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersGuidConfirmPriceChangePost(requestParameters: ClientApiApiV1ClientsOrdersGuidConfirmPriceChangePostRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersGuidConfirmPriceChangePost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить заказ по его GUID.   ## описание поля status:       formed: 0,  Корзина - статус \"Формируется\"      new: 1,  Клиент создал заказ - статус \"Новый\"      readyToProcess: 10,  Заказ доступен к обработке закупщиком (через 15минут после того как он был сделан, приобрёл статус Новый ) - статус \"доступен для обработки\"      atProcess: 15,  Закупщик взял заказ в обработку - статус \"в обработке\"        Варианты обработки - \"Что-то не так - требуется уточнение у клиента\" - уведомить клиента. - закупщику контрольное         уведомление (т.к. будет суброль)        Необходим поиск нового поставщика. - уведомить клиента. - закупщику контрольное уведомление (т.к. будет суброль)      needConfirmingToPriceChange: 19,  \"требуется подтверждение для изменения цены \"        paid: 20, закупщик оплатил заказ - статус \"оплачен\"       trackNumberIssued: 25, выдан и принят трек номер - статус \"выдан трек номер\"      needConfirmingReceiving: 27 - Этот статус промежуточный между 25 и 30     С этого статуса заказ можно переводить в статусы 25,30,35     inStock: 30, Товар пришёл на склад - \"Пришёл на склад\"      canceledByBuyer: 35, // Отменен байером      canceledByClient: 40 // Отменен байером отменем клиентом, можно выстаить только для вакантных или тех котрорые ожидают доплаты. (10, 19)   
     * @summary # Получить заказ по его GUID.
     * @param {ClientApiApiV1ClientsOrdersGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersGuidGet(requestParameters: ClientApiApiV1ClientsOrdersGuidGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в заказ.   ## Обратить внимание - внутри заказа нельзя отдельно редактировать атрибуты товара.   ## Если изменился какой-то они товар, все равно нужно передать полностью новый массив с .   ## с товарами.   ## Данный метод возможно вызывать до выплат поставщику (пока paidAt === null)Проверки: тариф доставки должен принадлежать данному сторкиперу
     * @summary # Внести изменения в заказ.
     * @param {ClientApiApiV1ClientsOrdersGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersGuidPatch(requestParameters: ClientApiApiV1ClientsOrdersGuidPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать заказ.   ## Статус автоматом ставиться readyToProcess: 10  Стоимость заказа = количество * (цена товара + (цена доставки паритии / количество товара в партии)):  Эта сумма будет заморожена у клиента. Курс записывается из админки Проверки:  Наличие продукта по guid,  Наличие у продукта поставщика тариф доставки должен принадлежать данному сторкиперу
     * @summary # Создать заказ.
     * @param {ClientApiApiV1ClientsOrdersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersPost(requestParameters: ClientApiApiV1ClientsOrdersPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
     * @summary # Перенести заказ из статусов formed(0), pending(2) или readyForBuyout(3) в статус readyToProcess(10)
     * @param {ClientApiApiV1ClientsOrdersToReadyToProcessGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsOrdersToReadyToProcessGuidPatch(requestParameters: ClientApiApiV1ClientsOrdersToReadyToProcessGuidPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsOrdersToReadyToProcessGuidPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить заказы текущего клиента.   
     * @summary # Получить заказы текущего клиента.
     * @param {ClientApiApiV1ClientsPagOrdersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsPagOrdersGet(requestParameters: ClientApiApiV1ClientsPagOrdersGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsPagOrdersGet(requestParameters.status, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Получить данные продукта по гуиду
     * @summary # Получить данные продукта по гуиду
     * @param {ClientApiApiV1ClientsProductsDataGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsDataGuidGet(requestParameters: ClientApiApiV1ClientsProductsDataGuidGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsDataGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отправить  созданные клиентом товары на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
     * @summary # Отправить  созданные клиентом товары на проверку супервайзеру.
     * @param {ClientApiApiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch(requestParameters: ClientApiApiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatchRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsFromClientReadyToBeCheckedBySupervisorPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
     * @summary # Получить цену для клиента на поиск поставщика множества товаров
     * @param {ClientApiApiV1ClientsProductsGetPriceForClientPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGetPriceForClientPost(requestParameters: ClientApiApiV1ClientsProductsGetPriceForClientPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGetPriceForClientPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в баркод товара.   Проверки:  Данный товар не принадлежит вам.
     * @summary # Внести изменения в баркод товара.
     * @param {ClientApiApiV1ClientsProductsGuidChangeBarCodePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidChangeBarCodePatch(requestParameters: ClientApiApiV1ClientsProductsGuidChangeBarCodePatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidChangeBarCodePatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в fourMonthesStock товара.   Проверки:  Данный товар не принадлежит вам.
     * @summary # Внести изменения в fourMonthesStock товара.
     * @param {ClientApiApiV1ClientsProductsGuidFourMonthesStockPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidFourMonthesStockPatch(requestParameters: ClientApiApiV1ClientsProductsGuidFourMonthesStockPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidFourMonthesStockPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отправить  созданный клиентом товар на проверку супервайзеру.   Данный метод ставит статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205).   Замораживает средства у клиента,( услуги баер + услуги супервайзера(если он требуется)) * 2    Затирает id баера и супервайзера  Записывает комментарий от клиента   ## Проверки  Вы можете ставить продукту статус FROM_CLIENT_READY_TO_BE_CHECKED_BY_SUPERVISOR (205), если ранее товар имел статусы 200, 270, 275, 280, 290
     * @summary # Отправить  созданный клиентом товар на проверку супервайзеру.
     * @param {ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch(requestParameters: ClientApiApiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidFromClientReadyToBeCheckedBySupervisorPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить цену для клиента на поиск поставщика   ## Проверки  только продуты созданные клиентом и принадлежавшие данному пользователю.
     * @summary # Получить цену для клиента на поиск поставщика
     * @param {ClientApiApiV1ClientsProductsGuidGetPriceForClientGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidGetPriceForClientGet(requestParameters: ClientApiApiV1ClientsProductsGuidGetPriceForClientGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidGetPriceForClientGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в товар.   Если товар был создан ресерчером (статус до 100) менять можно только баркод (нет проверки).   ## Если товар был создан клиентом (статус от 200):  Вам разрешено редактировать свой товар или добавлять поставщика только если ранее товар имел статусы 200, 270, 275, 280, 290  
     * @summary # Внести изменения в товар.
     * @param {ClientApiApiV1ClientsProductsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidPatch(requestParameters: ClientApiApiV1ClientsProductsGuidPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в stockUSA товара.   Проверки:  Данный товар не принадлежит вам.
     * @summary # Внести изменения в stockUSA товара.
     * @param {ClientApiApiV1ClientsProductsGuidStockUSAPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidStockUSAPatch(requestParameters: ClientApiApiV1ClientsProductsGuidStockUSAPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidStockUSAPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в защиту листинга товара.   Проверки:  Данный товар не принадлежит вам.
     * @summary # Внести изменения в защиту листинга товара.
     * @param {ClientApiApiV1ClientsProductsGuidTransparencyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidTransparencyPatch(requestParameters: ClientApiApiV1ClientsProductsGuidTransparencyPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidTransparencyPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в seo-файлы товара.   Проверки:  Данный товар не принадлежит вам.
     * @summary # Внести изменения в seo-файлы товара.
     * @param {ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsGuidUpdateSeoFilesPatch(requestParameters: ClientApiApiV1ClientsProductsGuidUpdateSeoFilesPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsGuidUpdateSeoFilesPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список продуктов для заказов. 
     * @summary # Получить список продуктов.
     * @param {ClientApiApiV1ClientsProductsInfoForOrdersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsInfoForOrdersGet(requestParameters: ClientApiApiV1ClientsProductsInfoForOrdersGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsInfoForOrdersGet(requestParameters.productIds, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить облегченный список товаров(archive = false)
     * @summary # Получить облегченный список товаров
     * @param {ClientApiApiV1ClientsProductsLightGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsLightGet(requestParameters: ClientApiApiV1ClientsProductsLightGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsLightGet(requestParameters.isChild, requestParameters.isParent, requestParameters.shopId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## GET products_listing_reports с пагинацией по айди продукта.
     * @summary GET products_listing_reports с пагинацией по айди продукта.
     * @param {ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsListingReportsByProductIdGuidGet(requestParameters: ClientApiApiV1ClientsProductsListingReportsByProductIdGuidGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsListingReportsByProductIdGuidGet(requestParameters.guid, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## GET products_listing_reports с пагинацией.
     * @summary GET products_listing_reports с пагинацией.
     * @param {ClientApiApiV1ClientsProductsListingReportsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsListingReportsGet(requestParameters: ClientApiApiV1ClientsProductsListingReportsGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsListingReportsGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить запись из products_listing_reports.
     * @summary Удалить запись из products_listing_reports.
     * @param {ClientApiApiV1ClientsProductsListingReportsGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsListingReportsGuidDelete(requestParameters: ClientApiApiV1ClientsProductsListingReportsGuidDeleteRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsListingReportsGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## GET products_listing_reports by guid.
     * @summary GET products_listing_reports by guid.
     * @param {ClientApiApiV1ClientsProductsListingReportsGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsListingReportsGuidGet(requestParameters: ClientApiApiV1ClientsProductsListingReportsGuidGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsListingReportsGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить products_listing_reports по гуиду. В боди важно отправить _id лаунча для обновления
     * @summary Изменить запись в products_listing_reports.
     * @param {ClientApiApiV1ClientsProductsListingReportsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsListingReportsGuidPatch(requestParameters: ClientApiApiV1ClientsProductsListingReportsGuidPatchRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsListingReportsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Добавить products_listing_reports.
     * @summary Добавить запись в products_listing_reports.
     * @param {ClientApiApiV1ClientsProductsListingReportsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsListingReportsPost(requestParameters: ClientApiApiV1ClientsProductsListingReportsPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsListingReportsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить медиа-файлы по продукту
     * @summary # Получить медиа-файлы по продукту.
     * @param {ClientApiApiV1ClientsProductsMediaGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsMediaGuidGet(requestParameters: ClientApiApiV1ClientsProductsMediaGuidGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsMediaGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
     * @summary # Получить список товаров данного клиента используя фильтр
     * @param {ClientApiApiV1ClientsProductsMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsMyGet(requestParameters: ClientApiApiV1ClientsProductsMyGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsMyGet(requestParameters.filters, requestParameters.shopId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
     * @summary # Получить список товаров данного клиента используя фильтр (DEPRECATED)
     * @param {ClientApiApiV1ClientsProductsMyWithPagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsMyWithPagGet(requestParameters: ClientApiApiV1ClientsProductsMyWithPagGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsMyWithPagGet(requestParameters.filters, requestParameters.shopIds, requestParameters.purchaseQuantityAboveZero, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров данного клиента используя фильтр.   Выдача только продуктов которые не были оплачены paidAt = null.
     * @summary # Получить список товаров данного клиента используя фильтр
     * @param {ClientApiApiV1ClientsProductsMyWithPagV2GetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsMyWithPagV2Get(requestParameters: ClientApiApiV1ClientsProductsMyWithPagV2GetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsMyWithPagV2Get(requestParameters.filters, requestParameters.shopIds, requestParameters.purchaseQuantityAboveZero, requestParameters.storekeeper, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.preset, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Добавить новый продукт клиентом.  ## В отличии от метода ресерчера, статус продукта ставиться автоматом  CREATED_BY_CLIENT 
     * @summary # Добавить новый продукт клиентом.
     * @param {ClientApiApiV1ClientsProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsPost(requestParameters: ClientApiApiV1ClientsProductsPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список  вакантных товаров. статусы 70 и 110(скрыты данные о поставщике, байере, супервайзере, создателе и skuByClient)  
     * @summary # Получить список вакантных товаров.
     * @param {ClientApiApiV1ClientsProductsVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsProductsVacGet(requestParameters: ClientApiApiV1ClientsProductsVacGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsProductsVacGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export shops-data
     * @summary Export shops-data
     * @param {ClientApiApiV1ClientsShopsExportGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsShopsExportGet(requestParameters: ClientApiApiV1ClientsShopsExportGetRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsShopsExportGet(requestParameters.table, requestParameters.shopIds, requestParameters.statusGroup, requestParameters.onAmazon, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить все пермишшены по магазинам
     * @summary  Получить все пермишшены по магазинам
     * @param {ClientApiApiV1ClientsShopsPermissionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsShopsPermissionsGet(requestParameters: ClientApiApiV1ClientsShopsPermissionsGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsShopsPermissionsGet(requestParameters.limit, requestParameters.offset, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Показать все задачи с коробками данного юзера.   
     * @summary # Показать все задачи с коробками данного юзера
     * @param {ClientApiApiV1ClientsTasksByBoxesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsTasksByBoxesGet(requestParameters: ClientApiApiV1ClientsTasksByBoxesGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsTasksByBoxesGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.storekeeperId, requestParameters.operationType, requestParameters.priority, requestParameters.status, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отменить задачу. Выставляет задаче статус 30.  
     * @summary # Отменить задачу.
     * @param {ClientApiApiV1ClientsTasksCancelGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsTasksCancelGuidPost(requestParameters: ClientApiApiV1ClientsTasksCancelGuidPostRequest, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsTasksCancelGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Показать все задачи данного пользователя в данном складе.   
     * @summary # Показать все задачи данного пользователя в данном складе.
     * @param {ClientApiApiV1ClientsTasksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsTasksGet(requestParameters: ClientApiApiV1ClientsTasksGetRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsTasksGet(requestParameters.storekeeperId, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать задачу.   
     * @summary # Создать задачу.
     * @param {ClientApiApiV1ClientsTasksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsTasksPost(requestParameters: ClientApiApiV1ClientsTasksPostRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsTasksPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновить данные по магазинам, не дожидаясь обновления в 7 утра
     * @summary Обновить данные по магазинам, не дожидаясь обновления в 7 утра
     * @param {ClientApiApiV1ClientsUpdateStoreDataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiV1ClientsUpdateStoreDataPatch(requestParameters: ClientApiApiV1ClientsUpdateStoreDataPatchRequest = {}, options?: any) {
        return ClientApiFp(this.configuration).apiV1ClientsUpdateStoreDataPatch(requestParameters.body, requestParameters.queue, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
