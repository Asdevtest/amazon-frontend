/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject100 } from '../models';
// @ts-ignore
import { InlineObject101 } from '../models';
// @ts-ignore
import { InlineObject102 } from '../models';
// @ts-ignore
import { InlineObject103 } from '../models';
// @ts-ignore
import { InlineObject104 } from '../models';
// @ts-ignore
import { InlineObject105 } from '../models';
// @ts-ignore
import { InlineObject106 } from '../models';
// @ts-ignore
import { InlineObject107 } from '../models';
// @ts-ignore
import { InlineObject108 } from '../models';
// @ts-ignore
import { InlineObject109 } from '../models';
// @ts-ignore
import { InlineObject110 } from '../models';
// @ts-ignore
import { InlineObject111 } from '../models';
// @ts-ignore
import { InlineObject112 } from '../models';
// @ts-ignore
import { InlineObject167 } from '../models';
// @ts-ignore
import { InlineResponse200121 } from '../models';
// @ts-ignore
import { InlineResponse20087 } from '../models';
// @ts-ignore
import { InlineResponse20088 } from '../models';
// @ts-ignore
import { InlineResponse20089 } from '../models';
// @ts-ignore
import { InlineResponse20111 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * RequestProposalsApi - axios parameter creator
 * @export
 */
export const RequestProposalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Получить список предложений по guid заявки..   Если его вызывает создатель заявки:  Эндпоинт должен отдавать список всех предложений со всеми статусами Если его вызывает исполнитель(фрилансер): Он должен отдавать предложения к заявке, только от этого исполнителя со всеми статусами Если его вызывает супервизор: Он должен отдавать предложения проверяемые данным супервайзером.
         * @summary Получить список предложений по guid заявки.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsCustomByRequestIdGuidGet: async (guid: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsCustomByRequestIdGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/custom/by_request_id/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить предложение по его id.   
         * @summary Получить предложение по его id.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsCustomGuidGet: async (guid: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsCustomGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/custom/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать результат работы   Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
         * @summary #  Редактировать результат работы.
         * @param {string} guid GUID в БД
         * @param {InlineObject167} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsCustomGuidResultEditPatch: async (guid: string, body?: InlineObject167, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsCustomGuidResultEditPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/custom/{guid}/result_edit`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить исходники
         * @summary #  Получить исходники.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/request-proposals/freelance-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить исходник
         * @summary #  Удалить исходник
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsFreelanceSourcesGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/freelance-sources/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить исходник
         * @summary #  Изменить исходник.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject112} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesGuidPatch: async (guid: string, body?: InlineObject112, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsFreelanceSourcesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/freelance-sources/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать исходник
         * @summary #  Создать исходник.
         * @param {InlineObject110} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesPost: async (body?: InlineObject110, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/request-proposals/freelance-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все предложения для супервизора.  
         * @summary Получить все предложения для супервизора.
         * @param {'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT'} type Тип заявки
         * @param {'VACANT' | 'LINKED_TO_ME' | 'ALL'} kind Виды запросов:       LINKED_TO_ME - предложения которые связанны с данным пользователем,       ALL - все предложения, если в заявке требовалась проверка супервайзера,       VACANT - все доступные предложения на проверку сепервайзером. Данный запрос доступен только для роли супервайзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>} [status] Сортировать по статусам.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGet: async (type: 'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT', kind: 'VACANT' | 'LINKED_TO_ME' | 'ALL', noCache?: boolean, status?: Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('apiV1RequestProposalsGet', 'type', type)
            // verify required parameter 'kind' is not null or undefined
            assertParamExists('apiV1RequestProposalsGet', 'kind', kind)
            const localVarPath = `/api/v1/request-proposals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status).join(COLLECTION_FORMATS.csv);
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Одобрить/отклонить роботу над предложением саба, может сделать только записаный в createdBy юзер
         * @summary #  Одобрить/отклонить роботу над предложением саба
         * @param {string} guid GUID в БД
         * @param {InlineObject101} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidApprovePatch: async (guid: string, body?: InlineObject101, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidApprovePatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/approve`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отмена предложения до заключения сделки  ## Статус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли вызвавший данный метод владельцем предложения.
         * @summary # Отмена предложения до заключения сделки.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject100} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidCancelBeforeDealPatch: async (guid: string, body?: InlineObject100, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidCancelBeforeDealPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/cancel_before_deal`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отмена предложения после заключения сделки  Вызывает возврат замороженных средств.  ## Если вызвал исполнитель(фрилансер), стутус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем предложения. ## Если вызвал клиент, статус меняется на CANCELED_BY_CREATOR_OF_REQUEST Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем заявки к торой относится данное предложение. ## Если вызвал супервайзер, статус меняется на CANCELED_BY_SUPERVISOR Проверки: Только  предложения со статусами:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary # Отмена предложения после заключения сделки, в зависимости от того кто вызвал ставится статус.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject108} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidCancelPatch: async (guid: string, body?: InlineObject108, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidCancelPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/cancel`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить исполнителя
         * @summary #  Изменить исполнителя.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject111} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidChangePerformerPatch: async (guid: string, body?: InlineObject111, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidChangePerformerPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/change_performer`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Привязать  супервайзра к предложению. Статус меняется на VERIFYING_BY_SUPERVISOR В поле supervisorId вписывается id супервайзера. Устанавливается время за которое супервайзер должен принять решение. Пос истечения времени супервайзер снимается.  ## Супервайзер добавляется в чат  Проверки: Предложения должны быть со статусом READY_TO_VERIFY и в заявке указывалась необходимость в проверке. Взять на проверку предложение не могут создатель заявки или предложения ## Отвязать супервайзра от предложения . Статус возвращается на READY_TO_VERIFY id супервайзера удалятся из supervisorId. Проверки: Только со статусами предложений:   VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ## Это нужно чтобы рассчитать остаток средств при закрытии заявки. Супервайзер не может отвязать от себя предложение если он не связан.
         * @summary #  Привязать или \"отвязать\" супервайзера от предложения.
         * @param {string} guid GUID в БД
         * @param {InlineObject109} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch: async (guid: string, body?: InlineObject109, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/link_or_unlink_supervisor`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Принять предложение.   При вызове данного метода клиент подтверждает согласие на заключение договора Если клиент принял предложение, то статус меняется на OFFER_CONDITIONS_ACCEPTEDУ фрилансеру дается время в минутах, которое было оговорено (execution_time). У клиента замораживаются средства. Проверки: Только владелец заявки может принять предложение Принимаются предложения только со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
         * @summary #  Принять предложение.
         * @param {string} guid GUID в БД
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalAcceptPatch: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidProposalAcceptPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/proposal_accept`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Отправить предложение обратно, после доработки.  Статус ставится автоматом: OFFER_CONDITIONS_CORRECTED Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Только владелец предложения может вызвать данный метод.
         * @summary # Отправить предложение обратно, после доработки.
         * @param {string} guid GUID в БД
         * @param {InlineObject104} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalCorrectedPatch: async (guid: string, body?: InlineObject104, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidProposalCorrectedPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/proposal_corrected`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать условия предложения   Данный метод может вызываться исполнителем до заключения договора, Если при первом вызове, исполнитель не ввел свои изменения (цены или времени), то данные берутся из заявки При повторном вызове, если исполнитель не ввел свои изменения (цены или времени), то данные не меняются. Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
         * @summary #  Редактировать условия предложения.
         * @param {string} guid GUID в БД
         * @param {InlineObject103} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalEditPatch: async (guid: string, body?: InlineObject103, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidProposalEditPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/proposal_edit`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отказаться от предложения..  Ставиться статус: OFFER_CONDITIONS_REJECTED Нужно написать в комментарии причину. Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли пользователь владельцем заявки к которой относится предложение. 
         * @summary # Отказаться от предложения.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject102} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalRejectPatch: async (guid: string, body?: InlineObject102, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidProposalRejectPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/proposal_reject`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Отправить на утверждение.  Статус READY_TO_VERIFY ставится автоматом Устанавливается время на принятие автоматом предложения клиентом  Если в заявке было требование проверять супервизором, то время не устанавливается. Проверки: Только предложения со статусом:  OFFER_CONDITIONS_ACCEPTED
         * @summary #  Отправить предложение на утверждение.
         * @param {string} guid GUID в БД
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidReadyToVerifyPatch: async (guid: string, body?: object, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidReadyToVerifyPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/ready_to_verify`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Принять результаты работы.   Произвести оплаты Если клиент принял предложение, то статус меняется на ACCEPTED_BY_CLIENT, Если супервайзер принял предложение, то статус меняется на ACCEPTED_BY_SUPERVISOR  ## Заявка переходит в статус COMPLETE_PROPOSALS_AMOUNT_ACHIEVED при достижении задорного количества принятых предложений. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED, READY_TO_VERIFY, VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary #  Принять результаты работы.
         * @param {string} guid GUID в БД
         * @param {InlineObject107} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidResultAcceptPatch: async (guid: string, body?: InlineObject107, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidResultAcceptPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/result_accept`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Отправить обратно на утверждение, после доработки.  Статус ставится автоматом: CORRECTED В зависимости была ли в заявке требование проверки супервизором, устанавливается время. После достижении времени, предложение будет принято автоматом  если была в заявке была проверка супервайзером, то сепервайзер снимается с проверки предложения. Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Только предложения со статусом: TO_CORRECT
         * @summary #  Отправить обратно на утверждение, после доработки.
         * @param {string} guid GUID в БД
         * @param {InlineObject106} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidResultCorrectedPatch: async (guid: string, body?: InlineObject106, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidResultCorrectedPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/result_corrected`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отправить на доработку результат работы.  Ставиться статус TO_CORRECT Нужно написать в комментарии причину. Можно выставить время на доработку, в минутах. по умолчанию 120 мин. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary # Отправить на доработку результат работы.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject105} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidResultToCorrectPatch: async (guid: string, body?: InlineObject105, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestProposalsGuidResultToCorrectPatch', 'guid', guid)
            const localVarPath = `/api/v1/request-proposals/{guid}/result_to_correct`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить все предложения фрилансера с пагинацией [sub, master]
         * @summary Получить все предложения фрилансера [sub, master].
         * @param {string} [filters]                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsPagMyAllGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/request-proposals/pag/my_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить все предложения фрилансера с пагинацией
         * @summary Получить все предложения фрилансера.
         * @param {string} [filters]                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsPagMyGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/request-proposals/pag/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestProposalsApi - functional programming interface
 * @export
 */
export const RequestProposalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestProposalsApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Получить список предложений по guid заявки..   Если его вызывает создатель заявки:  Эндпоинт должен отдавать список всех предложений со всеми статусами Если его вызывает исполнитель(фрилансер): Он должен отдавать предложения к заявке, только от этого исполнителя со всеми статусами Если его вызывает супервизор: Он должен отдавать предложения проверяемые данным супервайзером.
         * @summary Получить список предложений по guid заявки.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsCustomByRequestIdGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200121>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsCustomByRequestIdGuidGet(guid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить предложение по его id.   
         * @summary Получить предложение по его id.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsCustomGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsCustomGuidGet(guid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать результат работы   Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
         * @summary #  Редактировать результат работы.
         * @param {string} guid GUID в БД
         * @param {InlineObject167} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsCustomGuidResultEditPatch(guid: string, body?: InlineObject167, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsCustomGuidResultEditPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить исходники
         * @summary #  Получить исходники.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsFreelanceSourcesGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20088>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsFreelanceSourcesGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить исходник
         * @summary #  Удалить исходник
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsFreelanceSourcesGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsFreelanceSourcesGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить исходник
         * @summary #  Изменить исходник.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject112} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsFreelanceSourcesGuidPatch(guid: string, body?: InlineObject112, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsFreelanceSourcesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать исходник
         * @summary #  Создать исходник.
         * @param {InlineObject110} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsFreelanceSourcesPost(body?: InlineObject110, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20111>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsFreelanceSourcesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все предложения для супервизора.  
         * @summary Получить все предложения для супервизора.
         * @param {'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT'} type Тип заявки
         * @param {'VACANT' | 'LINKED_TO_ME' | 'ALL'} kind Виды запросов:       LINKED_TO_ME - предложения которые связанны с данным пользователем,       ALL - все предложения, если в заявке требовалась проверка супервайзера,       VACANT - все доступные предложения на проверку сепервайзером. Данный запрос доступен только для роли супервайзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>} [status] Сортировать по статусам.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGet(type: 'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT', kind: 'VACANT' | 'LINKED_TO_ME' | 'ALL', noCache?: boolean, status?: Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20087>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGet(type, kind, noCache, status, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Одобрить/отклонить роботу над предложением саба, может сделать только записаный в createdBy юзер
         * @summary #  Одобрить/отклонить роботу над предложением саба
         * @param {string} guid GUID в БД
         * @param {InlineObject101} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidApprovePatch(guid: string, body?: InlineObject101, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidApprovePatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отмена предложения до заключения сделки  ## Статус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли вызвавший данный метод владельцем предложения.
         * @summary # Отмена предложения до заключения сделки.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject100} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidCancelBeforeDealPatch(guid: string, body?: InlineObject100, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidCancelBeforeDealPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отмена предложения после заключения сделки  Вызывает возврат замороженных средств.  ## Если вызвал исполнитель(фрилансер), стутус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем предложения. ## Если вызвал клиент, статус меняется на CANCELED_BY_CREATOR_OF_REQUEST Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем заявки к торой относится данное предложение. ## Если вызвал супервайзер, статус меняется на CANCELED_BY_SUPERVISOR Проверки: Только  предложения со статусами:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary # Отмена предложения после заключения сделки, в зависимости от того кто вызвал ставится статус.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject108} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidCancelPatch(guid: string, body?: InlineObject108, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidCancelPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить исполнителя
         * @summary #  Изменить исполнителя.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject111} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidChangePerformerPatch(guid: string, body?: InlineObject111, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidChangePerformerPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Привязать  супервайзра к предложению. Статус меняется на VERIFYING_BY_SUPERVISOR В поле supervisorId вписывается id супервайзера. Устанавливается время за которое супервайзер должен принять решение. Пос истечения времени супервайзер снимается.  ## Супервайзер добавляется в чат  Проверки: Предложения должны быть со статусом READY_TO_VERIFY и в заявке указывалась необходимость в проверке. Взять на проверку предложение не могут создатель заявки или предложения ## Отвязать супервайзра от предложения . Статус возвращается на READY_TO_VERIFY id супервайзера удалятся из supervisorId. Проверки: Только со статусами предложений:   VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ## Это нужно чтобы рассчитать остаток средств при закрытии заявки. Супервайзер не может отвязать от себя предложение если он не связан.
         * @summary #  Привязать или \"отвязать\" супервайзера от предложения.
         * @param {string} guid GUID в БД
         * @param {InlineObject109} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch(guid: string, body?: InlineObject109, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Принять предложение.   При вызове данного метода клиент подтверждает согласие на заключение договора Если клиент принял предложение, то статус меняется на OFFER_CONDITIONS_ACCEPTEDУ фрилансеру дается время в минутах, которое было оговорено (execution_time). У клиента замораживаются средства. Проверки: Только владелец заявки может принять предложение Принимаются предложения только со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
         * @summary #  Принять предложение.
         * @param {string} guid GUID в БД
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidProposalAcceptPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidProposalAcceptPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Отправить предложение обратно, после доработки.  Статус ставится автоматом: OFFER_CONDITIONS_CORRECTED Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Только владелец предложения может вызвать данный метод.
         * @summary # Отправить предложение обратно, после доработки.
         * @param {string} guid GUID в БД
         * @param {InlineObject104} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidProposalCorrectedPatch(guid: string, body?: InlineObject104, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidProposalCorrectedPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать условия предложения   Данный метод может вызываться исполнителем до заключения договора, Если при первом вызове, исполнитель не ввел свои изменения (цены или времени), то данные берутся из заявки При повторном вызове, если исполнитель не ввел свои изменения (цены или времени), то данные не меняются. Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
         * @summary #  Редактировать условия предложения.
         * @param {string} guid GUID в БД
         * @param {InlineObject103} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidProposalEditPatch(guid: string, body?: InlineObject103, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidProposalEditPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отказаться от предложения..  Ставиться статус: OFFER_CONDITIONS_REJECTED Нужно написать в комментарии причину. Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли пользователь владельцем заявки к которой относится предложение. 
         * @summary # Отказаться от предложения.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject102} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidProposalRejectPatch(guid: string, body?: InlineObject102, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidProposalRejectPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Отправить на утверждение.  Статус READY_TO_VERIFY ставится автоматом Устанавливается время на принятие автоматом предложения клиентом  Если в заявке было требование проверять супервизором, то время не устанавливается. Проверки: Только предложения со статусом:  OFFER_CONDITIONS_ACCEPTED
         * @summary #  Отправить предложение на утверждение.
         * @param {string} guid GUID в БД
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidReadyToVerifyPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidReadyToVerifyPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Принять результаты работы.   Произвести оплаты Если клиент принял предложение, то статус меняется на ACCEPTED_BY_CLIENT, Если супервайзер принял предложение, то статус меняется на ACCEPTED_BY_SUPERVISOR  ## Заявка переходит в статус COMPLETE_PROPOSALS_AMOUNT_ACHIEVED при достижении задорного количества принятых предложений. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED, READY_TO_VERIFY, VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary #  Принять результаты работы.
         * @param {string} guid GUID в БД
         * @param {InlineObject107} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidResultAcceptPatch(guid: string, body?: InlineObject107, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidResultAcceptPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Отправить обратно на утверждение, после доработки.  Статус ставится автоматом: CORRECTED В зависимости была ли в заявке требование проверки супервизором, устанавливается время. После достижении времени, предложение будет принято автоматом  если была в заявке была проверка супервайзером, то сепервайзер снимается с проверки предложения. Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Только предложения со статусом: TO_CORRECT
         * @summary #  Отправить обратно на утверждение, после доработки.
         * @param {string} guid GUID в БД
         * @param {InlineObject106} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidResultCorrectedPatch(guid: string, body?: InlineObject106, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidResultCorrectedPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отправить на доработку результат работы.  Ставиться статус TO_CORRECT Нужно написать в комментарии причину. Можно выставить время на доработку, в минутах. по умолчанию 120 мин. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary # Отправить на доработку результат работы.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject105} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsGuidResultToCorrectPatch(guid: string, body?: InlineObject105, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsGuidResultToCorrectPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить все предложения фрилансера с пагинацией [sub, master]
         * @summary Получить все предложения фрилансера [sub, master].
         * @param {string} [filters]                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsPagMyAllGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20089>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsPagMyAllGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить все предложения фрилансера с пагинацией
         * @summary Получить все предложения фрилансера.
         * @param {string} [filters]                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestProposalsPagMyGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20089>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestProposalsPagMyGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestProposalsApi - factory interface
 * @export
 */
export const RequestProposalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestProposalsApiFp(configuration)
    return {
        /**
         * ## Получить список предложений по guid заявки..   Если его вызывает создатель заявки:  Эндпоинт должен отдавать список всех предложений со всеми статусами Если его вызывает исполнитель(фрилансер): Он должен отдавать предложения к заявке, только от этого исполнителя со всеми статусами Если его вызывает супервизор: Он должен отдавать предложения проверяемые данным супервайзером.
         * @summary Получить список предложений по guid заявки.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsCustomByRequestIdGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200121>> {
            return localVarFp.apiV1RequestProposalsCustomByRequestIdGuidGet(guid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить предложение по его id.   
         * @summary Получить предложение по его id.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsCustomGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1RequestProposalsCustomGuidGet(guid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать результат работы   Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
         * @summary #  Редактировать результат работы.
         * @param {string} guid GUID в БД
         * @param {InlineObject167} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsCustomGuidResultEditPatch(guid: string, body?: InlineObject167, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsCustomGuidResultEditPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить исходники
         * @summary #  Получить исходники.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20088>> {
            return localVarFp.apiV1RequestProposalsFreelanceSourcesGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить исходник
         * @summary #  Удалить исходник
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsFreelanceSourcesGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить исходник
         * @summary #  Изменить исходник.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject112} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesGuidPatch(guid: string, body?: InlineObject112, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsFreelanceSourcesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать исходник
         * @summary #  Создать исходник.
         * @param {InlineObject110} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsFreelanceSourcesPost(body?: InlineObject110, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20111> {
            return localVarFp.apiV1RequestProposalsFreelanceSourcesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все предложения для супервизора.  
         * @summary Получить все предложения для супервизора.
         * @param {'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT'} type Тип заявки
         * @param {'VACANT' | 'LINKED_TO_ME' | 'ALL'} kind Виды запросов:       LINKED_TO_ME - предложения которые связанны с данным пользователем,       ALL - все предложения, если в заявке требовалась проверка супервайзера,       VACANT - все доступные предложения на проверку сепервайзером. Данный запрос доступен только для роли супервайзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>} [status] Сортировать по статусам.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGet(type: 'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT', kind: 'VACANT' | 'LINKED_TO_ME' | 'ALL', noCache?: boolean, status?: Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20087>> {
            return localVarFp.apiV1RequestProposalsGet(type, kind, noCache, status, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Одобрить/отклонить роботу над предложением саба, может сделать только записаный в createdBy юзер
         * @summary #  Одобрить/отклонить роботу над предложением саба
         * @param {string} guid GUID в БД
         * @param {InlineObject101} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidApprovePatch(guid: string, body?: InlineObject101, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidApprovePatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отмена предложения до заключения сделки  ## Статус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли вызвавший данный метод владельцем предложения.
         * @summary # Отмена предложения до заключения сделки.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject100} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidCancelBeforeDealPatch(guid: string, body?: InlineObject100, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidCancelBeforeDealPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отмена предложения после заключения сделки  Вызывает возврат замороженных средств.  ## Если вызвал исполнитель(фрилансер), стутус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем предложения. ## Если вызвал клиент, статус меняется на CANCELED_BY_CREATOR_OF_REQUEST Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем заявки к торой относится данное предложение. ## Если вызвал супервайзер, статус меняется на CANCELED_BY_SUPERVISOR Проверки: Только  предложения со статусами:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary # Отмена предложения после заключения сделки, в зависимости от того кто вызвал ставится статус.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject108} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidCancelPatch(guid: string, body?: InlineObject108, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidCancelPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить исполнителя
         * @summary #  Изменить исполнителя.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject111} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidChangePerformerPatch(guid: string, body?: InlineObject111, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidChangePerformerPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Привязать  супервайзра к предложению. Статус меняется на VERIFYING_BY_SUPERVISOR В поле supervisorId вписывается id супервайзера. Устанавливается время за которое супервайзер должен принять решение. Пос истечения времени супервайзер снимается.  ## Супервайзер добавляется в чат  Проверки: Предложения должны быть со статусом READY_TO_VERIFY и в заявке указывалась необходимость в проверке. Взять на проверку предложение не могут создатель заявки или предложения ## Отвязать супервайзра от предложения . Статус возвращается на READY_TO_VERIFY id супервайзера удалятся из supervisorId. Проверки: Только со статусами предложений:   VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ## Это нужно чтобы рассчитать остаток средств при закрытии заявки. Супервайзер не может отвязать от себя предложение если он не связан.
         * @summary #  Привязать или \"отвязать\" супервайзера от предложения.
         * @param {string} guid GUID в БД
         * @param {InlineObject109} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch(guid: string, body?: InlineObject109, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Принять предложение.   При вызове данного метода клиент подтверждает согласие на заключение договора Если клиент принял предложение, то статус меняется на OFFER_CONDITIONS_ACCEPTEDУ фрилансеру дается время в минутах, которое было оговорено (execution_time). У клиента замораживаются средства. Проверки: Только владелец заявки может принять предложение Принимаются предложения только со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
         * @summary #  Принять предложение.
         * @param {string} guid GUID в БД
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalAcceptPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidProposalAcceptPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Отправить предложение обратно, после доработки.  Статус ставится автоматом: OFFER_CONDITIONS_CORRECTED Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Только владелец предложения может вызвать данный метод.
         * @summary # Отправить предложение обратно, после доработки.
         * @param {string} guid GUID в БД
         * @param {InlineObject104} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalCorrectedPatch(guid: string, body?: InlineObject104, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidProposalCorrectedPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать условия предложения   Данный метод может вызываться исполнителем до заключения договора, Если при первом вызове, исполнитель не ввел свои изменения (цены или времени), то данные берутся из заявки При повторном вызове, если исполнитель не ввел свои изменения (цены или времени), то данные не меняются. Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
         * @summary #  Редактировать условия предложения.
         * @param {string} guid GUID в БД
         * @param {InlineObject103} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalEditPatch(guid: string, body?: InlineObject103, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidProposalEditPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отказаться от предложения..  Ставиться статус: OFFER_CONDITIONS_REJECTED Нужно написать в комментарии причину. Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли пользователь владельцем заявки к которой относится предложение. 
         * @summary # Отказаться от предложения.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject102} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidProposalRejectPatch(guid: string, body?: InlineObject102, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidProposalRejectPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Отправить на утверждение.  Статус READY_TO_VERIFY ставится автоматом Устанавливается время на принятие автоматом предложения клиентом  Если в заявке было требование проверять супервизором, то время не устанавливается. Проверки: Только предложения со статусом:  OFFER_CONDITIONS_ACCEPTED
         * @summary #  Отправить предложение на утверждение.
         * @param {string} guid GUID в БД
         * @param {object} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidReadyToVerifyPatch(guid: string, body?: object, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidReadyToVerifyPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Принять результаты работы.   Произвести оплаты Если клиент принял предложение, то статус меняется на ACCEPTED_BY_CLIENT, Если супервайзер принял предложение, то статус меняется на ACCEPTED_BY_SUPERVISOR  ## Заявка переходит в статус COMPLETE_PROPOSALS_AMOUNT_ACHIEVED при достижении задорного количества принятых предложений. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED, READY_TO_VERIFY, VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary #  Принять результаты работы.
         * @param {string} guid GUID в БД
         * @param {InlineObject107} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidResultAcceptPatch(guid: string, body?: InlineObject107, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidResultAcceptPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Отправить обратно на утверждение, после доработки.  Статус ставится автоматом: CORRECTED В зависимости была ли в заявке требование проверки супервизором, устанавливается время. После достижении времени, предложение будет принято автоматом  если была в заявке была проверка супервайзером, то сепервайзер снимается с проверки предложения. Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Только предложения со статусом: TO_CORRECT
         * @summary #  Отправить обратно на утверждение, после доработки.
         * @param {string} guid GUID в БД
         * @param {InlineObject106} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidResultCorrectedPatch(guid: string, body?: InlineObject106, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidResultCorrectedPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отправить на доработку результат работы.  Ставиться статус TO_CORRECT Нужно написать в комментарии причину. Можно выставить время на доработку, в минутах. по умолчанию 120 мин. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
         * @summary # Отправить на доработку результат работы.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject105} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsGuidResultToCorrectPatch(guid: string, body?: InlineObject105, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestProposalsGuidResultToCorrectPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить все предложения фрилансера с пагинацией [sub, master]
         * @summary Получить все предложения фрилансера [sub, master].
         * @param {string} [filters]                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsPagMyAllGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20089> {
            return localVarFp.apiV1RequestProposalsPagMyAllGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить все предложения фрилансера с пагинацией
         * @summary Получить все предложения фрилансера.
         * @param {string} [filters]                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestProposalsPagMyGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20089> {
            return localVarFp.apiV1RequestProposalsPagMyGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1RequestProposalsCustomByRequestIdGuidGet operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGetRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGetRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsCustomGuidGet operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsCustomGuidGetRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsCustomGuidGetRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsCustomGuidResultEditPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject167}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatch
     */
    readonly body?: InlineObject167

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsFreelanceSourcesGet operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGetRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsFreelanceSourcesGuidDelete operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidDeleteRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidDeleteRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsFreelanceSourcesGuidPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject112}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatch
     */
    readonly body?: InlineObject112

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsFreelanceSourcesPost operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesPostRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsFreelanceSourcesPostRequest {
    /**
     * 
     * @type {InlineObject110}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesPost
     */
    readonly body?: InlineObject110

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsFreelanceSourcesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGet operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGetRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGetRequest {
    /**
     * Тип заявки
     * @type {'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT'}
     * @memberof RequestProposalsApiApiV1RequestProposalsGet
     */
    readonly type: 'CUSTOM' | 'SEARCH_NICHE' | 'SEARCH_PRODUCT'

    /**
     * Виды запросов:       LINKED_TO_ME - предложения которые связанны с данным пользователем,       ALL - все предложения, если в заявке требовалась проверка супервайзера,       VACANT - все доступные предложения на проверку сепервайзером. Данный запрос доступен только для роли супервайзера
     * @type {'VACANT' | 'LINKED_TO_ME' | 'ALL'}
     * @memberof RequestProposalsApiApiV1RequestProposalsGet
     */
    readonly kind: 'VACANT' | 'LINKED_TO_ME' | 'ALL'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestProposalsApiApiV1RequestProposalsGet
     */
    readonly noCache?: boolean

    /**
     * Сортировать по статусам.
     * @type {Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>}
     * @memberof RequestProposalsApiApiV1RequestProposalsGet
     */
    readonly status?: Set<'CREATED' | 'OFFER_CONDITIONS_ACCEPTED' | 'READY_TO_VERIFY' | 'OFFER_CONDITIONS_REJECTED' | 'OFFER_CONDITIONS_CORRECTED' | 'VERIFYING_BY_SUPERVISOR' | 'TO_CORRECT' | 'CORRECTED' | 'CANCELED_BY_CREATOR_OF_REQUEST' | 'CANCELED_BY_SUPERVISOR' | 'CANCELED_BY_EXECUTOR' | 'ACCEPTED_BY_CLIENT' | 'ACCEPTED_BY_SUPERVISOR' | 'EXPIRED' | 'COMPLETE_PROPOSALS_AMOUNT_ACHIEVED'>

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidApprovePatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidApprovePatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidApprovePatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidApprovePatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject101}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidApprovePatch
     */
    readonly body?: InlineObject101

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidApprovePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidCancelBeforeDealPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject100}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatch
     */
    readonly body?: InlineObject100

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidCancelPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidCancelPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidCancelPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidCancelPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject108}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidCancelPatch
     */
    readonly body?: InlineObject108

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidCancelPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidChangePerformerPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject111}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatch
     */
    readonly body?: InlineObject111

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject109}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch
     */
    readonly body?: InlineObject109

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidProposalAcceptPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatch
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatch
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidProposalCorrectedPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject104}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatch
     */
    readonly body?: InlineObject104

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidProposalEditPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject103}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatch
     */
    readonly body?: InlineObject103

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidProposalRejectPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject102}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatch
     */
    readonly body?: InlineObject102

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidReadyToVerifyPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatch
     */
    readonly guid: string

    /**
     * 
     * @type {object}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatch
     */
    readonly body?: object

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidResultAcceptPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject107}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatch
     */
    readonly body?: InlineObject107

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidResultCorrectedPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject106}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatch
     */
    readonly body?: InlineObject106

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsGuidResultToCorrectPatch operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatchRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject105}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatch
     */
    readonly body?: InlineObject105

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsPagMyAllGet operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsPagMyAllGetRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsPagMyAllGetRequest {
    /**
     *                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyAllGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestProposalsPagMyGet operation in RequestProposalsApi.
 * @export
 * @interface RequestProposalsApiApiV1RequestProposalsPagMyGetRequest
 */
export interface RequestProposalsApiApiV1RequestProposalsPagMyGetRequest {
    /**
     *                Возможные поля:               (Proposal) -&gt; status, createdBy, sub, updatedAt               (Request) -&gt; humanFriendlyId, priority, title, maxAmountOfProposals, timeoutAt, requestCreatedBy,               (Product) -&gt; asin, amazonTitle,               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestProposalsApiApiV1RequestProposalsPagMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * RequestProposalsApi - object-oriented interface
 * @export
 * @class RequestProposalsApi
 * @extends {BaseAPI}
 */
export class RequestProposalsApi extends BaseAPI {
    /**
     * ## Получить список предложений по guid заявки..   Если его вызывает создатель заявки:  Эндпоинт должен отдавать список всех предложений со всеми статусами Если его вызывает исполнитель(фрилансер): Он должен отдавать предложения к заявке, только от этого исполнителя со всеми статусами Если его вызывает супервизор: Он должен отдавать предложения проверяемые данным супервайзером.
     * @summary Получить список предложений по guid заявки.
     * @param {RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsCustomByRequestIdGuidGet(requestParameters: RequestProposalsApiApiV1RequestProposalsCustomByRequestIdGuidGetRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsCustomByRequestIdGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить предложение по его id.   
     * @summary Получить предложение по его id.
     * @param {RequestProposalsApiApiV1RequestProposalsCustomGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsCustomGuidGet(requestParameters: RequestProposalsApiApiV1RequestProposalsCustomGuidGetRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsCustomGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать результат работы   Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
     * @summary #  Редактировать результат работы.
     * @param {RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsCustomGuidResultEditPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsCustomGuidResultEditPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsCustomGuidResultEditPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить исходники
     * @summary #  Получить исходники.
     * @param {RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsFreelanceSourcesGet(requestParameters: RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGetRequest = {}, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsFreelanceSourcesGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить исходник
     * @summary #  Удалить исходник
     * @param {RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsFreelanceSourcesGuidDelete(requestParameters: RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidDeleteRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsFreelanceSourcesGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить исходник
     * @summary #  Изменить исходник.
     * @param {RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsFreelanceSourcesGuidPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsFreelanceSourcesGuidPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsFreelanceSourcesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать исходник
     * @summary #  Создать исходник.
     * @param {RequestProposalsApiApiV1RequestProposalsFreelanceSourcesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsFreelanceSourcesPost(requestParameters: RequestProposalsApiApiV1RequestProposalsFreelanceSourcesPostRequest = {}, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsFreelanceSourcesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все предложения для супервизора.  
     * @summary Получить все предложения для супервизора.
     * @param {RequestProposalsApiApiV1RequestProposalsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGet(requestParameters: RequestProposalsApiApiV1RequestProposalsGetRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGet(requestParameters.type, requestParameters.kind, requestParameters.noCache, requestParameters.status, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Одобрить/отклонить роботу над предложением саба, может сделать только записаный в createdBy юзер
     * @summary #  Одобрить/отклонить роботу над предложением саба
     * @param {RequestProposalsApiApiV1RequestProposalsGuidApprovePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidApprovePatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidApprovePatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidApprovePatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отмена предложения до заключения сделки  ## Статус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли вызвавший данный метод владельцем предложения.
     * @summary # Отмена предложения до заключения сделки.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidCancelBeforeDealPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidCancelBeforeDealPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidCancelBeforeDealPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отмена предложения после заключения сделки  Вызывает возврат замороженных средств.  ## Если вызвал исполнитель(фрилансер), стутус меняется на CANCELED_BY_EXECUTOR Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем предложения. ## Если вызвал клиент, статус меняется на CANCELED_BY_CREATOR_OF_REQUEST Проверки: Только  предложения со статусами:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод владельцем заявки к торой относится данное предложение. ## Если вызвал супервайзер, статус меняется на CANCELED_BY_SUPERVISOR Проверки: Только  предложения со статусами:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
     * @summary # Отмена предложения после заключения сделки, в зависимости от того кто вызвал ставится статус.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidCancelPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidCancelPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidCancelPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidCancelPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить исполнителя
     * @summary #  Изменить исполнителя.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidChangePerformerPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidChangePerformerPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidChangePerformerPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Привязать  супервайзра к предложению. Статус меняется на VERIFYING_BY_SUPERVISOR В поле supervisorId вписывается id супервайзера. Устанавливается время за которое супервайзер должен принять решение. Пос истечения времени супервайзер снимается.  ## Супервайзер добавляется в чат  Проверки: Предложения должны быть со статусом READY_TO_VERIFY и в заявке указывалась необходимость в проверке. Взять на проверку предложение не могут создатель заявки или предложения ## Отвязать супервайзра от предложения . Статус возвращается на READY_TO_VERIFY id супервайзера удалятся из supervisorId. Проверки: Только со статусами предложений:   VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ## Это нужно чтобы рассчитать остаток средств при закрытии заявки. Супервайзер не может отвязать от себя предложение если он не связан.
     * @summary #  Привязать или \"отвязать\" супервайзера от предложения.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidLinkOrUnlinkSupervisorPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Принять предложение.   При вызове данного метода клиент подтверждает согласие на заключение договора Если клиент принял предложение, то статус меняется на OFFER_CONDITIONS_ACCEPTEDУ фрилансеру дается время в минутах, которое было оговорено (execution_time). У клиента замораживаются средства. Проверки: Только владелец заявки может принять предложение Принимаются предложения только со статусами:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
     * @summary #  Принять предложение.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidProposalAcceptPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidProposalAcceptPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidProposalAcceptPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Отправить предложение обратно, после доработки.  Статус ставится автоматом: OFFER_CONDITIONS_CORRECTED Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Только владелец предложения может вызвать данный метод.
     * @summary # Отправить предложение обратно, после доработки.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidProposalCorrectedPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidProposalCorrectedPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidProposalCorrectedPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать условия предложения   Данный метод может вызываться исполнителем до заключения договора, Если при первом вызове, исполнитель не ввел свои изменения (цены или времени), то данные берутся из заявки При повторном вызове, если исполнитель не ввел свои изменения (цены или времени), то данные не меняются. Проверки: Владелец предложения может редактировать.  Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED
     * @summary #  Редактировать условия предложения.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidProposalEditPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidProposalEditPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidProposalEditPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отказаться от предложения..  Ставиться статус: OFFER_CONDITIONS_REJECTED Нужно написать в комментарии причину. Проверки: Принимаются только статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED EXPIRED Является ли пользователь владельцем заявки к которой относится предложение. 
     * @summary # Отказаться от предложения.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidProposalRejectPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidProposalRejectPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidProposalRejectPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Отправить на утверждение.  Статус READY_TO_VERIFY ставится автоматом Устанавливается время на принятие автоматом предложения клиентом  Если в заявке было требование проверять супервизором, то время не устанавливается. Проверки: Только предложения со статусом:  OFFER_CONDITIONS_ACCEPTED
     * @summary #  Отправить предложение на утверждение.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidReadyToVerifyPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidReadyToVerifyPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidReadyToVerifyPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Принять результаты работы.   Произвести оплаты Если клиент принял предложение, то статус меняется на ACCEPTED_BY_CLIENT, Если супервайзер принял предложение, то статус меняется на ACCEPTED_BY_SUPERVISOR  ## Заявка переходит в статус COMPLETE_PROPOSALS_AMOUNT_ACHIEVED при достижении задорного количества принятых предложений. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED, READY_TO_VERIFY, VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR, TO_CORRECT, CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
     * @summary #  Принять результаты работы.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidResultAcceptPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidResultAcceptPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidResultAcceptPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Отправить обратно на утверждение, после доработки.  Статус ставится автоматом: CORRECTED В зависимости была ли в заявке требование проверки супервизором, устанавливается время. После достижении времени, предложение будет принято автоматом  если была в заявке была проверка супервайзером, то сепервайзер снимается с проверки предложения. Исполнитель может написать комментарий к действию или прикрепить ссылки на медиа файлы Проверки: Только предложения со статусом: TO_CORRECT
     * @summary #  Отправить обратно на утверждение, после доработки.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidResultCorrectedPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidResultCorrectedPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidResultCorrectedPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отправить на доработку результат работы.  Ставиться статус TO_CORRECT Нужно написать в комментарии причину. Можно выставить время на доработку, в минутах. по умолчанию 120 мин. Проверки: Если вызвал СОЗДАТЕЛЬ ЗАЯВКИ принимаются только статусы:  OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли пользователь владельцем заявки к которой относится предложение. Если вызвал СУПЕРВАЙЗЕР принимаются только статусы:  VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED Является ли вызвавший данный метод супервайзер ответственным за проверку данного предложения.
     * @summary # Отправить на доработку результат работы.
     * @param {RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsGuidResultToCorrectPatch(requestParameters: RequestProposalsApiApiV1RequestProposalsGuidResultToCorrectPatchRequest, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsGuidResultToCorrectPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить все предложения фрилансера с пагинацией [sub, master]
     * @summary Получить все предложения фрилансера [sub, master].
     * @param {RequestProposalsApiApiV1RequestProposalsPagMyAllGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsPagMyAllGet(requestParameters: RequestProposalsApiApiV1RequestProposalsPagMyAllGetRequest = {}, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsPagMyAllGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить все предложения фрилансера с пагинацией
     * @summary Получить все предложения фрилансера.
     * @param {RequestProposalsApiApiV1RequestProposalsPagMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestProposalsApi
     */
    public apiV1RequestProposalsPagMyGet(requestParameters: RequestProposalsApiApiV1RequestProposalsPagMyGetRequest = {}, options?: any) {
        return RequestProposalsApiFp(this.configuration).apiV1RequestProposalsPagMyGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
