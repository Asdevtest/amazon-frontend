/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject113 } from '../models';
// @ts-ignore
import { InlineObject114 } from '../models';
// @ts-ignore
import { InlineObject115 } from '../models';
// @ts-ignore
import { InlineObject116 } from '../models';
// @ts-ignore
import { InlineObject117 } from '../models';
// @ts-ignore
import { InlineObject118 } from '../models';
// @ts-ignore
import { InlineObject119 } from '../models';
// @ts-ignore
import { InlineObject120 } from '../models';
// @ts-ignore
import { InlineObject168 } from '../models';
// @ts-ignore
import { InlineObject169 } from '../models';
// @ts-ignore
import { InlineObject170 } from '../models';
// @ts-ignore
import { InlineObject5 } from '../models';
// @ts-ignore
import { InlineResponse200120 } from '../models';
// @ts-ignore
import { InlineResponse200121 } from '../models';
// @ts-ignore
import { InlineResponse20089 } from '../models';
// @ts-ignore
import { InlineResponse20090 } from '../models';
// @ts-ignore
import { InlineResponse20091 } from '../models';
// @ts-ignore
import { InlineResponse20092 } from '../models';
// @ts-ignore
import { InlineResponse20093 } from '../models';
// @ts-ignore
import { InlineResponse20112 } from '../models';
// @ts-ignore
import { InlineResponse20113 } from '../models';
// @ts-ignore
import { InlineResponse2017 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * RequestsApi - axios parameter creator
 * @export
 */
export const RequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получить облегченный список заявок по продукту   
         * @summary Получить облегченный список заявок по продукту
         * @param {string} guid GUID в сущности в БД
         * @param {string} [status] 
         * @param {string} [excludeIdeaId] Гуид идеи, который исключить
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsByProductLightGuidGet: async (guid: string, status?: string, excludeIdeaId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsByProductLightGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/requests/by_product/light/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (excludeIdeaId !== undefined) {
                localVarQueryParameter['excludeIdeaId'] = excludeIdeaId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Получить детализацию стоимости заявки.  Перед публикованием заявки, нужно уведомить пользователя стоимости. Точность до сотых, (0.01$)   Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами DRAFT или FORBID_NEW_PROPOSALS.
         * @summary Получить детализацию стоимости заявки
         * @param {string} guid GUID в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCalculateRequestCostGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsCalculateRequestCostGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/requests/calculate_request_cost/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Метод для ручного закрытия заявки.    ## Метод вызывает юзер с ролью 10 ## Реквест находится в статусах : IN_PROCESS || EXPIRED || FORBID_NEW_PROPOSALS ## По реквесту минимум 1 предложение(proposal) в статусе ACCEPTED_BY_CLIENT ( можно найти объединением таблиц requests + request_proposals)  
         * @summary # Метод для ручного закрытия заявки
         * @param {string} guid GUID сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCompletedGuidPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsCompletedGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/completed/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить детали заявки.   Проверки: Только владелец может редактировать заявку  
         * @summary #  Изменить детали заявки.
         * @param {string} guid GUID заявки в БД
         * @param {InlineObject170} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomDetailsGuidPatch: async (guid: string, body?: InlineObject170, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsCustomDetailsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/custom/details/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все уникальные заявки для исполнителя.   
         * @summary Получить все уникальные заявки для исполнителя.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/requests/custom/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить уникальную заявку по его guid.   
         * @summary Получить уникальную заявку по его guid.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomGuidGet: async (guid: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsCustomGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/requests/custom/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить заявку.   Цена будет округлена на до 0,01$   Проверки: Только владелец может редактировать заявку  Проверка на статус, статус должен быть DRAFT или PUBLISHED..
         * @summary #  Изменить заявку.
         * @param {string} guid GUID в БД
         * @param {InlineObject169} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomGuidPatch: async (guid: string, body?: InlineObject169, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsCustomGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/custom/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать универсальную заявку.   Цена будет округлена на до 0,01$   Роли которые могут работать с заявками клиент, фрилансер и супервайзер  Проверки: пока нет проверки (Цена за предложение не должно быть меньше установленного в админке.)
         * @summary # Создать универсальную заявку.
         * @param {InlineObject168} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomPost: async (body?: InlineObject168, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/requests/custom/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод должен выдавать заявки в зависимости от query params.   
         * @summary Получить список заявок
         * @param {'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL'} kind Виды заявок:             VACANT - все заявки со статусом TO_PUBLISH и IN_PROCESS, + должны быть свободные слоты для предложений.             Фильтрует по ролям доступных для заявки.             Срыты заявки созданые тем кто вызвал данный метод.             MY - все заявки созданные тем кто вызывает метод,               countProposalsByStatuses: {                 allProposals: - предложения со статусами CREATED,OFFER_CONDITIONS_REJECTED,OFFER_CONDITIONS_CORRECTED,OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR,                 waitedProposals: - предложения со статусами READY_TO_VERIFY,                 atWorkProposals: - предложения со статусами OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,                 verifyingProposals: - предложения со статусами VERIFYING_BY_SUPERVISOR,                 acceptedProposals: - предложения со статусами ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR               }             PICKUPED_BY_ME - все заявки где числится как исполнитель тот кто вызывает метод,             ALL - абсолютно все заявки, без исключения,             ASSIGNED_TO_ME - пока не реализовано.
         * @param {string} [productId] Гуид продукта
         * @param {boolean} [onlyWaitedProposals] Только проверенные предложения
         * @param {string} [filters]                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGet: async (kind: 'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL', productId?: string, onlyWaitedProposals?: boolean, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kind' is not null or undefined
            assertParamExists('apiV1RequestsGet', 'kind', kind)
            const localVarPath = `/api/v1/requests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (onlyWaitedProposals !== undefined) {
                localVarQueryParameter['onlyWaitedProposals'] = onlyWaitedProposals;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить заявки с определенным продуктом и типом задания
         * @summary Получить заявки с определенным продуктом и типом задания
         * @param {string} guid GUID в БД
         * @param {number} specType Тип задачи заявки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGetExistingRequestsSpecTypeGuidGet: async (guid: string, specType: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGetExistingRequestsSpecTypeGuidGet', 'guid', guid)
            // verify required parameter 'specType' is not null or undefined
            assertParamExists('apiV1RequestsGetExistingRequestsSpecTypeGuidGet', 'specType', specType)
            const localVarPath = `/api/v1/requests/get_existing_requests/{specType}/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"specType"}}`, encodeURIComponent(String(specType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Прервать прием предложений.  При вызове этого метода клиент прекращает прием предложений, статус меняется на FORBID_NEW_PROPOSALS  Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами PUBLISHED, IN_PROGRESS
         * @summary # Прервать прием предложений.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject117} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidAbortPatch: async (guid: string, body?: InlineObject117, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGuidAbortPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/{guid}/abort`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## УОтменить заявку создателем.    Заявку можно отменить только если статус DRAFT или PUBLISHED. Только владелец может отменить заявку  
         * @summary # Отменить заявку создателем
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidCancelByCreatorPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGuidCancelByCreatorPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/{guid}/cancel_by_creator`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить заявку по его GUIDD.    Заявку можно удалить только если статус DRAFT или PUBLISHED. Только владелец может удалить заявку  
         * @summary # (возможно данные метод не нужен) Удалить заявку по его GUID.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/requests/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Этот метод вызывает тот кто бронирует место в заявке.  При первом бронировании статус заявка меняется с PUBLISHED на IN_PROGRESS. В зависимости от типа заявки создается предложение и его детали, статус предложения CREATED  ## Создается чат и добавляется клиент и исполнитель  Проверки: Можно бронировать только заявки со статусами: PUBLISHED, IN_PROCESS Владелец заявки не может отправлять себе предложения.  Если роль пользователя нет в списке roles заявки, то не может забронировать Если есть ограничение по количеству предложений maxAmountOfProposals !== null  Количество активных (принятых + в работе) предложений меньше чем ограничение клиента на эту заявку. Активные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ACCEPTED_BY_CLIENT ACCEPTED_BY_SUPERVISOR  Если у данной заявки есть незавершенные предложения от данного пользователя Незавершенные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
         * @summary # Этот метод вызывает тот кто бронирует место в заявке.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject116} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidPickupPost: async (guid: string, body?: InlineObject116, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGuidPickupPost', 'guid', guid)
            const localVarPath = `/api/v1/requests/{guid}/pickup`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Опубликовать заявку.   Статус поменяется на PUBLISHED. ## Важно!! Для избежания проблем связанных с изменением состояния заявки, с того момента когда пользователь  ## получил детализацию из калькулятора стоимости заявки и до момента вызова данного метода,  для подтверждения нужно вернуть totalCost Проверки:  Публиковать можно только заявки со статусом DRAFT и FORBID_NEW_PROPOSALS. Только владелец может опубликовать. Проверка изменения totalCost
         * @summary #  Опубликовать заявку.
         * @param {string} guid GUID в БД
         * @param {InlineObject113} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidToPublishPatch: async (guid: string, body?: InlineObject113, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGuidToPublishPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/{guid}/to_publish`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновить дедлайн, вернуть из статуса EXPIRED
         * @summary # Обновить дедлайн, вернуть из статуса EXPIRED
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject115} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidUpdateDeadlinePatch: async (guid: string, body?: InlineObject115, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsGuidUpdateDeadlinePatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/{guid}/update_deadline`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Связать заявку с идеей
         * @summary #  Связать заявку с идеей, поле, которое не отправляется сетится на наллб если ничего не отправлено - на налл сетятся оба
         * @param {string} guid ID идеи
         * @param {InlineObject120} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsIdeasGuidPatch: async (guid: string, body?: InlineObject120, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsIdeasGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/ideas/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить исходник
         * @summary #  Удалить исходник.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsMediaGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/requests/media/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить медиа
         * @summary #  Получить медиа.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsMediaGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/requests/media/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить медиа
         * @summary #  Изменить медиа.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject118} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaGuidPatch: async (guid: string, body?: InlineObject118, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1RequestsMediaGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/requests/media/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить медиа
         * @summary #  Изменить медиа.
         * @param {Array<InlineObject5>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaManyPatch: async (body?: Array<InlineObject5>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/requests/media/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать медиа
         * @summary #  Создать медиа.
         * @param {InlineObject119} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaPost: async (body?: InlineObject119, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/requests/media`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Изменить uploadedToListing
         * @summary # Изменить uploadedToListing
         * @param {InlineObject114} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsUploadedToListingPatch: async (body?: InlineObject114, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/requests/uploaded_to_listing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestsApi - functional programming interface
 * @export
 */
export const RequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Получить облегченный список заявок по продукту   
         * @summary Получить облегченный список заявок по продукту
         * @param {string} guid GUID в сущности в БД
         * @param {string} [status] 
         * @param {string} [excludeIdeaId] Гуид идеи, который исключить
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsByProductLightGuidGet(guid: string, status?: string, excludeIdeaId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20092>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsByProductLightGuidGet(guid, status, excludeIdeaId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Получить детализацию стоимости заявки.  Перед публикованием заявки, нужно уведомить пользователя стоимости. Точность до сотых, (0.01$)   Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами DRAFT или FORBID_NEW_PROPOSALS.
         * @summary Получить детализацию стоимости заявки
         * @param {string} guid GUID в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCalculateRequestCostGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20089>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCalculateRequestCostGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Метод для ручного закрытия заявки.    ## Метод вызывает юзер с ролью 10 ## Реквест находится в статусах : IN_PROCESS || EXPIRED || FORBID_NEW_PROPOSALS ## По реквесту минимум 1 предложение(proposal) в статусе ACCEPTED_BY_CLIENT ( можно найти объединением таблиц requests + request_proposals)  
         * @summary # Метод для ручного закрытия заявки
         * @param {string} guid GUID сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCompletedGuidPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCompletedGuidPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить детали заявки.   Проверки: Только владелец может редактировать заявку  
         * @summary #  Изменить детали заявки.
         * @param {string} guid GUID заявки в БД
         * @param {InlineObject170} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCustomDetailsGuidPatch(guid: string, body?: InlineObject170, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCustomDetailsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все уникальные заявки для исполнителя.   
         * @summary Получить все уникальные заявки для исполнителя.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCustomGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200120>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCustomGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить уникальную заявку по его guid.   
         * @summary Получить уникальную заявку по его guid.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCustomGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200121>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCustomGuidGet(guid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить заявку.   Цена будет округлена на до 0,01$   Проверки: Только владелец может редактировать заявку  Проверка на статус, статус должен быть DRAFT или PUBLISHED..
         * @summary #  Изменить заявку.
         * @param {string} guid GUID в БД
         * @param {InlineObject169} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCustomGuidPatch(guid: string, body?: InlineObject169, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCustomGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать универсальную заявку.   Цена будет округлена на до 0,01$   Роли которые могут работать с заявками клиент, фрилансер и супервайзер  Проверки: пока нет проверки (Цена за предложение не должно быть меньше установленного в админке.)
         * @summary # Создать универсальную заявку.
         * @param {InlineObject168} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsCustomPost(body?: InlineObject168, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsCustomPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Метод должен выдавать заявки в зависимости от query params.   
         * @summary Получить список заявок
         * @param {'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL'} kind Виды заявок:             VACANT - все заявки со статусом TO_PUBLISH и IN_PROCESS, + должны быть свободные слоты для предложений.             Фильтрует по ролям доступных для заявки.             Срыты заявки созданые тем кто вызвал данный метод.             MY - все заявки созданные тем кто вызывает метод,               countProposalsByStatuses: {                 allProposals: - предложения со статусами CREATED,OFFER_CONDITIONS_REJECTED,OFFER_CONDITIONS_CORRECTED,OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR,                 waitedProposals: - предложения со статусами READY_TO_VERIFY,                 atWorkProposals: - предложения со статусами OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,                 verifyingProposals: - предложения со статусами VERIFYING_BY_SUPERVISOR,                 acceptedProposals: - предложения со статусами ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR               }             PICKUPED_BY_ME - все заявки где числится как исполнитель тот кто вызывает метод,             ALL - абсолютно все заявки, без исключения,             ASSIGNED_TO_ME - пока не реализовано.
         * @param {string} [productId] Гуид продукта
         * @param {boolean} [onlyWaitedProposals] Только проверенные предложения
         * @param {string} [filters]                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGet(kind: 'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL', productId?: string, onlyWaitedProposals?: boolean, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20091>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGet(kind, productId, onlyWaitedProposals, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить заявки с определенным продуктом и типом задания
         * @summary Получить заявки с определенным продуктом и типом задания
         * @param {string} guid GUID в БД
         * @param {number} specType Тип задачи заявки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGetExistingRequestsSpecTypeGuidGet(guid: string, specType: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20090>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGetExistingRequestsSpecTypeGuidGet(guid, specType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Прервать прием предложений.  При вызове этого метода клиент прекращает прием предложений, статус меняется на FORBID_NEW_PROPOSALS  Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами PUBLISHED, IN_PROGRESS
         * @summary # Прервать прием предложений.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject117} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGuidAbortPatch(guid: string, body?: InlineObject117, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGuidAbortPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## УОтменить заявку создателем.    Заявку можно отменить только если статус DRAFT или PUBLISHED. Только владелец может отменить заявку  
         * @summary # Отменить заявку создателем
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGuidCancelByCreatorPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGuidCancelByCreatorPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить заявку по его GUIDD.    Заявку можно удалить только если статус DRAFT или PUBLISHED. Только владелец может удалить заявку  
         * @summary # (возможно данные метод не нужен) Удалить заявку по его GUID.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Этот метод вызывает тот кто бронирует место в заявке.  При первом бронировании статус заявка меняется с PUBLISHED на IN_PROGRESS. В зависимости от типа заявки создается предложение и его детали, статус предложения CREATED  ## Создается чат и добавляется клиент и исполнитель  Проверки: Можно бронировать только заявки со статусами: PUBLISHED, IN_PROCESS Владелец заявки не может отправлять себе предложения.  Если роль пользователя нет в списке roles заявки, то не может забронировать Если есть ограничение по количеству предложений maxAmountOfProposals !== null  Количество активных (принятых + в работе) предложений меньше чем ограничение клиента на эту заявку. Активные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ACCEPTED_BY_CLIENT ACCEPTED_BY_SUPERVISOR  Если у данной заявки есть незавершенные предложения от данного пользователя Незавершенные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
         * @summary # Этот метод вызывает тот кто бронирует место в заявке.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject116} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGuidPickupPost(guid: string, body?: InlineObject116, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20112>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGuidPickupPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Опубликовать заявку.   Статус поменяется на PUBLISHED. ## Важно!! Для избежания проблем связанных с изменением состояния заявки, с того момента когда пользователь  ## получил детализацию из калькулятора стоимости заявки и до момента вызова данного метода,  для подтверждения нужно вернуть totalCost Проверки:  Публиковать можно только заявки со статусом DRAFT и FORBID_NEW_PROPOSALS. Только владелец может опубликовать. Проверка изменения totalCost
         * @summary #  Опубликовать заявку.
         * @param {string} guid GUID в БД
         * @param {InlineObject113} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGuidToPublishPatch(guid: string, body?: InlineObject113, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGuidToPublishPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Обновить дедлайн, вернуть из статуса EXPIRED
         * @summary # Обновить дедлайн, вернуть из статуса EXPIRED
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject115} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsGuidUpdateDeadlinePatch(guid: string, body?: InlineObject115, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsGuidUpdateDeadlinePatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Связать заявку с идеей
         * @summary #  Связать заявку с идеей, поле, которое не отправляется сетится на наллб если ничего не отправлено - на налл сетятся оба
         * @param {string} guid ID идеи
         * @param {InlineObject120} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsIdeasGuidPatch(guid: string, body?: InlineObject120, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsIdeasGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить исходник
         * @summary #  Удалить исходник.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsMediaGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsMediaGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить медиа
         * @summary #  Получить медиа.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsMediaGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20093>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsMediaGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить медиа
         * @summary #  Изменить медиа.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject118} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsMediaGuidPatch(guid: string, body?: InlineObject118, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsMediaGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить медиа
         * @summary #  Изменить медиа.
         * @param {Array<InlineObject5>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsMediaManyPatch(body?: Array<InlineObject5>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsMediaManyPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать медиа
         * @summary #  Создать медиа.
         * @param {InlineObject119} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsMediaPost(body?: InlineObject119, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20113>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsMediaPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Изменить uploadedToListing
         * @summary # Изменить uploadedToListing
         * @param {InlineObject114} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RequestsUploadedToListingPatch(body?: InlineObject114, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1RequestsUploadedToListingPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestsApi - factory interface
 * @export
 */
export const RequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestsApiFp(configuration)
    return {
        /**
         * Получить облегченный список заявок по продукту   
         * @summary Получить облегченный список заявок по продукту
         * @param {string} guid GUID в сущности в БД
         * @param {string} [status] 
         * @param {string} [excludeIdeaId] Гуид идеи, который исключить
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsByProductLightGuidGet(guid: string, status?: string, excludeIdeaId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20092>> {
            return localVarFp.apiV1RequestsByProductLightGuidGet(guid, status, excludeIdeaId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Получить детализацию стоимости заявки.  Перед публикованием заявки, нужно уведомить пользователя стоимости. Точность до сотых, (0.01$)   Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами DRAFT или FORBID_NEW_PROPOSALS.
         * @summary Получить детализацию стоимости заявки
         * @param {string} guid GUID в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCalculateRequestCostGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20089> {
            return localVarFp.apiV1RequestsCalculateRequestCostGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Метод для ручного закрытия заявки.    ## Метод вызывает юзер с ролью 10 ## Реквест находится в статусах : IN_PROCESS || EXPIRED || FORBID_NEW_PROPOSALS ## По реквесту минимум 1 предложение(proposal) в статусе ACCEPTED_BY_CLIENT ( можно найти объединением таблиц requests + request_proposals)  
         * @summary # Метод для ручного закрытия заявки
         * @param {string} guid GUID сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCompletedGuidPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsCompletedGuidPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить детали заявки.   Проверки: Только владелец может редактировать заявку  
         * @summary #  Изменить детали заявки.
         * @param {string} guid GUID заявки в БД
         * @param {InlineObject170} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomDetailsGuidPatch(guid: string, body?: InlineObject170, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsCustomDetailsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все уникальные заявки для исполнителя.   
         * @summary Получить все уникальные заявки для исполнителя.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200120>> {
            return localVarFp.apiV1RequestsCustomGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить уникальную заявку по его guid.   
         * @summary Получить уникальную заявку по его guid.
         * @param {string} guid GUID в сущности в БД
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200121> {
            return localVarFp.apiV1RequestsCustomGuidGet(guid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить заявку.   Цена будет округлена на до 0,01$   Проверки: Только владелец может редактировать заявку  Проверка на статус, статус должен быть DRAFT или PUBLISHED..
         * @summary #  Изменить заявку.
         * @param {string} guid GUID в БД
         * @param {InlineObject169} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomGuidPatch(guid: string, body?: InlineObject169, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsCustomGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать универсальную заявку.   Цена будет округлена на до 0,01$   Роли которые могут работать с заявками клиент, фрилансер и супервайзер  Проверки: пока нет проверки (Цена за предложение не должно быть меньше установленного в админке.)
         * @summary # Создать универсальную заявку.
         * @param {InlineObject168} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsCustomPost(body?: InlineObject168, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.apiV1RequestsCustomPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Метод должен выдавать заявки в зависимости от query params.   
         * @summary Получить список заявок
         * @param {'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL'} kind Виды заявок:             VACANT - все заявки со статусом TO_PUBLISH и IN_PROCESS, + должны быть свободные слоты для предложений.             Фильтрует по ролям доступных для заявки.             Срыты заявки созданые тем кто вызвал данный метод.             MY - все заявки созданные тем кто вызывает метод,               countProposalsByStatuses: {                 allProposals: - предложения со статусами CREATED,OFFER_CONDITIONS_REJECTED,OFFER_CONDITIONS_CORRECTED,OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR,                 waitedProposals: - предложения со статусами READY_TO_VERIFY,                 atWorkProposals: - предложения со статусами OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,                 verifyingProposals: - предложения со статусами VERIFYING_BY_SUPERVISOR,                 acceptedProposals: - предложения со статусами ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR               }             PICKUPED_BY_ME - все заявки где числится как исполнитель тот кто вызывает метод,             ALL - абсолютно все заявки, без исключения,             ASSIGNED_TO_ME - пока не реализовано.
         * @param {string} [productId] Гуид продукта
         * @param {boolean} [onlyWaitedProposals] Только проверенные предложения
         * @param {string} [filters]                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGet(kind: 'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL', productId?: string, onlyWaitedProposals?: boolean, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20091> {
            return localVarFp.apiV1RequestsGet(kind, productId, onlyWaitedProposals, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить заявки с определенным продуктом и типом задания
         * @summary Получить заявки с определенным продуктом и типом задания
         * @param {string} guid GUID в БД
         * @param {number} specType Тип задачи заявки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGetExistingRequestsSpecTypeGuidGet(guid: string, specType: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20090>> {
            return localVarFp.apiV1RequestsGetExistingRequestsSpecTypeGuidGet(guid, specType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Прервать прием предложений.  При вызове этого метода клиент прекращает прием предложений, статус меняется на FORBID_NEW_PROPOSALS  Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами PUBLISHED, IN_PROGRESS
         * @summary # Прервать прием предложений.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject117} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidAbortPatch(guid: string, body?: InlineObject117, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsGuidAbortPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## УОтменить заявку создателем.    Заявку можно отменить только если статус DRAFT или PUBLISHED. Только владелец может отменить заявку  
         * @summary # Отменить заявку создателем
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidCancelByCreatorPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsGuidCancelByCreatorPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить заявку по его GUIDD.    Заявку можно удалить только если статус DRAFT или PUBLISHED. Только владелец может удалить заявку  
         * @summary # (возможно данные метод не нужен) Удалить заявку по его GUID.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Этот метод вызывает тот кто бронирует место в заявке.  При первом бронировании статус заявка меняется с PUBLISHED на IN_PROGRESS. В зависимости от типа заявки создается предложение и его детали, статус предложения CREATED  ## Создается чат и добавляется клиент и исполнитель  Проверки: Можно бронировать только заявки со статусами: PUBLISHED, IN_PROCESS Владелец заявки не может отправлять себе предложения.  Если роль пользователя нет в списке roles заявки, то не может забронировать Если есть ограничение по количеству предложений maxAmountOfProposals !== null  Количество активных (принятых + в работе) предложений меньше чем ограничение клиента на эту заявку. Активные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ACCEPTED_BY_CLIENT ACCEPTED_BY_SUPERVISOR  Если у данной заявки есть незавершенные предложения от данного пользователя Незавершенные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
         * @summary # Этот метод вызывает тот кто бронирует место в заявке.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject116} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidPickupPost(guid: string, body?: InlineObject116, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20112> {
            return localVarFp.apiV1RequestsGuidPickupPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Опубликовать заявку.   Статус поменяется на PUBLISHED. ## Важно!! Для избежания проблем связанных с изменением состояния заявки, с того момента когда пользователь  ## получил детализацию из калькулятора стоимости заявки и до момента вызова данного метода,  для подтверждения нужно вернуть totalCost Проверки:  Публиковать можно только заявки со статусом DRAFT и FORBID_NEW_PROPOSALS. Только владелец может опубликовать. Проверка изменения totalCost
         * @summary #  Опубликовать заявку.
         * @param {string} guid GUID в БД
         * @param {InlineObject113} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidToPublishPatch(guid: string, body?: InlineObject113, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsGuidToPublishPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновить дедлайн, вернуть из статуса EXPIRED
         * @summary # Обновить дедлайн, вернуть из статуса EXPIRED
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject115} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsGuidUpdateDeadlinePatch(guid: string, body?: InlineObject115, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsGuidUpdateDeadlinePatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Связать заявку с идеей
         * @summary #  Связать заявку с идеей, поле, которое не отправляется сетится на наллб если ничего не отправлено - на налл сетятся оба
         * @param {string} guid ID идеи
         * @param {InlineObject120} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsIdeasGuidPatch(guid: string, body?: InlineObject120, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsIdeasGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить исходник
         * @summary #  Удалить исходник.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsMediaGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить медиа
         * @summary #  Получить медиа.
         * @param {string} guid GUID в сущности в БД
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20093>> {
            return localVarFp.apiV1RequestsMediaGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить медиа
         * @summary #  Изменить медиа.
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject118} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaGuidPatch(guid: string, body?: InlineObject118, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsMediaGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить медиа
         * @summary #  Изменить медиа.
         * @param {Array<InlineObject5>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaManyPatch(body?: Array<InlineObject5>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsMediaManyPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать медиа
         * @summary #  Создать медиа.
         * @param {InlineObject119} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsMediaPost(body?: InlineObject119, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20113> {
            return localVarFp.apiV1RequestsMediaPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Изменить uploadedToListing
         * @summary # Изменить uploadedToListing
         * @param {InlineObject114} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RequestsUploadedToListingPatch(body?: InlineObject114, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1RequestsUploadedToListingPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1RequestsByProductLightGuidGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsByProductLightGuidGetRequest
 */
export interface RequestsApiApiV1RequestsByProductLightGuidGetRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsByProductLightGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsByProductLightGuidGet
     */
    readonly status?: string

    /**
     * Гуид идеи, который исключить
     * @type {string}
     * @memberof RequestsApiApiV1RequestsByProductLightGuidGet
     */
    readonly excludeIdeaId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestsApiApiV1RequestsByProductLightGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsByProductLightGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCalculateRequestCostGuidGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCalculateRequestCostGuidGetRequest
 */
export interface RequestsApiApiV1RequestsCalculateRequestCostGuidGetRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCalculateRequestCostGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCalculateRequestCostGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCompletedGuidPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCompletedGuidPatchRequest
 */
export interface RequestsApiApiV1RequestsCompletedGuidPatchRequest {
    /**
     * GUID сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCompletedGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCompletedGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCustomDetailsGuidPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCustomDetailsGuidPatchRequest
 */
export interface RequestsApiApiV1RequestsCustomDetailsGuidPatchRequest {
    /**
     * GUID заявки в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomDetailsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject170}
     * @memberof RequestsApiApiV1RequestsCustomDetailsGuidPatch
     */
    readonly body?: InlineObject170

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomDetailsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCustomGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCustomGetRequest
 */
export interface RequestsApiApiV1RequestsCustomGetRequest {
    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCustomGuidGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCustomGuidGetRequest
 */
export interface RequestsApiApiV1RequestsCustomGuidGetRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestsApiApiV1RequestsCustomGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCustomGuidPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCustomGuidPatchRequest
 */
export interface RequestsApiApiV1RequestsCustomGuidPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject169}
     * @memberof RequestsApiApiV1RequestsCustomGuidPatch
     */
    readonly body?: InlineObject169

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsCustomPost operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsCustomPostRequest
 */
export interface RequestsApiApiV1RequestsCustomPostRequest {
    /**
     * 
     * @type {InlineObject168}
     * @memberof RequestsApiApiV1RequestsCustomPost
     */
    readonly body?: InlineObject168

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsCustomPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGetRequest
 */
export interface RequestsApiApiV1RequestsGetRequest {
    /**
     * Виды заявок:             VACANT - все заявки со статусом TO_PUBLISH и IN_PROCESS, + должны быть свободные слоты для предложений.             Фильтрует по ролям доступных для заявки.             Срыты заявки созданые тем кто вызвал данный метод.             MY - все заявки созданные тем кто вызывает метод,               countProposalsByStatuses: {                 allProposals: - предложения со статусами CREATED,OFFER_CONDITIONS_REJECTED,OFFER_CONDITIONS_CORRECTED,OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR,                 waitedProposals: - предложения со статусами READY_TO_VERIFY,                 atWorkProposals: - предложения со статусами OFFER_CONDITIONS_ACCEPTED,READY_TO_VERIFY,VERIFYING_BY_SUPERVISOR,TO_CORRECT,CORRECTED,                 verifyingProposals: - предложения со статусами VERIFYING_BY_SUPERVISOR,                 acceptedProposals: - предложения со статусами ACCEPTED_BY_CLIENT,ACCEPTED_BY_SUPERVISOR               }             PICKUPED_BY_ME - все заявки где числится как исполнитель тот кто вызывает метод,             ALL - абсолютно все заявки, без исключения,             ASSIGNED_TO_ME - пока не реализовано.
     * @type {'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL'}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly kind: 'VACANT' | 'MY' | 'PICKUPED_BY_ME' | 'ALL'

    /**
     * Гуид продукта
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly productId?: string

    /**
     * Только проверенные предложения
     * @type {boolean}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly onlyWaitedProposals?: boolean

    /**
     *                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGetExistingRequestsSpecTypeGuidGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGetRequest
 */
export interface RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGetRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGet
     */
    readonly guid: string

    /**
     * Тип задачи заявки
     * @type {number}
     * @memberof RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGet
     */
    readonly specType: number

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGuidAbortPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGuidAbortPatchRequest
 */
export interface RequestsApiApiV1RequestsGuidAbortPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidAbortPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject117}
     * @memberof RequestsApiApiV1RequestsGuidAbortPatch
     */
    readonly body?: InlineObject117

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidAbortPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGuidCancelByCreatorPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGuidCancelByCreatorPatchRequest
 */
export interface RequestsApiApiV1RequestsGuidCancelByCreatorPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidCancelByCreatorPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidCancelByCreatorPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGuidDelete operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGuidDeleteRequest
 */
export interface RequestsApiApiV1RequestsGuidDeleteRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGuidPickupPost operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGuidPickupPostRequest
 */
export interface RequestsApiApiV1RequestsGuidPickupPostRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidPickupPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject116}
     * @memberof RequestsApiApiV1RequestsGuidPickupPost
     */
    readonly body?: InlineObject116

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidPickupPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGuidToPublishPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGuidToPublishPatchRequest
 */
export interface RequestsApiApiV1RequestsGuidToPublishPatchRequest {
    /**
     * GUID в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidToPublishPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject113}
     * @memberof RequestsApiApiV1RequestsGuidToPublishPatch
     */
    readonly body?: InlineObject113

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidToPublishPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsGuidUpdateDeadlinePatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsGuidUpdateDeadlinePatchRequest
 */
export interface RequestsApiApiV1RequestsGuidUpdateDeadlinePatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidUpdateDeadlinePatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject115}
     * @memberof RequestsApiApiV1RequestsGuidUpdateDeadlinePatch
     */
    readonly body?: InlineObject115

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsGuidUpdateDeadlinePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsIdeasGuidPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsIdeasGuidPatchRequest
 */
export interface RequestsApiApiV1RequestsIdeasGuidPatchRequest {
    /**
     * ID идеи
     * @type {string}
     * @memberof RequestsApiApiV1RequestsIdeasGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject120}
     * @memberof RequestsApiApiV1RequestsIdeasGuidPatch
     */
    readonly body?: InlineObject120

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsIdeasGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsMediaGuidDelete operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsMediaGuidDeleteRequest
 */
export interface RequestsApiApiV1RequestsMediaGuidDeleteRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsMediaGuidGet operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsMediaGuidGetRequest
 */
export interface RequestsApiApiV1RequestsMediaGuidGetRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsMediaGuidPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsMediaGuidPatchRequest
 */
export interface RequestsApiApiV1RequestsMediaGuidPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject118}
     * @memberof RequestsApiApiV1RequestsMediaGuidPatch
     */
    readonly body?: InlineObject118

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsMediaManyPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsMediaManyPatchRequest
 */
export interface RequestsApiApiV1RequestsMediaManyPatchRequest {
    /**
     * 
     * @type {Array<InlineObject5>}
     * @memberof RequestsApiApiV1RequestsMediaManyPatch
     */
    readonly body?: Array<InlineObject5>

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaManyPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsMediaPost operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsMediaPostRequest
 */
export interface RequestsApiApiV1RequestsMediaPostRequest {
    /**
     * 
     * @type {InlineObject119}
     * @memberof RequestsApiApiV1RequestsMediaPost
     */
    readonly body?: InlineObject119

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsMediaPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1RequestsUploadedToListingPatch operation in RequestsApi.
 * @export
 * @interface RequestsApiApiV1RequestsUploadedToListingPatchRequest
 */
export interface RequestsApiApiV1RequestsUploadedToListingPatchRequest {
    /**
     * 
     * @type {InlineObject114}
     * @memberof RequestsApiApiV1RequestsUploadedToListingPatch
     */
    readonly body?: InlineObject114

    /**
     * 
     * @type {string}
     * @memberof RequestsApiApiV1RequestsUploadedToListingPatch
     */
    readonly acceptEncoding?: string
}

/**
 * RequestsApi - object-oriented interface
 * @export
 * @class RequestsApi
 * @extends {BaseAPI}
 */
export class RequestsApi extends BaseAPI {
    /**
     * Получить облегченный список заявок по продукту   
     * @summary Получить облегченный список заявок по продукту
     * @param {RequestsApiApiV1RequestsByProductLightGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsByProductLightGuidGet(requestParameters: RequestsApiApiV1RequestsByProductLightGuidGetRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsByProductLightGuidGet(requestParameters.guid, requestParameters.status, requestParameters.excludeIdeaId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Получить детализацию стоимости заявки.  Перед публикованием заявки, нужно уведомить пользователя стоимости. Точность до сотых, (0.01$)   Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами DRAFT или FORBID_NEW_PROPOSALS.
     * @summary Получить детализацию стоимости заявки
     * @param {RequestsApiApiV1RequestsCalculateRequestCostGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCalculateRequestCostGuidGet(requestParameters: RequestsApiApiV1RequestsCalculateRequestCostGuidGetRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCalculateRequestCostGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Метод для ручного закрытия заявки.    ## Метод вызывает юзер с ролью 10 ## Реквест находится в статусах : IN_PROCESS || EXPIRED || FORBID_NEW_PROPOSALS ## По реквесту минимум 1 предложение(proposal) в статусе ACCEPTED_BY_CLIENT ( можно найти объединением таблиц requests + request_proposals)  
     * @summary # Метод для ручного закрытия заявки
     * @param {RequestsApiApiV1RequestsCompletedGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCompletedGuidPatch(requestParameters: RequestsApiApiV1RequestsCompletedGuidPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCompletedGuidPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить детали заявки.   Проверки: Только владелец может редактировать заявку  
     * @summary #  Изменить детали заявки.
     * @param {RequestsApiApiV1RequestsCustomDetailsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCustomDetailsGuidPatch(requestParameters: RequestsApiApiV1RequestsCustomDetailsGuidPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCustomDetailsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все уникальные заявки для исполнителя.   
     * @summary Получить все уникальные заявки для исполнителя.
     * @param {RequestsApiApiV1RequestsCustomGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCustomGet(requestParameters: RequestsApiApiV1RequestsCustomGetRequest = {}, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCustomGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить уникальную заявку по его guid.   
     * @summary Получить уникальную заявку по его guid.
     * @param {RequestsApiApiV1RequestsCustomGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCustomGuidGet(requestParameters: RequestsApiApiV1RequestsCustomGuidGetRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCustomGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить заявку.   Цена будет округлена на до 0,01$   Проверки: Только владелец может редактировать заявку  Проверка на статус, статус должен быть DRAFT или PUBLISHED..
     * @summary #  Изменить заявку.
     * @param {RequestsApiApiV1RequestsCustomGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCustomGuidPatch(requestParameters: RequestsApiApiV1RequestsCustomGuidPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCustomGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать универсальную заявку.   Цена будет округлена на до 0,01$   Роли которые могут работать с заявками клиент, фрилансер и супервайзер  Проверки: пока нет проверки (Цена за предложение не должно быть меньше установленного в админке.)
     * @summary # Создать универсальную заявку.
     * @param {RequestsApiApiV1RequestsCustomPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsCustomPost(requestParameters: RequestsApiApiV1RequestsCustomPostRequest = {}, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsCustomPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Метод должен выдавать заявки в зависимости от query params.   
     * @summary Получить список заявок
     * @param {RequestsApiApiV1RequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGet(requestParameters: RequestsApiApiV1RequestsGetRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGet(requestParameters.kind, requestParameters.productId, requestParameters.onlyWaitedProposals, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить заявки с определенным продуктом и типом задания
     * @summary Получить заявки с определенным продуктом и типом задания
     * @param {RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGetExistingRequestsSpecTypeGuidGet(requestParameters: RequestsApiApiV1RequestsGetExistingRequestsSpecTypeGuidGetRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGetExistingRequestsSpecTypeGuidGet(requestParameters.guid, requestParameters.specType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Прервать прием предложений.  При вызове этого метода клиент прекращает прием предложений, статус меняется на FORBID_NEW_PROPOSALS  Проверки: Только владелец заявки может вызывать данный метод Только для заявок  со статусами PUBLISHED, IN_PROGRESS
     * @summary # Прервать прием предложений.
     * @param {RequestsApiApiV1RequestsGuidAbortPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGuidAbortPatch(requestParameters: RequestsApiApiV1RequestsGuidAbortPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGuidAbortPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## УОтменить заявку создателем.    Заявку можно отменить только если статус DRAFT или PUBLISHED. Только владелец может отменить заявку  
     * @summary # Отменить заявку создателем
     * @param {RequestsApiApiV1RequestsGuidCancelByCreatorPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGuidCancelByCreatorPatch(requestParameters: RequestsApiApiV1RequestsGuidCancelByCreatorPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGuidCancelByCreatorPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить заявку по его GUIDD.    Заявку можно удалить только если статус DRAFT или PUBLISHED. Только владелец может удалить заявку  
     * @summary # (возможно данные метод не нужен) Удалить заявку по его GUID.
     * @param {RequestsApiApiV1RequestsGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGuidDelete(requestParameters: RequestsApiApiV1RequestsGuidDeleteRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Этот метод вызывает тот кто бронирует место в заявке.  При первом бронировании статус заявка меняется с PUBLISHED на IN_PROGRESS. В зависимости от типа заявки создается предложение и его детали, статус предложения CREATED  ## Создается чат и добавляется клиент и исполнитель  Проверки: Можно бронировать только заявки со статусами: PUBLISHED, IN_PROCESS Владелец заявки не может отправлять себе предложения.  Если роль пользователя нет в списке roles заявки, то не может забронировать Если есть ограничение по количеству предложений maxAmountOfProposals !== null  Количество активных (принятых + в работе) предложений меньше чем ограничение клиента на эту заявку. Активные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED ACCEPTED_BY_CLIENT ACCEPTED_BY_SUPERVISOR  Если у данной заявки есть незавершенные предложения от данного пользователя Незавершенные предложения имеют статусы:  CREATED OFFER_CONDITIONS_REJECTED OFFER_CONDITIONS_CORRECTED OFFER_CONDITIONS_ACCEPTED READY_TO_VERIFY VERIFYING_BY_SUPERVISOR TO_CORRECT CORRECTED
     * @summary # Этот метод вызывает тот кто бронирует место в заявке.
     * @param {RequestsApiApiV1RequestsGuidPickupPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGuidPickupPost(requestParameters: RequestsApiApiV1RequestsGuidPickupPostRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGuidPickupPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Опубликовать заявку.   Статус поменяется на PUBLISHED. ## Важно!! Для избежания проблем связанных с изменением состояния заявки, с того момента когда пользователь  ## получил детализацию из калькулятора стоимости заявки и до момента вызова данного метода,  для подтверждения нужно вернуть totalCost Проверки:  Публиковать можно только заявки со статусом DRAFT и FORBID_NEW_PROPOSALS. Только владелец может опубликовать. Проверка изменения totalCost
     * @summary #  Опубликовать заявку.
     * @param {RequestsApiApiV1RequestsGuidToPublishPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGuidToPublishPatch(requestParameters: RequestsApiApiV1RequestsGuidToPublishPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGuidToPublishPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновить дедлайн, вернуть из статуса EXPIRED
     * @summary # Обновить дедлайн, вернуть из статуса EXPIRED
     * @param {RequestsApiApiV1RequestsGuidUpdateDeadlinePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsGuidUpdateDeadlinePatch(requestParameters: RequestsApiApiV1RequestsGuidUpdateDeadlinePatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsGuidUpdateDeadlinePatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Связать заявку с идеей
     * @summary #  Связать заявку с идеей, поле, которое не отправляется сетится на наллб если ничего не отправлено - на налл сетятся оба
     * @param {RequestsApiApiV1RequestsIdeasGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsIdeasGuidPatch(requestParameters: RequestsApiApiV1RequestsIdeasGuidPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsIdeasGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить исходник
     * @summary #  Удалить исходник.
     * @param {RequestsApiApiV1RequestsMediaGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsMediaGuidDelete(requestParameters: RequestsApiApiV1RequestsMediaGuidDeleteRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsMediaGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить медиа
     * @summary #  Получить медиа.
     * @param {RequestsApiApiV1RequestsMediaGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsMediaGuidGet(requestParameters: RequestsApiApiV1RequestsMediaGuidGetRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsMediaGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить медиа
     * @summary #  Изменить медиа.
     * @param {RequestsApiApiV1RequestsMediaGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsMediaGuidPatch(requestParameters: RequestsApiApiV1RequestsMediaGuidPatchRequest, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsMediaGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить медиа
     * @summary #  Изменить медиа.
     * @param {RequestsApiApiV1RequestsMediaManyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsMediaManyPatch(requestParameters: RequestsApiApiV1RequestsMediaManyPatchRequest = {}, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsMediaManyPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать медиа
     * @summary #  Создать медиа.
     * @param {RequestsApiApiV1RequestsMediaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsMediaPost(requestParameters: RequestsApiApiV1RequestsMediaPostRequest = {}, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsMediaPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Изменить uploadedToListing
     * @summary # Изменить uploadedToListing
     * @param {RequestsApiApiV1RequestsUploadedToListingPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestsApi
     */
    public apiV1RequestsUploadedToListingPatch(requestParameters: RequestsApiApiV1RequestsUploadedToListingPatchRequest = {}, options?: any) {
        return RequestsApiFp(this.configuration).apiV1RequestsUploadedToListingPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
