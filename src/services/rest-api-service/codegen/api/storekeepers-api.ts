/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiV1AdminsOrdersLogicsTariff } from '../models';
// @ts-ignore
import { ApiV1BatchesBoxes } from '../models';
// @ts-ignore
import { ApiV1StorekeepersTariffWarehouses } from '../models';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject127 } from '../models';
// @ts-ignore
import { InlineObject128 } from '../models';
// @ts-ignore
import { InlineObject129 } from '../models';
// @ts-ignore
import { InlineObject130 } from '../models';
// @ts-ignore
import { InlineObject131 } from '../models';
// @ts-ignore
import { InlineObject132 } from '../models';
// @ts-ignore
import { InlineObject133 } from '../models';
// @ts-ignore
import { InlineObject134 } from '../models';
// @ts-ignore
import { InlineObject135 } from '../models';
// @ts-ignore
import { InlineObject136 } from '../models';
// @ts-ignore
import { InlineObject137 } from '../models';
// @ts-ignore
import { InlineResponse200101 } from '../models';
// @ts-ignore
import { InlineResponse200102 } from '../models';
// @ts-ignore
import { InlineResponse200103 } from '../models';
// @ts-ignore
import { InlineResponse200104 } from '../models';
// @ts-ignore
import { InlineResponse20037 } from '../models';
// @ts-ignore
import { InlineResponse2006 } from '../models';
// @ts-ignore
import { InlineResponse2017 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * StorekeepersApi - axios parameter creator
 * @export
 */
export const StorekeepersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Изменить комментарий коробки сторкипера.   
         * @summary # Изменить комментарий коробки сторкипера.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject132} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersBoxesCommentGuidPatch: async (guid: string, body?: InlineObject132, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersBoxesCommentGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/boxes/comment/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки и их строки по текущему сторкиперу.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
         * @summary # Получить коробки и их строки по текущему сторкиперу.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersBoxesGet: async (noCache?: boolean, offset?: number, limit?: number, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/boxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить коробку сторкипером.   
         * @summary # Изменить коробку сторкипером.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject131} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersBoxesGuidPatch: async (guid: string, body?: InlineObject131, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersBoxesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/boxes/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать/обновить дестинейшн  Доступно для сторкипера
         * @summary # Создать/обновить дестинейшн
         * @param {InlineObject137} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersDestinationPost: async (body?: InlineObject137, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/destination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создается копия партии, коробки получают статус IN_STOCK, слздаются задачи на принятие
         * @summary # Скопировать партию, расформировать, на коробки из партии создать задачи
         * @param {string} guid GUID партии в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersDestructBatchGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersDestructBatchGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/destruct_batch/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить всех сторкиперов(все склады).  если вызвал килен, то показывает сколко коробок у каждого сторкипера пока тут только данные о сторкипере, далее должно быть вся информация о складе, с тарифами  
         * @summary # Получить всех сторкиперов(все склады).
         * @param {boolean} [withoutTariffs] С тарифами
         * @param {string} [boxStatus] Статус коробок,  которые нужно посчитать.
         * @param {number} [tariffType] Тип тарифа(10, 20)
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersGet: async (withoutTariffs?: boolean, boxStatus?: string, tariffType?: number, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withoutTariffs !== undefined) {
                localVarQueryParameter['withoutTariffs'] = withoutTariffs;
            }

            if (boxStatus !== undefined) {
                localVarQueryParameter['boxStatus'] = boxStatus;
            }

            if (tariffType !== undefined) {
                localVarQueryParameter['tariffType'] = tariffType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить значение status  в сущности заказ.   
         * @summary # Изменить значение status в сущности заказ.
         * @param {string} guid GUID ордера, который мы хотим изменить
         * @param {InlineObject130} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersOrdersSetStatusGuidPatch: async (guid: string, body?: InlineObject130, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersOrdersSetStatusGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/orders/set_status/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки и их строки по текущему сторкиперу с пагинацией.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
         * @summary # Получить коробки и их строки по текущему сторкиперу с пагинацией.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersPagBoxesGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/pag/boxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить тариф доставки.  Логическое удаление, isActual = false.         При удалении тарифа доставки все коробки, принадлежащие тарифу, со статусами REQUESTED_SEND_TO_BATCH, IN_BATCH,         переводятся в статус NEED_TO_UPDATE_THE_TARIFF.         Проверки:         Доступно для сторкипера.
         * @summary # Удалить тариф доставки.
         * @param {string} guid GUID тарифа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTariffLogisticsGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tariff-logistics/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать тариф доставки.  Доступно для сторкипера.         у коробок с статусами: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, REQUESTED_SEND_TO_BATCH, IN_BATCH,         при изменении тарифа происходит пересчет стоимостей доставок.         При повышении цены ставиться статус NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, далее нужно ожидать подтверждения от клиента.         Если вернуть цену на старое значение, то статус возвращается к REQUESTED_SEND_TO_BATCH.         При понижении цены автоматом происходит возврат разницы клиенту, статус ставится REQUESTED_SEND_TO_BATCH
         * @summary # Редактировать тариф доставки.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject134} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsGuidPatch: async (guid: string, body?: InlineObject134, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTariffLogisticsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tariff-logistics/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить всех тарифами доставки сторкипером.   доступно сторкипером  
         * @summary # Получить всех тарифами доставки сторкипером.
         * @param {boolean} [archive] Заархивирован ли тариф
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [tariffType] Тип тарифа(10, 20)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsMyGet: async (archive?: boolean, noCache?: boolean, tariffType?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tariff-logistics/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (tariffType !== undefined) {
                localVarQueryParameter['tariffType'] = tariffType;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать тарифами доставки.  
         * @summary # Создать тарифами доставки.
         * @param {InlineObject133} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsPost: async (body?: InlineObject133, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tariff-logistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить тариф склада.  Доступно для сторкипера
         * @summary # Удалить тариф склада.
         * @param {string} guid GUID тарифа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehouseGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTariffWarehouseGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tariff-warehouse/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать тариф услуг склада.  Доступно для сторкипера
         * @summary # Редактировать тариф услуг склада.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject136} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehouseGuidPatch: async (guid: string, body?: InlineObject136, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTariffWarehouseGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tariff-warehouse/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все тарифы сторкипером.   доступно сторкипером  
         * @summary # Получить все тарифы сторкипером.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehouseMyGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tariff-warehouse/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать тариф услуг склада.  
         * @summary # Создать тариф услуг склада.
         * @param {InlineObject135} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehousesPost: async (body?: InlineObject135, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tariff-warehouses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
         * @summary # Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
         * @param {string} [productId] ProductId для расчетов
         * @param {string} [supplierId] SupplierId для расчетов
         * @param {string} [ideaId] IdeaId для расчетов
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Кол-во получаемых записей
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [activeTariffLogisticsId] Active storekeeper logistic tariff guid
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffsWithCalculationsGet: async (productId?: string, supplierId?: string, ideaId?: string, filters?: string, limit?: number, offset?: number, noCache?: boolean, activeTariffLogisticsId?: string, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tariffs_with_calculations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            if (ideaId !== undefined) {
                localVarQueryParameter['ideaId'] = ideaId;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (activeTariffLogisticsId !== undefined) {
                localVarQueryParameter['activeTariffLogisticsId'] = activeTariffLogisticsId;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## NEW! Получить задачу по его id.   
         * @summary # NEW! Получить задачу по его id.
         * @param {string} guid GUID задачи.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTaskLightGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTaskLightGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/task_light/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отметить задачу, как отмененную.  
         * @summary # Отметить задачу, как отмененную..
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksCancelGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTasksCancelGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tasks/cancel/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отметить задачу, как выполненную.  
         * @summary # Отметить задачу, как выполненную.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject127} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksDoneGuidPost: async (guid: string, body?: InlineObject127, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTasksDoneGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tasks/done/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить задачу. Здесь только статус.   
         * @summary # Изменить задачу.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject128} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksGuidPatch: async (guid: string, body?: InlineObject128, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTasksGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tasks/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить задачи закрепленные за данным сборщиком.  
         * @summary # Получить задачи закрепленные за данным сборщиком..
         * @param {number} [status] Статус задачи для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightMyGet: async (status?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks_light/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## олучить задачи закрепленные за данным сторкипером с пагинацией  
         * @summary # Получить задачи закрепленные за данным сторкипером с пагинацией
         * @param {number} [status] Статус задачи для фильтра.
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {string} [operationType] Типы задач разделенные запятой
         * @param {string} [priority] Приоритет задачи
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [filters]                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightPagMyGet: async (status?: number, offset?: number, operationType?: string, priority?: string, limit?: number, filters?: string, noCache?: boolean, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks_light/pag/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить вакантные задачи закрепленные за данным сторкипером с пагинацией  
         * @summary # Получить вакантные задачи закрепленные за данным сторкипером с пагинацией
         * @param {number} [status] Статус задачи для фильтра.
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [priority] Приоритет задачи
         * @param {string} [operationType] Типы задач разделенные запятой
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightPagVacGet: async (status?: number, offset?: number, limit?: number, priority?: string, operationType?: string, filters?: string, noCache?: boolean, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks_light/pag/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить задачи не закрепленные за сотрудниками склада.   
         * @summary # Получить задачи не закрепленные за сотрудниками склада.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightVacGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks_light/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить задачи закрепленные за данным сборщиком.  
         * @summary # Получить задачи закрепленные за данным сборщиком..
         * @param {number} [status] Статус задачи для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksMyGet: async (status?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Закрепить задачу за сборщиком.   
         * @summary # Закрепить задачу за сборщиком.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksPickupGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTasksPickupGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tasks/pickup/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Переврдит все задачи из статуса 0 в статус 10, storekeeper_id должен совпадать с _id юзера
         * @summary # Взять несколько задач сторкипером
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksPickupManyPost: async (body?: Array<string>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks/pickup/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить приоритет задачи.   
         * @summary # Изменить приоритет задачи.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject129} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksPriorityGuidPatch: async (guid: string, body?: InlineObject129, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTasksPriorityGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tasks/priority/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить данные из boxesBefore в формате XLSX
         * @summary # Получить данные из boxesBefore в формате XLSX
         * @param {string} guid GUID таски
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksReportGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1StorekeepersTasksReportGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/storekeepers/tasks/report/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить задачи не закрепленные за сотрудниками склада.   
         * @summary # Deprecated! Получить задачи не закрепленные за сотрудниками склада.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksVacGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storekeepers/tasks/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorekeepersApi - functional programming interface
 * @export
 */
export const StorekeepersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorekeepersApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Изменить комментарий коробки сторкипера.   
         * @summary # Изменить комментарий коробки сторкипера.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject132} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersBoxesCommentGuidPatch(guid: string, body?: InlineObject132, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersBoxesCommentGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки и их строки по текущему сторкиперу.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
         * @summary # Получить коробки и их строки по текущему сторкиперу.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersBoxesGet(noCache?: boolean, offset?: number, limit?: number, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1BatchesBoxes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersBoxesGet(noCache, offset, limit, sortField, sortType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить коробку сторкипером.   
         * @summary # Изменить коробку сторкипером.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject131} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersBoxesGuidPatch(guid: string, body?: InlineObject131, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersBoxesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать/обновить дестинейшн  Доступно для сторкипера
         * @summary # Создать/обновить дестинейшн
         * @param {InlineObject137} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersDestinationPost(body?: InlineObject137, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersDestinationPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создается копия партии, коробки получают статус IN_STOCK, слздаются задачи на принятие
         * @summary # Скопировать партию, расформировать, на коробки из партии создать задачи
         * @param {string} guid GUID партии в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersDestructBatchGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersDestructBatchGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить всех сторкиперов(все склады).  если вызвал килен, то показывает сколко коробок у каждого сторкипера пока тут только данные о сторкипере, далее должно быть вся информация о складе, с тарифами  
         * @summary # Получить всех сторкиперов(все склады).
         * @param {boolean} [withoutTariffs] С тарифами
         * @param {string} [boxStatus] Статус коробок,  которые нужно посчитать.
         * @param {number} [tariffType] Тип тарифа(10, 20)
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersGet(withoutTariffs?: boolean, boxStatus?: string, tariffType?: number, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200103>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersGet(withoutTariffs, boxStatus, tariffType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить значение status  в сущности заказ.   
         * @summary # Изменить значение status в сущности заказ.
         * @param {string} guid GUID ордера, который мы хотим изменить
         * @param {InlineObject130} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersOrdersSetStatusGuidPatch(guid: string, body?: InlineObject130, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersOrdersSetStatusGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки и их строки по текущему сторкиперу с пагинацией.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
         * @summary # Получить коробки и их строки по текущему сторкиперу с пагинацией.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersPagBoxesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200102>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersPagBoxesGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить тариф доставки.  Логическое удаление, isActual = false.         При удалении тарифа доставки все коробки, принадлежащие тарифу, со статусами REQUESTED_SEND_TO_BATCH, IN_BATCH,         переводятся в статус NEED_TO_UPDATE_THE_TARIFF.         Проверки:         Доступно для сторкипера.
         * @summary # Удалить тариф доставки.
         * @param {string} guid GUID тарифа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffLogisticsGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffLogisticsGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать тариф доставки.  Доступно для сторкипера.         у коробок с статусами: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, REQUESTED_SEND_TO_BATCH, IN_BATCH,         при изменении тарифа происходит пересчет стоимостей доставок.         При повышении цены ставиться статус NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, далее нужно ожидать подтверждения от клиента.         Если вернуть цену на старое значение, то статус возвращается к REQUESTED_SEND_TO_BATCH.         При понижении цены автоматом происходит возврат разницы клиенту, статус ставится REQUESTED_SEND_TO_BATCH
         * @summary # Редактировать тариф доставки.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject134} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffLogisticsGuidPatch(guid: string, body?: InlineObject134, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffLogisticsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить всех тарифами доставки сторкипером.   доступно сторкипером  
         * @summary # Получить всех тарифами доставки сторкипером.
         * @param {boolean} [archive] Заархивирован ли тариф
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [tariffType] Тип тарифа(10, 20)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffLogisticsMyGet(archive?: boolean, noCache?: boolean, tariffType?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AdminsOrdersLogicsTariff>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffLogisticsMyGet(archive, noCache, tariffType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать тарифами доставки.  
         * @summary # Создать тарифами доставки.
         * @param {InlineObject133} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffLogisticsPost(body?: InlineObject133, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffLogisticsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить тариф склада.  Доступно для сторкипера
         * @summary # Удалить тариф склада.
         * @param {string} guid GUID тарифа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffWarehouseGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffWarehouseGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать тариф услуг склада.  Доступно для сторкипера
         * @summary # Редактировать тариф услуг склада.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject136} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffWarehouseGuidPatch(guid: string, body?: InlineObject136, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffWarehouseGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все тарифы сторкипером.   доступно сторкипером  
         * @summary # Получить все тарифы сторкипером.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffWarehouseMyGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1StorekeepersTariffWarehouses>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffWarehouseMyGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать тариф услуг склада.  
         * @summary # Создать тариф услуг склада.
         * @param {InlineObject135} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffWarehousesPost(body?: InlineObject135, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffWarehousesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
         * @summary # Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
         * @param {string} [productId] ProductId для расчетов
         * @param {string} [supplierId] SupplierId для расчетов
         * @param {string} [ideaId] IdeaId для расчетов
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Кол-во получаемых записей
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [activeTariffLogisticsId] Active storekeeper logistic tariff guid
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTariffsWithCalculationsGet(productId?: string, supplierId?: string, ideaId?: string, filters?: string, limit?: number, offset?: number, noCache?: boolean, activeTariffLogisticsId?: string, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200104>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTariffsWithCalculationsGet(productId, supplierId, ideaId, filters, limit, offset, noCache, activeTariffLogisticsId, sortField, sortType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## NEW! Получить задачу по его id.   
         * @summary # NEW! Получить задачу по его id.
         * @param {string} guid GUID задачи.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTaskLightGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTaskLightGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отметить задачу, как отмененную.  
         * @summary # Отметить задачу, как отмененную..
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksCancelGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksCancelGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отметить задачу, как выполненную.  
         * @summary # Отметить задачу, как выполненную.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject127} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksDoneGuidPost(guid: string, body?: InlineObject127, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksDoneGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить задачу. Здесь только статус.   
         * @summary # Изменить задачу.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject128} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksGuidPatch(guid: string, body?: InlineObject128, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить задачи закрепленные за данным сборщиком.  
         * @summary # Получить задачи закрепленные за данным сборщиком..
         * @param {number} [status] Статус задачи для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksLightMyGet(status?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksLightMyGet(status, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## олучить задачи закрепленные за данным сторкипером с пагинацией  
         * @summary # Получить задачи закрепленные за данным сторкипером с пагинацией
         * @param {number} [status] Статус задачи для фильтра.
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {string} [operationType] Типы задач разделенные запятой
         * @param {string} [priority] Приоритет задачи
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [filters]                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksLightPagMyGet(status?: number, offset?: number, operationType?: string, priority?: string, limit?: number, filters?: string, noCache?: boolean, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200101>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksLightPagMyGet(status, offset, operationType, priority, limit, filters, noCache, sortField, sortType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить вакантные задачи закрепленные за данным сторкипером с пагинацией  
         * @summary # Получить вакантные задачи закрепленные за данным сторкипером с пагинацией
         * @param {number} [status] Статус задачи для фильтра.
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [priority] Приоритет задачи
         * @param {string} [operationType] Типы задач разделенные запятой
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksLightPagVacGet(status?: number, offset?: number, limit?: number, priority?: string, operationType?: string, filters?: string, noCache?: boolean, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200101>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksLightPagVacGet(status, offset, limit, priority, operationType, filters, noCache, sortField, sortType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить задачи не закрепленные за сотрудниками склада.   
         * @summary # Получить задачи не закрепленные за сотрудниками склада.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksLightVacGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksLightVacGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить задачи закрепленные за данным сборщиком.  
         * @summary # Получить задачи закрепленные за данным сборщиком..
         * @param {number} [status] Статус задачи для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksMyGet(status?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20037>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksMyGet(status, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Закрепить задачу за сборщиком.   
         * @summary # Закрепить задачу за сборщиком.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksPickupGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksPickupGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Переврдит все задачи из статуса 0 в статус 10, storekeeper_id должен совпадать с _id юзера
         * @summary # Взять несколько задач сторкипером
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksPickupManyPost(body?: Array<string>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksPickupManyPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить приоритет задачи.   
         * @summary # Изменить приоритет задачи.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject129} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksPriorityGuidPatch(guid: string, body?: InlineObject129, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksPriorityGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить данные из boxesBefore в формате XLSX
         * @summary # Получить данные из boxesBefore в формате XLSX
         * @param {string} guid GUID таски
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksReportGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksReportGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить задачи не закрепленные за сотрудниками склада.   
         * @summary # Deprecated! Получить задачи не закрепленные за сотрудниками склада.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StorekeepersTasksVacGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20037>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StorekeepersTasksVacGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorekeepersApi - factory interface
 * @export
 */
export const StorekeepersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorekeepersApiFp(configuration)
    return {
        /**
         * ## Изменить комментарий коробки сторкипера.   
         * @summary # Изменить комментарий коробки сторкипера.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject132} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersBoxesCommentGuidPatch(guid: string, body?: InlineObject132, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersBoxesCommentGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки и их строки по текущему сторкиперу.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
         * @summary # Получить коробки и их строки по текущему сторкиперу.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersBoxesGet(noCache?: boolean, offset?: number, limit?: number, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1BatchesBoxes>> {
            return localVarFp.apiV1StorekeepersBoxesGet(noCache, offset, limit, sortField, sortType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить коробку сторкипером.   
         * @summary # Изменить коробку сторкипером.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject131} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersBoxesGuidPatch(guid: string, body?: InlineObject131, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersBoxesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать/обновить дестинейшн  Доступно для сторкипера
         * @summary # Создать/обновить дестинейшн
         * @param {InlineObject137} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersDestinationPost(body?: InlineObject137, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.apiV1StorekeepersDestinationPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создается копия партии, коробки получают статус IN_STOCK, слздаются задачи на принятие
         * @summary # Скопировать партию, расформировать, на коробки из партии создать задачи
         * @param {string} guid GUID партии в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersDestructBatchGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersDestructBatchGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить всех сторкиперов(все склады).  если вызвал килен, то показывает сколко коробок у каждого сторкипера пока тут только данные о сторкипере, далее должно быть вся информация о складе, с тарифами  
         * @summary # Получить всех сторкиперов(все склады).
         * @param {boolean} [withoutTariffs] С тарифами
         * @param {string} [boxStatus] Статус коробок,  которые нужно посчитать.
         * @param {number} [tariffType] Тип тарифа(10, 20)
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersGet(withoutTariffs?: boolean, boxStatus?: string, tariffType?: number, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200103>> {
            return localVarFp.apiV1StorekeepersGet(withoutTariffs, boxStatus, tariffType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить значение status  в сущности заказ.   
         * @summary # Изменить значение status в сущности заказ.
         * @param {string} guid GUID ордера, который мы хотим изменить
         * @param {InlineObject130} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersOrdersSetStatusGuidPatch(guid: string, body?: InlineObject130, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersOrdersSetStatusGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки и их строки по текущему сторкиперу с пагинацией.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
         * @summary # Получить коробки и их строки по текущему сторкиперу с пагинацией.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersPagBoxesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200102> {
            return localVarFp.apiV1StorekeepersPagBoxesGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить тариф доставки.  Логическое удаление, isActual = false.         При удалении тарифа доставки все коробки, принадлежащие тарифу, со статусами REQUESTED_SEND_TO_BATCH, IN_BATCH,         переводятся в статус NEED_TO_UPDATE_THE_TARIFF.         Проверки:         Доступно для сторкипера.
         * @summary # Удалить тариф доставки.
         * @param {string} guid GUID тарифа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTariffLogisticsGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать тариф доставки.  Доступно для сторкипера.         у коробок с статусами: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, REQUESTED_SEND_TO_BATCH, IN_BATCH,         при изменении тарифа происходит пересчет стоимостей доставок.         При повышении цены ставиться статус NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, далее нужно ожидать подтверждения от клиента.         Если вернуть цену на старое значение, то статус возвращается к REQUESTED_SEND_TO_BATCH.         При понижении цены автоматом происходит возврат разницы клиенту, статус ставится REQUESTED_SEND_TO_BATCH
         * @summary # Редактировать тариф доставки.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject134} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsGuidPatch(guid: string, body?: InlineObject134, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTariffLogisticsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить всех тарифами доставки сторкипером.   доступно сторкипером  
         * @summary # Получить всех тарифами доставки сторкипером.
         * @param {boolean} [archive] Заархивирован ли тариф
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [tariffType] Тип тарифа(10, 20)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsMyGet(archive?: boolean, noCache?: boolean, tariffType?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AdminsOrdersLogicsTariff>> {
            return localVarFp.apiV1StorekeepersTariffLogisticsMyGet(archive, noCache, tariffType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать тарифами доставки.  
         * @summary # Создать тарифами доставки.
         * @param {InlineObject133} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffLogisticsPost(body?: InlineObject133, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.apiV1StorekeepersTariffLogisticsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить тариф склада.  Доступно для сторкипера
         * @summary # Удалить тариф склада.
         * @param {string} guid GUID тарифа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehouseGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTariffWarehouseGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать тариф услуг склада.  Доступно для сторкипера
         * @summary # Редактировать тариф услуг склада.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject136} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehouseGuidPatch(guid: string, body?: InlineObject136, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTariffWarehouseGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все тарифы сторкипером.   доступно сторкипером  
         * @summary # Получить все тарифы сторкипером.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehouseMyGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1StorekeepersTariffWarehouses>> {
            return localVarFp.apiV1StorekeepersTariffWarehouseMyGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать тариф услуг склада.  
         * @summary # Создать тариф услуг склада.
         * @param {InlineObject135} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffWarehousesPost(body?: InlineObject135, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.apiV1StorekeepersTariffWarehousesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
         * @summary # Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
         * @param {string} [productId] ProductId для расчетов
         * @param {string} [supplierId] SupplierId для расчетов
         * @param {string} [ideaId] IdeaId для расчетов
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Кол-во получаемых записей
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [activeTariffLogisticsId] Active storekeeper logistic tariff guid
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTariffsWithCalculationsGet(productId?: string, supplierId?: string, ideaId?: string, filters?: string, limit?: number, offset?: number, noCache?: boolean, activeTariffLogisticsId?: string, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200104> {
            return localVarFp.apiV1StorekeepersTariffsWithCalculationsGet(productId, supplierId, ideaId, filters, limit, offset, noCache, activeTariffLogisticsId, sortField, sortType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## NEW! Получить задачу по его id.   
         * @summary # NEW! Получить задачу по его id.
         * @param {string} guid GUID задачи.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTaskLightGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1StorekeepersTaskLightGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отметить задачу, как отмененную.  
         * @summary # Отметить задачу, как отмененную..
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksCancelGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTasksCancelGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отметить задачу, как выполненную.  
         * @summary # Отметить задачу, как выполненную.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject127} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksDoneGuidPost(guid: string, body?: InlineObject127, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTasksDoneGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить задачу. Здесь только статус.   
         * @summary # Изменить задачу.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject128} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksGuidPatch(guid: string, body?: InlineObject128, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTasksGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить задачи закрепленные за данным сборщиком.  
         * @summary # Получить задачи закрепленные за данным сборщиком..
         * @param {number} [status] Статус задачи для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightMyGet(status?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.apiV1StorekeepersTasksLightMyGet(status, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## олучить задачи закрепленные за данным сторкипером с пагинацией  
         * @summary # Получить задачи закрепленные за данным сторкипером с пагинацией
         * @param {number} [status] Статус задачи для фильтра.
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {string} [operationType] Типы задач разделенные запятой
         * @param {string} [priority] Приоритет задачи
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [filters]                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightPagMyGet(status?: number, offset?: number, operationType?: string, priority?: string, limit?: number, filters?: string, noCache?: boolean, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200101> {
            return localVarFp.apiV1StorekeepersTasksLightPagMyGet(status, offset, operationType, priority, limit, filters, noCache, sortField, sortType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить вакантные задачи закрепленные за данным сторкипером с пагинацией  
         * @summary # Получить вакантные задачи закрепленные за данным сторкипером с пагинацией
         * @param {number} [status] Статус задачи для фильтра.
         * @param {number} [offset] Отступ от первой записи получаемой в запросе
         * @param {number} [limit] Кол-во получаемых записей
         * @param {string} [priority] Приоритет задачи
         * @param {string} [operationType] Типы задач разделенные запятой
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightPagVacGet(status?: number, offset?: number, limit?: number, priority?: string, operationType?: string, filters?: string, noCache?: boolean, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200101> {
            return localVarFp.apiV1StorekeepersTasksLightPagVacGet(status, offset, limit, priority, operationType, filters, noCache, sortField, sortType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить задачи не закрепленные за сотрудниками склада.   
         * @summary # Получить задачи не закрепленные за сотрудниками склада.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksLightVacGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.apiV1StorekeepersTasksLightVacGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить задачи закрепленные за данным сборщиком.  
         * @summary # Получить задачи закрепленные за данным сборщиком..
         * @param {number} [status] Статус задачи для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksMyGet(status?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20037>> {
            return localVarFp.apiV1StorekeepersTasksMyGet(status, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Закрепить задачу за сборщиком.   
         * @summary # Закрепить задачу за сборщиком.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksPickupGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTasksPickupGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Переврдит все задачи из статуса 0 в статус 10, storekeeper_id должен совпадать с _id юзера
         * @summary # Взять несколько задач сторкипером
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksPickupManyPost(body?: Array<string>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTasksPickupManyPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить приоритет задачи.   
         * @summary # Изменить приоритет задачи.
         * @param {string} guid GUID задачи, которую мы хотим изменить
         * @param {InlineObject129} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksPriorityGuidPatch(guid: string, body?: InlineObject129, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1StorekeepersTasksPriorityGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить данные из boxesBefore в формате XLSX
         * @summary # Получить данные из boxesBefore в формате XLSX
         * @param {string} guid GUID таски
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksReportGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1StorekeepersTasksReportGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить задачи не закрепленные за сотрудниками склада.   
         * @summary # Deprecated! Получить задачи не закрепленные за сотрудниками склада.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StorekeepersTasksVacGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20037>> {
            return localVarFp.apiV1StorekeepersTasksVacGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1StorekeepersBoxesCommentGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatchRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject132}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatch
     */
    readonly body?: InlineObject132

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersBoxesGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersBoxesGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersBoxesGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGet
     */
    readonly noCache?: boolean

    /**
     * Отступ от первой записи получаемой в запросе
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGet
     */
    readonly offset?: number

    /**
     * Кол-во получаемых записей
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGet
     */
    readonly limit?: number

    /**
     * Название поля
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersBoxesGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersBoxesGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersBoxesGuidPatchRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject131}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGuidPatch
     */
    readonly body?: InlineObject131

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersBoxesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersDestinationPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersDestinationPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersDestinationPostRequest {
    /**
     * 
     * @type {InlineObject137}
     * @memberof StorekeepersApiApiV1StorekeepersDestinationPost
     */
    readonly body?: InlineObject137

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersDestinationPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersDestructBatchGuidPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersDestructBatchGuidPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersDestructBatchGuidPostRequest {
    /**
     * GUID партии в БД.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersDestructBatchGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersDestructBatchGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersGetRequest {
    /**
     * С тарифами
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersGet
     */
    readonly withoutTariffs?: boolean

    /**
     * Статус коробок,  которые нужно посчитать.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersGet
     */
    readonly boxStatus?: string

    /**
     * Тип тарифа(10, 20)
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersGet
     */
    readonly tariffType?: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersOrdersSetStatusGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatchRequest {
    /**
     * GUID ордера, который мы хотим изменить
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject130}
     * @memberof StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatch
     */
    readonly body?: InlineObject130

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersPagBoxesGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersPagBoxesGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersPagBoxesGetRequest {
    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersPagBoxesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffLogisticsGuidDelete operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffLogisticsGuidDeleteRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffLogisticsGuidDeleteRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffLogisticsGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatchRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject134}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatch
     */
    readonly body?: InlineObject134

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffLogisticsMyGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffLogisticsMyGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffLogisticsMyGetRequest {
    /**
     * Заархивирован ли тариф
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsMyGet
     */
    readonly archive?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsMyGet
     */
    readonly noCache?: boolean

    /**
     * Тип тарифа(10, 20)
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsMyGet
     */
    readonly tariffType?: number

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffLogisticsPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffLogisticsPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffLogisticsPostRequest {
    /**
     * 
     * @type {InlineObject133}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsPost
     */
    readonly body?: InlineObject133

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffLogisticsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffWarehouseGuidDelete operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffWarehouseGuidDeleteRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffWarehouseGuidDeleteRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehouseGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehouseGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffWarehouseGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatchRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject136}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatch
     */
    readonly body?: InlineObject136

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffWarehouseMyGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffWarehouseMyGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffWarehouseMyGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehouseMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffWarehousesPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffWarehousesPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffWarehousesPostRequest {
    /**
     * 
     * @type {InlineObject135}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehousesPost
     */
    readonly body?: InlineObject135

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffWarehousesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTariffsWithCalculationsGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGetRequest {
    /**
     * ProductId для расчетов
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly productId?: string

    /**
     * SupplierId для расчетов
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly supplierId?: string

    /**
     * IdeaId для расчетов
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly ideaId?: string

    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly filters?: string

    /**
     * Кол-во получаемых записей
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly limit?: number

    /**
     * Отступ от первой записи получаемой в запросе
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly offset?: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly noCache?: boolean

    /**
     * Active storekeeper logistic tariff guid
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly activeTariffLogisticsId?: string

    /**
     * Название поля
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTaskLightGuidGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTaskLightGuidGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTaskLightGuidGetRequest {
    /**
     * GUID задачи.
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTaskLightGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTaskLightGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksCancelGuidPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksCancelGuidPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksCancelGuidPostRequest {
    /**
     * GUID задачи, которую мы хотим изменить
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksCancelGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksCancelGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksDoneGuidPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksDoneGuidPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksDoneGuidPostRequest {
    /**
     * GUID задачи, которую мы хотим изменить
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksDoneGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject127}
     * @memberof StorekeepersApiApiV1StorekeepersTasksDoneGuidPost
     */
    readonly body?: InlineObject127

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksDoneGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksGuidPatchRequest {
    /**
     * GUID задачи, которую мы хотим изменить
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject128}
     * @memberof StorekeepersApiApiV1StorekeepersTasksGuidPatch
     */
    readonly body?: InlineObject128

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksLightMyGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksLightMyGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksLightMyGetRequest {
    /**
     * Статус задачи для фильтра.
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightMyGet
     */
    readonly status?: number

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksLightPagMyGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksLightPagMyGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksLightPagMyGetRequest {
    /**
     * Статус задачи для фильтра.
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly status?: number

    /**
     * Отступ от первой записи получаемой в запросе
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly offset?: number

    /**
     * Типы задач разделенные запятой
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly operationType?: string

    /**
     * Приоритет задачи
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly priority?: string

    /**
     * Кол-во получаемых записей
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly limit?: number

    /**
     *                Возможные поля: isBarCodeAttached, asin, amazonTitle, skuByClient, id, item, trackNumberText, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly filters?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly noCache?: boolean

    /**
     * Название поля
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksLightPagVacGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksLightPagVacGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksLightPagVacGetRequest {
    /**
     * Статус задачи для фильтра.
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly status?: number

    /**
     * Отступ от первой записи получаемой в запросе
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly offset?: number

    /**
     * Кол-во получаемых записей
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly limit?: number

    /**
     * Приоритет задачи
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly priority?: string

    /**
     * Типы задач разделенные запятой
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly operationType?: string

    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, id, item, productId               Поиск для полей продукта идет через схему Партия -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Под humanFriendlyId имеется ввиду humanFriendlyId партии, не коробки               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly filters?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly noCache?: boolean

    /**
     * Название поля
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightPagVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksLightVacGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksLightVacGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksLightVacGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksLightVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksMyGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksMyGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksMyGetRequest {
    /**
     * Статус задачи для фильтра.
     * @type {number}
     * @memberof StorekeepersApiApiV1StorekeepersTasksMyGet
     */
    readonly status?: number

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksPickupGuidPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksPickupGuidPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksPickupGuidPostRequest {
    /**
     * GUID задачи, которую мы хотим изменить
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPickupGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPickupGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksPickupManyPost operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksPickupManyPostRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksPickupManyPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPickupManyPost
     */
    readonly body?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPickupManyPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksPriorityGuidPatch operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatchRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatchRequest {
    /**
     * GUID задачи, которую мы хотим изменить
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject129}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatch
     */
    readonly body?: InlineObject129

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksReportGuidGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksReportGuidGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksReportGuidGetRequest {
    /**
     * GUID таски
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksReportGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksReportGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1StorekeepersTasksVacGet operation in StorekeepersApi.
 * @export
 * @interface StorekeepersApiApiV1StorekeepersTasksVacGetRequest
 */
export interface StorekeepersApiApiV1StorekeepersTasksVacGetRequest {
    /**
     * 
     * @type {string}
     * @memberof StorekeepersApiApiV1StorekeepersTasksVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * StorekeepersApi - object-oriented interface
 * @export
 * @class StorekeepersApi
 * @extends {BaseAPI}
 */
export class StorekeepersApi extends BaseAPI {
    /**
     * ## Изменить комментарий коробки сторкипера.   
     * @summary # Изменить комментарий коробки сторкипера.
     * @param {StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersBoxesCommentGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersBoxesCommentGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersBoxesCommentGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки и их строки по текущему сторкиперу.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
     * @summary # Получить коробки и их строки по текущему сторкиперу.
     * @param {StorekeepersApiApiV1StorekeepersBoxesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersBoxesGet(requestParameters: StorekeepersApiApiV1StorekeepersBoxesGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersBoxesGet(requestParameters.noCache, requestParameters.offset, requestParameters.limit, requestParameters.sortField, requestParameters.sortType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить коробку сторкипером.   
     * @summary # Изменить коробку сторкипером.
     * @param {StorekeepersApiApiV1StorekeepersBoxesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersBoxesGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersBoxesGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersBoxesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать/обновить дестинейшн  Доступно для сторкипера
     * @summary # Создать/обновить дестинейшн
     * @param {StorekeepersApiApiV1StorekeepersDestinationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersDestinationPost(requestParameters: StorekeepersApiApiV1StorekeepersDestinationPostRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersDestinationPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создается копия партии, коробки получают статус IN_STOCK, слздаются задачи на принятие
     * @summary # Скопировать партию, расформировать, на коробки из партии создать задачи
     * @param {StorekeepersApiApiV1StorekeepersDestructBatchGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersDestructBatchGuidPost(requestParameters: StorekeepersApiApiV1StorekeepersDestructBatchGuidPostRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersDestructBatchGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить всех сторкиперов(все склады).  если вызвал килен, то показывает сколко коробок у каждого сторкипера пока тут только данные о сторкипере, далее должно быть вся информация о складе, с тарифами  
     * @summary # Получить всех сторкиперов(все склады).
     * @param {StorekeepersApiApiV1StorekeepersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersGet(requestParameters: StorekeepersApiApiV1StorekeepersGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersGet(requestParameters.withoutTariffs, requestParameters.boxStatus, requestParameters.tariffType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить значение status  в сущности заказ.   
     * @summary # Изменить значение status в сущности заказ.
     * @param {StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersOrdersSetStatusGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersOrdersSetStatusGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersOrdersSetStatusGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки и их строки по текущему сторкиперу с пагинацией.   Отдет все коробки кроме тех которые были в отбывших партии, со статусом: HAS_DISPATCHED  GUID сторкипера получаем из токена.   
     * @summary # Получить коробки и их строки по текущему сторкиперу с пагинацией.
     * @param {StorekeepersApiApiV1StorekeepersPagBoxesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersPagBoxesGet(requestParameters: StorekeepersApiApiV1StorekeepersPagBoxesGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersPagBoxesGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить тариф доставки.  Логическое удаление, isActual = false.         При удалении тарифа доставки все коробки, принадлежащие тарифу, со статусами REQUESTED_SEND_TO_BATCH, IN_BATCH,         переводятся в статус NEED_TO_UPDATE_THE_TARIFF.         Проверки:         Доступно для сторкипера.
     * @summary # Удалить тариф доставки.
     * @param {StorekeepersApiApiV1StorekeepersTariffLogisticsGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffLogisticsGuidDelete(requestParameters: StorekeepersApiApiV1StorekeepersTariffLogisticsGuidDeleteRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffLogisticsGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать тариф доставки.  Доступно для сторкипера.         у коробок с статусами: NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, REQUESTED_SEND_TO_BATCH, IN_BATCH,         при изменении тарифа происходит пересчет стоимостей доставок.         При повышении цены ставиться статус NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE, далее нужно ожидать подтверждения от клиента.         Если вернуть цену на старое значение, то статус возвращается к REQUESTED_SEND_TO_BATCH.         При понижении цены автоматом происходит возврат разницы клиенту, статус ставится REQUESTED_SEND_TO_BATCH
     * @summary # Редактировать тариф доставки.
     * @param {StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffLogisticsGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersTariffLogisticsGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffLogisticsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить всех тарифами доставки сторкипером.   доступно сторкипером  
     * @summary # Получить всех тарифами доставки сторкипером.
     * @param {StorekeepersApiApiV1StorekeepersTariffLogisticsMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffLogisticsMyGet(requestParameters: StorekeepersApiApiV1StorekeepersTariffLogisticsMyGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffLogisticsMyGet(requestParameters.archive, requestParameters.noCache, requestParameters.tariffType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать тарифами доставки.  
     * @summary # Создать тарифами доставки.
     * @param {StorekeepersApiApiV1StorekeepersTariffLogisticsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffLogisticsPost(requestParameters: StorekeepersApiApiV1StorekeepersTariffLogisticsPostRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffLogisticsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить тариф склада.  Доступно для сторкипера
     * @summary # Удалить тариф склада.
     * @param {StorekeepersApiApiV1StorekeepersTariffWarehouseGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffWarehouseGuidDelete(requestParameters: StorekeepersApiApiV1StorekeepersTariffWarehouseGuidDeleteRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffWarehouseGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать тариф услуг склада.  Доступно для сторкипера
     * @summary # Редактировать тариф услуг склада.
     * @param {StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffWarehouseGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersTariffWarehouseGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffWarehouseGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все тарифы сторкипером.   доступно сторкипером  
     * @summary # Получить все тарифы сторкипером.
     * @param {StorekeepersApiApiV1StorekeepersTariffWarehouseMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffWarehouseMyGet(requestParameters: StorekeepersApiApiV1StorekeepersTariffWarehouseMyGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffWarehouseMyGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать тариф услуг склада.  
     * @summary # Создать тариф услуг склада.
     * @param {StorekeepersApiApiV1StorekeepersTariffWarehousesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffWarehousesPost(requestParameters: StorekeepersApiApiV1StorekeepersTariffWarehousesPostRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffWarehousesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
     * @summary # Получить всех сторкиперов(все склады) с пагинацией, расчетными по доставкам
     * @param {StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTariffsWithCalculationsGet(requestParameters: StorekeepersApiApiV1StorekeepersTariffsWithCalculationsGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTariffsWithCalculationsGet(requestParameters.productId, requestParameters.supplierId, requestParameters.ideaId, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.noCache, requestParameters.activeTariffLogisticsId, requestParameters.sortField, requestParameters.sortType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## NEW! Получить задачу по его id.   
     * @summary # NEW! Получить задачу по его id.
     * @param {StorekeepersApiApiV1StorekeepersTaskLightGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTaskLightGuidGet(requestParameters: StorekeepersApiApiV1StorekeepersTaskLightGuidGetRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTaskLightGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отметить задачу, как отмененную.  
     * @summary # Отметить задачу, как отмененную..
     * @param {StorekeepersApiApiV1StorekeepersTasksCancelGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksCancelGuidPost(requestParameters: StorekeepersApiApiV1StorekeepersTasksCancelGuidPostRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksCancelGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отметить задачу, как выполненную.  
     * @summary # Отметить задачу, как выполненную.
     * @param {StorekeepersApiApiV1StorekeepersTasksDoneGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksDoneGuidPost(requestParameters: StorekeepersApiApiV1StorekeepersTasksDoneGuidPostRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksDoneGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить задачу. Здесь только статус.   
     * @summary # Изменить задачу.
     * @param {StorekeepersApiApiV1StorekeepersTasksGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersTasksGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить задачи закрепленные за данным сборщиком.  
     * @summary # Получить задачи закрепленные за данным сборщиком..
     * @param {StorekeepersApiApiV1StorekeepersTasksLightMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksLightMyGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksLightMyGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksLightMyGet(requestParameters.status, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## олучить задачи закрепленные за данным сторкипером с пагинацией  
     * @summary # Получить задачи закрепленные за данным сторкипером с пагинацией
     * @param {StorekeepersApiApiV1StorekeepersTasksLightPagMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksLightPagMyGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksLightPagMyGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksLightPagMyGet(requestParameters.status, requestParameters.offset, requestParameters.operationType, requestParameters.priority, requestParameters.limit, requestParameters.filters, requestParameters.noCache, requestParameters.sortField, requestParameters.sortType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить вакантные задачи закрепленные за данным сторкипером с пагинацией  
     * @summary # Получить вакантные задачи закрепленные за данным сторкипером с пагинацией
     * @param {StorekeepersApiApiV1StorekeepersTasksLightPagVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksLightPagVacGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksLightPagVacGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksLightPagVacGet(requestParameters.status, requestParameters.offset, requestParameters.limit, requestParameters.priority, requestParameters.operationType, requestParameters.filters, requestParameters.noCache, requestParameters.sortField, requestParameters.sortType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить задачи не закрепленные за сотрудниками склада.   
     * @summary # Получить задачи не закрепленные за сотрудниками склада.
     * @param {StorekeepersApiApiV1StorekeepersTasksLightVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksLightVacGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksLightVacGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksLightVacGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить задачи закрепленные за данным сборщиком.  
     * @summary # Получить задачи закрепленные за данным сборщиком..
     * @param {StorekeepersApiApiV1StorekeepersTasksMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksMyGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksMyGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksMyGet(requestParameters.status, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Закрепить задачу за сборщиком.   
     * @summary # Закрепить задачу за сборщиком.
     * @param {StorekeepersApiApiV1StorekeepersTasksPickupGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksPickupGuidPost(requestParameters: StorekeepersApiApiV1StorekeepersTasksPickupGuidPostRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksPickupGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Переврдит все задачи из статуса 0 в статус 10, storekeeper_id должен совпадать с _id юзера
     * @summary # Взять несколько задач сторкипером
     * @param {StorekeepersApiApiV1StorekeepersTasksPickupManyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksPickupManyPost(requestParameters: StorekeepersApiApiV1StorekeepersTasksPickupManyPostRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksPickupManyPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить приоритет задачи.   
     * @summary # Изменить приоритет задачи.
     * @param {StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksPriorityGuidPatch(requestParameters: StorekeepersApiApiV1StorekeepersTasksPriorityGuidPatchRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksPriorityGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить данные из boxesBefore в формате XLSX
     * @summary # Получить данные из boxesBefore в формате XLSX
     * @param {StorekeepersApiApiV1StorekeepersTasksReportGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksReportGuidGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksReportGuidGetRequest, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksReportGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить задачи не закрепленные за сотрудниками склада.   
     * @summary # Deprecated! Получить задачи не закрепленные за сотрудниками склада.
     * @param {StorekeepersApiApiV1StorekeepersTasksVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorekeepersApi
     */
    public apiV1StorekeepersTasksVacGet(requestParameters: StorekeepersApiApiV1StorekeepersTasksVacGetRequest = {}, options?: any) {
        return StorekeepersApiFp(this.configuration).apiV1StorekeepersTasksVacGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
