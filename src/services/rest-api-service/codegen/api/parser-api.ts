/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject156 } from '../models';
// @ts-ignore
import { InlineObject157 } from '../models';
// @ts-ignore
import { InlineObject158 } from '../models';
// @ts-ignore
import { InlineObject159 } from '../models';
// @ts-ignore
import { InlineObject160 } from '../models';
// @ts-ignore
import { InlineObject161 } from '../models';
// @ts-ignore
import { InlineObject162 } from '../models';
// @ts-ignore
import { InlineObject163 } from '../models';
// @ts-ignore
import { InlineObject164 } from '../models';
// @ts-ignore
import { InlineResponse200115 } from '../models';
// @ts-ignore
import { InlineResponse200116 } from '../models';
// @ts-ignore
import { InlineResponse200117 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
// @ts-ignore
import { ParamsGuid } from '../models';
/**
 * ParserApi - axios parameter creator
 * @export
 */
export const ParserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
         * @summary # Принудительный запуск парсеров (Только для админа)
         * @param {string} guid 
         * @param {InlineObject160} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsForceStartPatch: async (guid: string, body?: InlineObject160, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsForceStartPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/force_start`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Подтвердить запрос.
         * @summary # Подтвердить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {InlineObject164} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesApproveGuidPatch: async (guid: string, body?: InlineObject164, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesApproveGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/approve/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Получить все свободные профили.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для Админа)
         * @param {string} guid 
         * @param {InlineObject161} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidPatch: async (guid: string, body?: InlineObject161, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Создать аккаунт(профиль).
         * @param {InlineObject159} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesPost: async (body?: InlineObject159, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить заявки от клиентов на получение профиля.
         * @summary # Получить заявки от клиентов на получение профиля
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/receiving_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отклонить запрос.
         * @summary # Отклонить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesRejectGuidPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesRejectGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/reject/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
         * @param {InlineObject163} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStartPatch: async (body?: InlineObject163, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
         * @param {InlineObject162} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStopPatch: async (body?: InlineObject162, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Сигнал на проверку почты к доступам sellercentral
         * @summary # Сигнал на проверку.
         * @param {InlineObject157} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesCheckPatch: async (body?: InlineObject157, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для клиента)
         * @param {string} guid 
         * @param {InlineObject158} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesGuidPatch: async (guid: string, body?: InlineObject158, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserClientsProfilesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Запрос на получение GoLogin профиля.
         * @summary # Запрос на получение GoLogin профиля.
         * @param {string} guid 
         * @param {InlineObject156} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesReceivingPost: async (guid: string, body?: InlineObject156, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserClientsProfilesReceivingPost', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/receiving`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Посмотреть пароль от профиля.
         * @summary # Посмотреть пароль от профиля.
         * @param {string} profileId Profile guid
         * @param {string} password Hashed password
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserPasswordGet: async (profileId: string, password: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('apiV1IntegrationsParserPasswordGet', 'profileId', profileId)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiV1IntegrationsParserPasswordGet', 'password', password)
            const localVarPath = `/api/v1/integrations/parser/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (profileId !== undefined) {
                localVarQueryParameter['profileId'] = profileId;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParserApi - functional programming interface
 * @export
 */
export const ParserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParserApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
         * @summary # Принудительный запуск парсеров (Только для админа)
         * @param {string} guid 
         * @param {InlineObject160} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsForceStartPatch(guid: string, body?: InlineObject160, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsForceStartPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Подтвердить запрос.
         * @summary # Подтвердить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {InlineObject164} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid: string, body?: InlineObject164, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Получить все свободные профили.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200116>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для Админа)
         * @param {string} guid 
         * @param {InlineObject161} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesGuidPatch(guid: string, body?: InlineObject161, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Создать аккаунт(профиль).
         * @param {InlineObject159} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesPost(body?: InlineObject159, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParamsGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить заявки от клиентов на получение профиля.
         * @summary # Получить заявки от клиентов на получение профиля
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200117>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отклонить запрос.
         * @summary # Отклонить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
         * @param {InlineObject163} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesStartPatch(body?: InlineObject163, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesStartPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
         * @param {InlineObject162} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesStopPatch(body?: InlineObject162, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesStopPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Сигнал на проверку почты к доступам sellercentral
         * @summary # Сигнал на проверку.
         * @param {InlineObject157} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesCheckPatch(body?: InlineObject157, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesCheckPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для клиента)
         * @param {string} guid 
         * @param {InlineObject158} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesGuidPatch(guid: string, body?: InlineObject158, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Запрос на получение GoLogin профиля.
         * @summary # Запрос на получение GoLogin профиля.
         * @param {string} guid 
         * @param {InlineObject156} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesReceivingPost(guid: string, body?: InlineObject156, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParamsGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesReceivingPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Посмотреть пароль от профиля.
         * @summary # Посмотреть пароль от профиля.
         * @param {string} profileId Profile guid
         * @param {string} password Hashed password
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserPasswordGet(profileId: string, password: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200115>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserPasswordGet(profileId, password, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParserApi - factory interface
 * @export
 */
export const ParserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParserApiFp(configuration)
    return {
        /**
         * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
         * @summary # Принудительный запуск парсеров (Только для админа)
         * @param {string} guid 
         * @param {InlineObject160} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsForceStartPatch(guid: string, body?: InlineObject160, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsForceStartPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Подтвердить запрос.
         * @summary # Подтвердить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {InlineObject164} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid: string, body?: InlineObject164, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Получить все свободные профили.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200116>> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для Админа)
         * @param {string} guid 
         * @param {InlineObject161} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidPatch(guid: string, body?: InlineObject161, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Создать аккаунт(профиль).
         * @param {InlineObject159} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesPost(body?: InlineObject159, acceptEncoding?: string, options?: any): AxiosPromise<ParamsGuid> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить заявки от клиентов на получение профиля.
         * @summary # Получить заявки от клиентов на получение профиля
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200117>> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отклонить запрос.
         * @summary # Отклонить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
         * @param {InlineObject163} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStartPatch(body?: InlineObject163, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesStartPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
         * @param {InlineObject162} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStopPatch(body?: InlineObject162, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesStopPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Сигнал на проверку почты к доступам sellercentral
         * @summary # Сигнал на проверку.
         * @param {InlineObject157} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesCheckPatch(body?: InlineObject157, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesCheckPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для клиента)
         * @param {string} guid 
         * @param {InlineObject158} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesGuidPatch(guid: string, body?: InlineObject158, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Запрос на получение GoLogin профиля.
         * @summary # Запрос на получение GoLogin профиля.
         * @param {string} guid 
         * @param {InlineObject156} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesReceivingPost(guid: string, body?: InlineObject156, acceptEncoding?: string, options?: any): AxiosPromise<ParamsGuid> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesReceivingPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Посмотреть пароль от профиля.
         * @summary # Посмотреть пароль от профиля.
         * @param {string} profileId Profile guid
         * @param {string} password Hashed password
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserPasswordGet(profileId: string, password: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200115> {
            return localVarFp.apiV1IntegrationsParserPasswordGet(profileId, password, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1IntegrationsParserAdminsForceStartPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsForceStartPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject160}
     * @memberof ParserApiApiV1IntegrationsParserAdminsForceStartPatch
     */
    readonly body?: InlineObject160

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsForceStartPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesApproveGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject164}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatch
     */
    readonly body?: InlineObject164

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesGet operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject161}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatch
     */
    readonly body?: InlineObject161

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesPost operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest {
    /**
     * 
     * @type {InlineObject159}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesPost
     */
    readonly body?: InlineObject159

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesRejectGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesStartPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest {
    /**
     * 
     * @type {InlineObject163}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStartPatch
     */
    readonly body?: InlineObject163

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStartPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesStopPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest {
    /**
     * 
     * @type {InlineObject162}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStopPatch
     */
    readonly body?: InlineObject162

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStopPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesCheckPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest {
    /**
     * 
     * @type {InlineObject157}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesCheckPatch
     */
    readonly body?: InlineObject157

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesCheckPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject158}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidPatch
     */
    readonly body?: InlineObject158

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesReceivingPost operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesReceivingPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject156}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesReceivingPost
     */
    readonly body?: InlineObject156

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesReceivingPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserPasswordGet operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserPasswordGetRequest
 */
export interface ParserApiApiV1IntegrationsParserPasswordGetRequest {
    /**
     * Profile guid
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserPasswordGet
     */
    readonly profileId: string

    /**
     * Hashed password
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserPasswordGet
     */
    readonly password: string

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserPasswordGet
     */
    readonly acceptEncoding?: string
}

/**
 * ParserApi - object-oriented interface
 * @export
 * @class ParserApi
 * @extends {BaseAPI}
 */
export class ParserApi extends BaseAPI {
    /**
     * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
     * @summary # Принудительный запуск парсеров (Только для админа)
     * @param {ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsForceStartPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsForceStartPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Подтвердить запрос.
     * @summary # Подтвердить запрос клиента на получение профиля.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать аккаунт(профиль).
     * @summary # Получить все свободные профили.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesGet(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Изменить профиль. (Для Админа)
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать аккаунт(профиль).
     * @summary # Создать аккаунт(профиль).
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesPost(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить заявки от клиентов на получение профиля.
     * @summary # Получить заявки от клиентов на получение профиля
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отклонить запрос.
     * @summary # Отклонить запрос клиента на получение профиля.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesStartPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesStartPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesStopPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesStopPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Сигнал на проверку почты к доступам sellercentral
     * @summary # Сигнал на проверку.
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesCheckPatch(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesCheckPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Изменить профиль. (Для клиента)
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Запрос на получение GoLogin профиля.
     * @summary # Запрос на получение GoLogin профиля.
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesReceivingPost(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesReceivingPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Посмотреть пароль от профиля.
     * @summary # Посмотреть пароль от профиля.
     * @param {ParserApiApiV1IntegrationsParserPasswordGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserPasswordGet(requestParameters: ParserApiApiV1IntegrationsParserPasswordGetRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserPasswordGet(requestParameters.profileId, requestParameters.password, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
