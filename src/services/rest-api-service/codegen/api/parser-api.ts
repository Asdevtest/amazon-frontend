/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject157 } from '../models';
// @ts-ignore
import { InlineObject158 } from '../models';
// @ts-ignore
import { InlineObject159 } from '../models';
// @ts-ignore
import { InlineObject160 } from '../models';
// @ts-ignore
import { InlineObject161 } from '../models';
// @ts-ignore
import { InlineObject162 } from '../models';
// @ts-ignore
import { InlineObject163 } from '../models';
// @ts-ignore
import { InlineObject164 } from '../models';
// @ts-ignore
import { InlineObject165 } from '../models';
// @ts-ignore
import { InlineObject166 } from '../models';
// @ts-ignore
import { InlineResponse200117 } from '../models';
// @ts-ignore
import { InlineResponse200118 } from '../models';
// @ts-ignore
import { InlineResponse200119 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
// @ts-ignore
import { ParamsGuid } from '../models';
/**
 * ParserApi - axios parameter creator
 * @export
 */
export const ParserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
         * @summary # Принудительный запуск парсеров (Только для админа)
         * @param {InlineObject161} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsForceStartPatch: async (body?: InlineObject161, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/force_start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Подтвердить запрос.
         * @summary # Подтвердить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {InlineObject165} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesApproveGuidPatch: async (guid: string, body?: InlineObject165, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesApproveGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/approve/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все свободные профили для заявки + reserved profile.
         * @summary # Получить все свободные профили для заявки + reserved profile.
         * @param {string} guid 
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesForRequestGuidGet: async (guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesForRequestGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles_for_request/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Получить все свободные профили.
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить профиль.
         * @summary # Удалить профиль. (Для Админа)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для Админа)
         * @param {string} guid 
         * @param {InlineObject162} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidPatch: async (guid: string, body?: InlineObject162, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить status профиля.
         * @summary # Изменить статус профиля в \"REGISTERED\". (Для Админа)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/{guid}/registered`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Создать аккаунт(профиль).
         * @param {InlineObject160} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesPost: async (body?: InlineObject160, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить заявки от клиентов на получение профиля.
         * @summary # Получить заявки от клиентов на получение профиля
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/receiving_requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отклонить запрос.
         * @summary # Отклонить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesRejectGuidPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserAdminsProfilesRejectGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/reject/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
         * @param {InlineObject164} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStartPatch: async (body?: InlineObject164, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
         * @param {InlineObject163} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStopPatch: async (body?: InlineObject163, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/admins/profiles/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Привязать к товару SKU. Проверки:  Только для клиента  Только магазины клиента
         * @summary # Привязать к товару SKU. (Все таблицы или выброчно)
         * @param {InlineObject166} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProductsLinkSkuPatch: async (body?: InlineObject166, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/clients/products_link_sku`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Сигнал на проверку почты к доступам sellercentral
         * @summary # Сигнал на проверку.
         * @param {InlineObject158} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesCheckPatch: async (body?: InlineObject158, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить status профиля.
         * @summary # Изменить статус профиля в \"INVITED\". (Для Клиента)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesGuidInvitedPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserClientsProfilesGuidInvitedPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/{guid}/invited`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для клиента)
         * @param {string} guid 
         * @param {InlineObject159} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesGuidPatch: async (guid: string, body?: InlineObject159, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1IntegrationsParserClientsProfilesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Запрос на получение GoLogin профиля.
         * @summary # Запрос на получение GoLogin профиля.
         * @param {InlineObject157} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesReceivingPost: async (body?: InlineObject157, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/integrations/parser/clients/profiles/receiving`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParserApi - functional programming interface
 * @export
 */
export const ParserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParserApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
         * @summary # Принудительный запуск парсеров (Только для админа)
         * @param {InlineObject161} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsForceStartPatch(body?: InlineObject161, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsForceStartPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Подтвердить запрос.
         * @summary # Подтвердить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {InlineObject165} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid: string, body?: InlineObject165, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все свободные профили для заявки + reserved profile.
         * @summary # Получить все свободные профили для заявки + reserved profile.
         * @param {string} guid 
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesForRequestGuidGet(guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200118>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesForRequestGuidGet(guid, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Получить все свободные профили.
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200117>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить профиль.
         * @summary # Удалить профиль. (Для Админа)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для Админа)
         * @param {string} guid 
         * @param {InlineObject162} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesGuidPatch(guid: string, body?: InlineObject162, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить status профиля.
         * @summary # Изменить статус профиля в \"REGISTERED\". (Для Админа)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Создать аккаунт(профиль).
         * @param {InlineObject160} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesPost(body?: InlineObject160, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParamsGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить заявки от клиентов на получение профиля.
         * @summary # Получить заявки от клиентов на получение профиля
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200119>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отклонить запрос.
         * @summary # Отклонить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
         * @param {InlineObject164} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesStartPatch(body?: InlineObject164, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesStartPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
         * @param {InlineObject163} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserAdminsProfilesStopPatch(body?: InlineObject163, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserAdminsProfilesStopPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Привязать к товару SKU. Проверки:  Только для клиента  Только магазины клиента
         * @summary # Привязать к товару SKU. (Все таблицы или выброчно)
         * @param {InlineObject166} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProductsLinkSkuPatch(body?: InlineObject166, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProductsLinkSkuPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Сигнал на проверку почты к доступам sellercentral
         * @summary # Сигнал на проверку.
         * @param {InlineObject158} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesCheckPatch(body?: InlineObject158, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesCheckPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить status профиля.
         * @summary # Изменить статус профиля в \"INVITED\". (Для Клиента)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesGuidInvitedPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesGuidInvitedPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для клиента)
         * @param {string} guid 
         * @param {InlineObject159} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesGuidPatch(guid: string, body?: InlineObject159, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Запрос на получение GoLogin профиля.
         * @summary # Запрос на получение GoLogin профиля.
         * @param {InlineObject157} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationsParserClientsProfilesReceivingPost(body?: InlineObject157, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParamsGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1IntegrationsParserClientsProfilesReceivingPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParserApi - factory interface
 * @export
 */
export const ParserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParserApiFp(configuration)
    return {
        /**
         * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
         * @summary # Принудительный запуск парсеров (Только для админа)
         * @param {InlineObject161} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsForceStartPatch(body?: InlineObject161, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsForceStartPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Подтвердить запрос.
         * @summary # Подтвердить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {InlineObject165} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid: string, body?: InlineObject165, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все свободные профили для заявки + reserved profile.
         * @summary # Получить все свободные профили для заявки + reserved profile.
         * @param {string} guid 
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesForRequestGuidGet(guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200118> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesForRequestGuidGet(guid, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Получить все свободные профили.
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200117> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить профиль.
         * @summary # Удалить профиль. (Для Админа)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для Админа)
         * @param {string} guid 
         * @param {InlineObject162} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidPatch(guid: string, body?: InlineObject162, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить status профиля.
         * @summary # Изменить статус профиля в \"REGISTERED\". (Для Админа)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать аккаунт(профиль).
         * @summary # Создать аккаунт(профиль).
         * @param {InlineObject160} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesPost(body?: InlineObject160, acceptEncoding?: string, options?: any): AxiosPromise<ParamsGuid> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить заявки от клиентов на получение профиля.
         * @summary # Получить заявки от клиентов на получение профиля
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200119> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отклонить запрос.
         * @summary # Отклонить запрос клиента на получение профиля.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
         * @param {InlineObject164} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStartPatch(body?: InlineObject164, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesStartPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
         * @param {InlineObject163} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserAdminsProfilesStopPatch(body?: InlineObject163, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserAdminsProfilesStopPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Привязать к товару SKU. Проверки:  Только для клиента  Только магазины клиента
         * @summary # Привязать к товару SKU. (Все таблицы или выброчно)
         * @param {InlineObject166} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProductsLinkSkuPatch(body?: InlineObject166, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserClientsProductsLinkSkuPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Сигнал на проверку почты к доступам sellercentral
         * @summary # Сигнал на проверку.
         * @param {InlineObject158} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesCheckPatch(body?: InlineObject158, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesCheckPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить status профиля.
         * @summary # Изменить статус профиля в \"INVITED\". (Для Клиента)
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesGuidInvitedPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesGuidInvitedPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить профиль.
         * @summary # Изменить профиль. (Для клиента)
         * @param {string} guid 
         * @param {InlineObject159} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesGuidPatch(guid: string, body?: InlineObject159, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Запрос на получение GoLogin профиля.
         * @summary # Запрос на получение GoLogin профиля.
         * @param {InlineObject157} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationsParserClientsProfilesReceivingPost(body?: InlineObject157, acceptEncoding?: string, options?: any): AxiosPromise<ParamsGuid> {
            return localVarFp.apiV1IntegrationsParserClientsProfilesReceivingPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1IntegrationsParserAdminsForceStartPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest {
    /**
     * 
     * @type {InlineObject161}
     * @memberof ParserApiApiV1IntegrationsParserAdminsForceStartPatch
     */
    readonly body?: InlineObject161

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsForceStartPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesApproveGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject165}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatch
     */
    readonly body?: InlineObject165

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesForRequestGuidGet operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGetRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly guid: string

    /**
     *                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesGet operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest {
    /**
     *                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesGuidDelete operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidDeleteRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject162}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatch
     */
    readonly body?: InlineObject162

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidRegisteredPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesGuidRegisteredPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesPost operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest {
    /**
     * 
     * @type {InlineObject160}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesPost
     */
    readonly body?: InlineObject160

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest {
    /**
     *                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesRejectGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesStartPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest {
    /**
     * 
     * @type {InlineObject164}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStartPatch
     */
    readonly body?: InlineObject164

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStartPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserAdminsProfilesStopPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest {
    /**
     * 
     * @type {InlineObject163}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStopPatch
     */
    readonly body?: InlineObject163

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserAdminsProfilesStopPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProductsLinkSkuPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProductsLinkSkuPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProductsLinkSkuPatchRequest {
    /**
     * 
     * @type {InlineObject166}
     * @memberof ParserApiApiV1IntegrationsParserClientsProductsLinkSkuPatch
     */
    readonly body?: InlineObject166

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProductsLinkSkuPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesCheckPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest {
    /**
     * 
     * @type {InlineObject158}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesCheckPatch
     */
    readonly body?: InlineObject158

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesCheckPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesGuidInvitedPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesGuidInvitedPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesGuidInvitedPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidInvitedPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidInvitedPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesGuidPatch operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject159}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidPatch
     */
    readonly body?: InlineObject159

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1IntegrationsParserClientsProfilesReceivingPost operation in ParserApi.
 * @export
 * @interface ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest
 */
export interface ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest {
    /**
     * 
     * @type {InlineObject157}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesReceivingPost
     */
    readonly body?: InlineObject157

    /**
     * 
     * @type {string}
     * @memberof ParserApiApiV1IntegrationsParserClientsProfilesReceivingPost
     */
    readonly acceptEncoding?: string
}

/**
 * ParserApi - object-oriented interface
 * @export
 * @class ParserApi
 * @extends {BaseAPI}
 */
export class ParserApi extends BaseAPI {
    /**
     * ## Принудительный запуск парсеров  У админа есть доступ ко всем профилям
     * @summary # Принудительный запуск парсеров (Только для админа)
     * @param {ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsForceStartPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsForceStartPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsForceStartPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Подтвердить запрос.
     * @summary # Подтвердить запрос клиента на получение профиля.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesApproveGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesApproveGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все свободные профили для заявки + reserved profile.
     * @summary # Получить все свободные профили для заявки + reserved profile.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesForRequestGuidGet(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesForRequestGuidGetRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesForRequestGuidGet(requestParameters.guid, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать аккаунт(профиль).
     * @summary # Получить все свободные профили.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesGet(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesGetRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить профиль.
     * @summary # Удалить профиль. (Для Админа)
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesGuidDelete(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesGuidDeleteRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Изменить профиль. (Для Админа)
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить status профиля.
     * @summary # Изменить статус профиля в \"REGISTERED\". (Для Админа)
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesGuidRegisteredPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesGuidRegisteredPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesGuidRegisteredPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать аккаунт(профиль).
     * @summary # Создать аккаунт(профиль).
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesPost(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesPostRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить заявки от клиентов на получение профиля.
     * @summary # Получить заявки от клиентов на получение профиля
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesReceivingRequestsGetRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesReceivingRequestsGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отклонить запрос.
     * @summary # Отклонить запрос клиента на получение профиля.
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesRejectGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesRejectGuidPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Запустить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то запустит все
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesStartPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesStartPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesStartPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Остановить парсеры (Для Админа)  Принимает массив гуиодов профиля  Если не переданы то остановится все
     * @param {ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserAdminsProfilesStopPatch(requestParameters: ParserApiApiV1IntegrationsParserAdminsProfilesStopPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserAdminsProfilesStopPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Привязать к товару SKU. Проверки:  Только для клиента  Только магазины клиента
     * @summary # Привязать к товару SKU. (Все таблицы или выброчно)
     * @param {ParserApiApiV1IntegrationsParserClientsProductsLinkSkuPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProductsLinkSkuPatch(requestParameters: ParserApiApiV1IntegrationsParserClientsProductsLinkSkuPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProductsLinkSkuPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Сигнал на проверку почты к доступам sellercentral
     * @summary # Сигнал на проверку.
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesCheckPatch(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesCheckPatchRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesCheckPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить status профиля.
     * @summary # Изменить статус профиля в \"INVITED\". (Для Клиента)
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesGuidInvitedPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesGuidInvitedPatch(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesGuidInvitedPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesGuidInvitedPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить профиль.
     * @summary # Изменить профиль. (Для клиента)
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesGuidPatch(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesGuidPatchRequest, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Запрос на получение GoLogin профиля.
     * @summary # Запрос на получение GoLogin профиля.
     * @param {ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParserApi
     */
    public apiV1IntegrationsParserClientsProfilesReceivingPost(requestParameters: ParserApiApiV1IntegrationsParserClientsProfilesReceivingPostRequest = {}, options?: any) {
        return ParserApiFp(this.configuration).apiV1IntegrationsParserClientsProfilesReceivingPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
