/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiV1AdminsGetProductsByStatusRedFlags } from '../models';
// @ts-ignore
import { ApiV1AdminsGetProductsByStatusTags } from '../models';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject4 } from '../models';
// @ts-ignore
import { InlineObject94 } from '../models';
// @ts-ignore
import { InlineObject95 } from '../models';
// @ts-ignore
import { InlineObject96 } from '../models';
// @ts-ignore
import { InlineObject97 } from '../models';
// @ts-ignore
import { InlineObject98 } from '../models';
// @ts-ignore
import { InlineObject99 } from '../models';
// @ts-ignore
import { InlineResponse200 } from '../models';
// @ts-ignore
import { InlineResponse20052 } from '../models';
// @ts-ignore
import { InlineResponse20078 } from '../models';
// @ts-ignore
import { InlineResponse20079 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Добавить магазины к продукту.   
         * @summary Добавить магазины к продукту.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject96} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsAddShopsGuidPost: async (guid: string, body?: InlineObject96, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsAddShopsGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/products/add_shops/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Добавить поставщиков к продукту.   
         * @summary Добавить поставщиков к продукту.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject94} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsAddSuppliersGuidPost: async (guid: string, body?: InlineObject94, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsAddSuppliersGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/products/add_suppliers/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отдает все продукты, созданные определенным пользователем
         * @summary Получение продуктов по ID создателя
         * @param {string} guid ID пользователя
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsByCreatorGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsByCreatorGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/products/by_creator/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Пересчитать поле stockCost в продукте
         * @summary # Пересчитать поле stockCost в продукте
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsCalculateStockCostPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsCalculateStockCostPatch', 'guid', guid)
            const localVarPath = `/api/v1/products/calculate_stock_cost`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактирование поля hsCode в продукте.   Доступно только для Байера, Клиента, Сторкипера
         * @summary # Редактирование поля hsCode в продукте.
         * @param {Array<InlineObject4>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsEditHsCodePatch: async (body?: Array<InlineObject4>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products/edit_hsCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Обновления списка тегов у продукта.
         * @summary # Обновления списка тегов у продукта.
         * @param {string} guid id товара.
         * @param {InlineObject99} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsGuidEditTagsPatch: async (guid: string, body?: InlineObject99, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsGuidEditTagsPatch', 'guid', guid)
            const localVarPath = `/api/v1/products/{guid}/edit_tags`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить товар оп id.   
         * @summary # Получить товар оп id.
         * @param {string} guid id товара.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsGuidGet: async (guid: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/products/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить теги продукта по product GUID
         * @summary # Получить теги продукта по product GUID
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsGuidTagsGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsGuidTagsGet', 'guid', guid)
            const localVarPath = `/api/v1/products/{guid}/tags`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.   
         * @summary # Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsHsCodeGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsHsCodeGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/products/hs_code/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        ## На вход получает xlsx файл, в котором первая колонка заполнена асинами        Фильтруются продукты, критерии фильтра:        Амазон не продает этот товар        Первый продавец продукта сейчас не продает его        Возвращается xlsx файл с его данными из Keepa       
         * @summary # Отфильтровать и получить данные  о продуктах через Keepa
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsKeepaPost: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products/keepa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Поменять/убрать родительский продукт у множества продуктов, можно ставить null
         * @summary # Поменять/убрать родительский продукт у множества продуктов
         * @param {InlineObject98} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsParentPatch: async (body?: InlineObject98, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products/parent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить данные о продукте с сайта Амазон по id(asin)  
         * @summary Получить данные о продукте с сайта Амазон по id(asin)
         * @param {string} id id(asin) для проверки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsParseAmazonIdGet: async (id: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1ProductsParseAmazonIdGet', 'id', id)
            const localVarPath = `/api/v1/products/parse_amazon/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить данные о продукте с SellerCentral  
         * @summary Получить данные о продукте с SellerCentral
         * @param {string} asin ASIN продукта
         * @param {number} [price] Цена продукта.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsParseSellercentralGet: async (asin: string, price?: number, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'asin' is not null or undefined
            assertParamExists('apiV1ProductsParseSellercentralGet', 'asin', asin)
            const localVarPath = `/api/v1/products/parse_sellercentral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (asin !== undefined) {
                localVarQueryParameter['asin'] = asin;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Получить красные флаги       
         * @summary # Получить красные флаги
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsRedFlagsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products/red_flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить магазины из продукта.   
         * @summary Удалить магазины из продукта.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject97} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsRemoveShopsGuidPost: async (guid: string, body?: InlineObject97, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsRemoveShopsGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/products/remove_shops/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить поставщиков из продукта.   
         * @summary Удалить поставщиков из продукта.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject95} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsRemoveSuppliersGuidPost: async (guid: string, body?: InlineObject95, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsRemoveSuppliersGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/products/remove_suppliers/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получить вариации продуктов
         * @summary # Получить вариации продуктов
         * @param {string} guid id товара.
         * @param {boolean} [dataFromInventory] Отдать продукты как в /my_with_pag_v2
         * @param {boolean} [preset] Включить пресеты?
         * @param {boolean} [archive] Отдать архивные продукты
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsVariationsGuidGet: async (guid: string, dataFromInventory?: boolean, preset?: boolean, archive?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1ProductsVariationsGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/products/variations/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataFromInventory !== undefined) {
                localVarQueryParameter['dataFromInventory'] = dataFromInventory;
            }

            if (preset !== undefined) {
                localVarQueryParameter['preset'] = preset;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Добавить магазины к продукту.   
         * @summary Добавить магазины к продукту.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject96} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsAddShopsGuidPost(guid: string, body?: InlineObject96, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsAddShopsGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Добавить поставщиков к продукту.   
         * @summary Добавить поставщиков к продукту.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject94} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsAddSuppliersGuidPost(guid: string, body?: InlineObject94, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsAddSuppliersGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отдает все продукты, созданные определенным пользователем
         * @summary Получение продуктов по ID создателя
         * @param {string} guid ID пользователя
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsByCreatorGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20052>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsByCreatorGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Пересчитать поле stockCost в продукте
         * @summary # Пересчитать поле stockCost в продукте
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsCalculateStockCostPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsCalculateStockCostPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактирование поля hsCode в продукте.   Доступно только для Байера, Клиента, Сторкипера
         * @summary # Редактирование поля hsCode в продукте.
         * @param {Array<InlineObject4>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsEditHsCodePatch(body?: Array<InlineObject4>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsEditHsCodePatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  Обновления списка тегов у продукта.
         * @summary # Обновления списка тегов у продукта.
         * @param {string} guid id товара.
         * @param {InlineObject99} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsGuidEditTagsPatch(guid: string, body?: InlineObject99, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsGuidEditTagsPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить товар оп id.   
         * @summary # Получить товар оп id.
         * @param {string} guid id товара.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsGuidGet(guid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить теги продукта по product GUID
         * @summary # Получить теги продукта по product GUID
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsGuidTagsGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AdminsGetProductsByStatusTags>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsGuidTagsGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.   
         * @summary # Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsHsCodeGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsHsCodeGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        ## На вход получает xlsx файл, в котором первая колонка заполнена асинами        Фильтруются продукты, критерии фильтра:        Амазон не продает этот товар        Первый продавец продукта сейчас не продает его        Возвращается xlsx файл с его данными из Keepa       
         * @summary # Отфильтровать и получить данные  о продуктах через Keepa
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsKeepaPost(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20079>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsKeepaPost(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Поменять/убрать родительский продукт у множества продуктов, можно ставить null
         * @summary # Поменять/убрать родительский продукт у множества продуктов
         * @param {InlineObject98} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsParentPatch(body?: InlineObject98, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsParentPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить данные о продукте с сайта Амазон по id(asin)  
         * @summary Получить данные о продукте с сайта Амазон по id(asin)
         * @param {string} id id(asin) для проверки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsParseAmazonIdGet(id: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsParseAmazonIdGet(id, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить данные о продукте с SellerCentral  
         * @summary Получить данные о продукте с SellerCentral
         * @param {string} asin ASIN продукта
         * @param {number} [price] Цена продукта.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsParseSellercentralGet(asin: string, price?: number, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20078>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsParseSellercentralGet(asin, price, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Получить красные флаги       
         * @summary # Получить красные флаги
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsRedFlagsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AdminsGetProductsByStatusRedFlags>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsRedFlagsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить магазины из продукта.   
         * @summary Удалить магазины из продукта.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject97} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsRemoveShopsGuidPost(guid: string, body?: InlineObject97, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsRemoveShopsGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить поставщиков из продукта.   
         * @summary Удалить поставщиков из продукта.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject95} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsRemoveSuppliersGuidPost(guid: string, body?: InlineObject95, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsRemoveSuppliersGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Получить вариации продуктов
         * @summary # Получить вариации продуктов
         * @param {string} guid id товара.
         * @param {boolean} [dataFromInventory] Отдать продукты как в /my_with_pag_v2
         * @param {boolean} [preset] Включить пресеты?
         * @param {boolean} [archive] Отдать архивные продукты
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProductsVariationsGuidGet(guid: string, dataFromInventory?: boolean, preset?: boolean, archive?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ProductsVariationsGuidGet(guid, dataFromInventory, preset, archive, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * ## Добавить магазины к продукту.   
         * @summary Добавить магазины к продукту.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject96} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsAddShopsGuidPost(guid: string, body?: InlineObject96, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsAddShopsGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Добавить поставщиков к продукту.   
         * @summary Добавить поставщиков к продукту.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject94} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsAddSuppliersGuidPost(guid: string, body?: InlineObject94, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsAddSuppliersGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отдает все продукты, созданные определенным пользователем
         * @summary Получение продуктов по ID создателя
         * @param {string} guid ID пользователя
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsByCreatorGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20052>> {
            return localVarFp.apiV1ProductsByCreatorGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Пересчитать поле stockCost в продукте
         * @summary # Пересчитать поле stockCost в продукте
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsCalculateStockCostPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsCalculateStockCostPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактирование поля hsCode в продукте.   Доступно только для Байера, Клиента, Сторкипера
         * @summary # Редактирование поля hsCode в продукте.
         * @param {Array<InlineObject4>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsEditHsCodePatch(body?: Array<InlineObject4>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsEditHsCodePatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *  Обновления списка тегов у продукта.
         * @summary # Обновления списка тегов у продукта.
         * @param {string} guid id товара.
         * @param {InlineObject99} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsGuidEditTagsPatch(guid: string, body?: InlineObject99, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsGuidEditTagsPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить товар оп id.   
         * @summary # Получить товар оп id.
         * @param {string} guid id товара.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.apiV1ProductsGuidGet(guid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить теги продукта по product GUID
         * @summary # Получить теги продукта по product GUID
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsGuidTagsGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AdminsGetProductsByStatusTags>> {
            return localVarFp.apiV1ProductsGuidTagsGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.   
         * @summary # Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.
         * @param {string} guid id товара.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsHsCodeGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1ProductsHsCodeGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *        ## На вход получает xlsx файл, в котором первая колонка заполнена асинами        Фильтруются продукты, критерии фильтра:        Амазон не продает этот товар        Первый продавец продукта сейчас не продает его        Возвращается xlsx файл с его данными из Keepa       
         * @summary # Отфильтровать и получить данные  о продуктах через Keepa
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsKeepaPost(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20079>> {
            return localVarFp.apiV1ProductsKeepaPost(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Поменять/убрать родительский продукт у множества продуктов, можно ставить null
         * @summary # Поменять/убрать родительский продукт у множества продуктов
         * @param {InlineObject98} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsParentPatch(body?: InlineObject98, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsParentPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить данные о продукте с сайта Амазон по id(asin)  
         * @summary Получить данные о продукте с сайта Амазон по id(asin)
         * @param {string} id id(asin) для проверки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsParseAmazonIdGet(id: string, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1ProductsParseAmazonIdGet(id, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить данные о продукте с SellerCentral  
         * @summary Получить данные о продукте с SellerCentral
         * @param {string} asin ASIN продукта
         * @param {number} [price] Цена продукта.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsParseSellercentralGet(asin: string, price?: number, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20078> {
            return localVarFp.apiV1ProductsParseSellercentralGet(asin, price, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *        Получить красные флаги       
         * @summary # Получить красные флаги
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsRedFlagsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AdminsGetProductsByStatusRedFlags>> {
            return localVarFp.apiV1ProductsRedFlagsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить магазины из продукта.   
         * @summary Удалить магазины из продукта.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject97} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsRemoveShopsGuidPost(guid: string, body?: InlineObject97, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsRemoveShopsGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить поставщиков из продукта.   
         * @summary Удалить поставщиков из продукта.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject95} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsRemoveSuppliersGuidPost(guid: string, body?: InlineObject95, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1ProductsRemoveSuppliersGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Получить вариации продуктов
         * @summary # Получить вариации продуктов
         * @param {string} guid id товара.
         * @param {boolean} [dataFromInventory] Отдать продукты как в /my_with_pag_v2
         * @param {boolean} [preset] Включить пресеты?
         * @param {boolean} [archive] Отдать архивные продукты
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProductsVariationsGuidGet(guid: string, dataFromInventory?: boolean, preset?: boolean, archive?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1ProductsVariationsGuidGet(guid, dataFromInventory, preset, archive, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1ProductsAddShopsGuidPost operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsAddShopsGuidPostRequest
 */
export interface ProductApiApiV1ProductsAddShopsGuidPostRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof ProductApiApiV1ProductsAddShopsGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject96}
     * @memberof ProductApiApiV1ProductsAddShopsGuidPost
     */
    readonly body?: InlineObject96

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsAddShopsGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsAddSuppliersGuidPost operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsAddSuppliersGuidPostRequest
 */
export interface ProductApiApiV1ProductsAddSuppliersGuidPostRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof ProductApiApiV1ProductsAddSuppliersGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject94}
     * @memberof ProductApiApiV1ProductsAddSuppliersGuidPost
     */
    readonly body?: InlineObject94

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsAddSuppliersGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsByCreatorGuidGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsByCreatorGuidGetRequest
 */
export interface ProductApiApiV1ProductsByCreatorGuidGetRequest {
    /**
     * ID пользователя
     * @type {string}
     * @memberof ProductApiApiV1ProductsByCreatorGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsByCreatorGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsCalculateStockCostPatch operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsCalculateStockCostPatchRequest
 */
export interface ProductApiApiV1ProductsCalculateStockCostPatchRequest {
    /**
     * id товара.
     * @type {string}
     * @memberof ProductApiApiV1ProductsCalculateStockCostPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsCalculateStockCostPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsEditHsCodePatch operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsEditHsCodePatchRequest
 */
export interface ProductApiApiV1ProductsEditHsCodePatchRequest {
    /**
     * 
     * @type {Array<InlineObject4>}
     * @memberof ProductApiApiV1ProductsEditHsCodePatch
     */
    readonly body?: Array<InlineObject4>

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsEditHsCodePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsGuidEditTagsPatch operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsGuidEditTagsPatchRequest
 */
export interface ProductApiApiV1ProductsGuidEditTagsPatchRequest {
    /**
     * id товара.
     * @type {string}
     * @memberof ProductApiApiV1ProductsGuidEditTagsPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject99}
     * @memberof ProductApiApiV1ProductsGuidEditTagsPatch
     */
    readonly body?: InlineObject99

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsGuidEditTagsPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsGuidGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsGuidGetRequest
 */
export interface ProductApiApiV1ProductsGuidGetRequest {
    /**
     * id товара.
     * @type {string}
     * @memberof ProductApiApiV1ProductsGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ProductApiApiV1ProductsGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsGuidTagsGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsGuidTagsGetRequest
 */
export interface ProductApiApiV1ProductsGuidTagsGetRequest {
    /**
     * id товара.
     * @type {string}
     * @memberof ProductApiApiV1ProductsGuidTagsGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsGuidTagsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsHsCodeGuidGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsHsCodeGuidGetRequest
 */
export interface ProductApiApiV1ProductsHsCodeGuidGetRequest {
    /**
     * id товара.
     * @type {string}
     * @memberof ProductApiApiV1ProductsHsCodeGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsHsCodeGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsKeepaPost operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsKeepaPostRequest
 */
export interface ProductApiApiV1ProductsKeepaPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsKeepaPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsParentPatch operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsParentPatchRequest
 */
export interface ProductApiApiV1ProductsParentPatchRequest {
    /**
     * 
     * @type {InlineObject98}
     * @memberof ProductApiApiV1ProductsParentPatch
     */
    readonly body?: InlineObject98

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsParentPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsParseAmazonIdGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsParseAmazonIdGetRequest
 */
export interface ProductApiApiV1ProductsParseAmazonIdGetRequest {
    /**
     * id(asin) для проверки
     * @type {string}
     * @memberof ProductApiApiV1ProductsParseAmazonIdGet
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsParseAmazonIdGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsParseSellercentralGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsParseSellercentralGetRequest
 */
export interface ProductApiApiV1ProductsParseSellercentralGetRequest {
    /**
     * ASIN продукта
     * @type {string}
     * @memberof ProductApiApiV1ProductsParseSellercentralGet
     */
    readonly asin: string

    /**
     * Цена продукта.
     * @type {number}
     * @memberof ProductApiApiV1ProductsParseSellercentralGet
     */
    readonly price?: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof ProductApiApiV1ProductsParseSellercentralGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsParseSellercentralGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsRedFlagsGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsRedFlagsGetRequest
 */
export interface ProductApiApiV1ProductsRedFlagsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsRedFlagsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsRemoveShopsGuidPost operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsRemoveShopsGuidPostRequest
 */
export interface ProductApiApiV1ProductsRemoveShopsGuidPostRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof ProductApiApiV1ProductsRemoveShopsGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject97}
     * @memberof ProductApiApiV1ProductsRemoveShopsGuidPost
     */
    readonly body?: InlineObject97

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsRemoveShopsGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsRemoveSuppliersGuidPost operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsRemoveSuppliersGuidPostRequest
 */
export interface ProductApiApiV1ProductsRemoveSuppliersGuidPostRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof ProductApiApiV1ProductsRemoveSuppliersGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject95}
     * @memberof ProductApiApiV1ProductsRemoveSuppliersGuidPost
     */
    readonly body?: InlineObject95

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsRemoveSuppliersGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1ProductsVariationsGuidGet operation in ProductApi.
 * @export
 * @interface ProductApiApiV1ProductsVariationsGuidGetRequest
 */
export interface ProductApiApiV1ProductsVariationsGuidGetRequest {
    /**
     * id товара.
     * @type {string}
     * @memberof ProductApiApiV1ProductsVariationsGuidGet
     */
    readonly guid: string

    /**
     * Отдать продукты как в /my_with_pag_v2
     * @type {boolean}
     * @memberof ProductApiApiV1ProductsVariationsGuidGet
     */
    readonly dataFromInventory?: boolean

    /**
     * Включить пресеты?
     * @type {boolean}
     * @memberof ProductApiApiV1ProductsVariationsGuidGet
     */
    readonly preset?: boolean

    /**
     * Отдать архивные продукты
     * @type {boolean}
     * @memberof ProductApiApiV1ProductsVariationsGuidGet
     */
    readonly archive?: boolean

    /**
     * 
     * @type {string}
     * @memberof ProductApiApiV1ProductsVariationsGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * ## Добавить магазины к продукту.   
     * @summary Добавить магазины к продукту.
     * @param {ProductApiApiV1ProductsAddShopsGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsAddShopsGuidPost(requestParameters: ProductApiApiV1ProductsAddShopsGuidPostRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsAddShopsGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Добавить поставщиков к продукту.   
     * @summary Добавить поставщиков к продукту.
     * @param {ProductApiApiV1ProductsAddSuppliersGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsAddSuppliersGuidPost(requestParameters: ProductApiApiV1ProductsAddSuppliersGuidPostRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsAddSuppliersGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отдает все продукты, созданные определенным пользователем
     * @summary Получение продуктов по ID создателя
     * @param {ProductApiApiV1ProductsByCreatorGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsByCreatorGuidGet(requestParameters: ProductApiApiV1ProductsByCreatorGuidGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsByCreatorGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Пересчитать поле stockCost в продукте
     * @summary # Пересчитать поле stockCost в продукте
     * @param {ProductApiApiV1ProductsCalculateStockCostPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsCalculateStockCostPatch(requestParameters: ProductApiApiV1ProductsCalculateStockCostPatchRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsCalculateStockCostPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактирование поля hsCode в продукте.   Доступно только для Байера, Клиента, Сторкипера
     * @summary # Редактирование поля hsCode в продукте.
     * @param {ProductApiApiV1ProductsEditHsCodePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsEditHsCodePatch(requestParameters: ProductApiApiV1ProductsEditHsCodePatchRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsEditHsCodePatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Обновления списка тегов у продукта.
     * @summary # Обновления списка тегов у продукта.
     * @param {ProductApiApiV1ProductsGuidEditTagsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsGuidEditTagsPatch(requestParameters: ProductApiApiV1ProductsGuidEditTagsPatchRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsGuidEditTagsPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить товар оп id.   
     * @summary # Получить товар оп id.
     * @param {ProductApiApiV1ProductsGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsGuidGet(requestParameters: ProductApiApiV1ProductsGuidGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить теги продукта по product GUID
     * @summary # Получить теги продукта по product GUID
     * @param {ProductApiApiV1ProductsGuidTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsGuidTagsGet(requestParameters: ProductApiApiV1ProductsGuidTagsGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsGuidTagsGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.   
     * @summary # Получить  “chinaTitle“, “material“ , “productUsage“, “hsCode“ по id.
     * @param {ProductApiApiV1ProductsHsCodeGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsHsCodeGuidGet(requestParameters: ProductApiApiV1ProductsHsCodeGuidGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsHsCodeGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        ## На вход получает xlsx файл, в котором первая колонка заполнена асинами        Фильтруются продукты, критерии фильтра:        Амазон не продает этот товар        Первый продавец продукта сейчас не продает его        Возвращается xlsx файл с его данными из Keepa       
     * @summary # Отфильтровать и получить данные  о продуктах через Keepa
     * @param {ProductApiApiV1ProductsKeepaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsKeepaPost(requestParameters: ProductApiApiV1ProductsKeepaPostRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsKeepaPost(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Поменять/убрать родительский продукт у множества продуктов, можно ставить null
     * @summary # Поменять/убрать родительский продукт у множества продуктов
     * @param {ProductApiApiV1ProductsParentPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsParentPatch(requestParameters: ProductApiApiV1ProductsParentPatchRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsParentPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить данные о продукте с сайта Амазон по id(asin)  
     * @summary Получить данные о продукте с сайта Амазон по id(asin)
     * @param {ProductApiApiV1ProductsParseAmazonIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsParseAmazonIdGet(requestParameters: ProductApiApiV1ProductsParseAmazonIdGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsParseAmazonIdGet(requestParameters.id, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить данные о продукте с SellerCentral  
     * @summary Получить данные о продукте с SellerCentral
     * @param {ProductApiApiV1ProductsParseSellercentralGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsParseSellercentralGet(requestParameters: ProductApiApiV1ProductsParseSellercentralGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsParseSellercentralGet(requestParameters.asin, requestParameters.price, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Получить красные флаги       
     * @summary # Получить красные флаги
     * @param {ProductApiApiV1ProductsRedFlagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsRedFlagsGet(requestParameters: ProductApiApiV1ProductsRedFlagsGetRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsRedFlagsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить магазины из продукта.   
     * @summary Удалить магазины из продукта.
     * @param {ProductApiApiV1ProductsRemoveShopsGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsRemoveShopsGuidPost(requestParameters: ProductApiApiV1ProductsRemoveShopsGuidPostRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsRemoveShopsGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить поставщиков из продукта.   
     * @summary Удалить поставщиков из продукта.
     * @param {ProductApiApiV1ProductsRemoveSuppliersGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsRemoveSuppliersGuidPost(requestParameters: ProductApiApiV1ProductsRemoveSuppliersGuidPostRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsRemoveSuppliersGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получить вариации продуктов
     * @summary # Получить вариации продуктов
     * @param {ProductApiApiV1ProductsVariationsGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public apiV1ProductsVariationsGuidGet(requestParameters: ProductApiApiV1ProductsVariationsGuidGetRequest, options?: any) {
        return ProductApiFp(this.configuration).apiV1ProductsVariationsGuidGet(requestParameters.guid, requestParameters.dataFromInventory, requestParameters.preset, requestParameters.archive, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
