/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject63 } from '../models';
// @ts-ignore
import { InlineObject64 } from '../models';
// @ts-ignore
import { InlineObject65 } from '../models';
// @ts-ignore
import { InlineObject66 } from '../models';
// @ts-ignore
import { InlineObject67 } from '../models';
// @ts-ignore
import { InlineObject68 } from '../models';
// @ts-ignore
import { InlineObject69 } from '../models';
// @ts-ignore
import { InlineObject70 } from '../models';
// @ts-ignore
import { InlineResponse2001 } from '../models';
// @ts-ignore
import { InlineResponse20045 } from '../models';
// @ts-ignore
import { InlineResponse20046 } from '../models';
// @ts-ignore
import { InlineResponse20047 } from '../models';
// @ts-ignore
import { InlineResponse20048 } from '../models';
// @ts-ignore
import { InlineResponse20049 } from '../models';
// @ts-ignore
import { InlineResponse20050 } from '../models';
// @ts-ignore
import { InlineResponse20051 } from '../models';
// @ts-ignore
import { InlineResponse20052 } from '../models';
// @ts-ignore
import { InlineResponse2015 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * BuyerApi - axios parameter creator
 * @export
 */
export const BuyerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Переместить заказ в статус atProcess
         * @summary # Переместить заказ в статус atProcess
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersAtProcessGuidPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersAtProcessGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/at_process/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать номер заказа
         * @summary # Редактировать номер заказа.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} item 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidEditItemItemPatch: async (guid: string, item: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidEditItemItemPatch', 'guid', guid)
            // verify required parameter 'item' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidEditItemItemPatch', 'item', item)
            const localVarPath = `/api/v1/buyers/orders/{guid}/edit_item/{item}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать заказ.   Данный метод позволяет редактировать все поля кроме status и totalPriceChanged Проверки:  Пока нет проверок
         * @summary # Редактировать заказ.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject68} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidEditPatch: async (guid: string, body?: InlineObject68, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidEditPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/{guid}/edit`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить конкретный заказ по его GUID.   
         * @summary # Получить конкретный заказ по его GUID.
         * @param {string} guid GUID заказа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Выставить статус оплачено поставщику.  При вызове данного метода статус меняется на 20 paid  Снимает средства с замороженных средств клиента и переводятся админу Проверки:  Нельзя повторно оплачивать поставщику. paidAt !== null
         * @summary # Выставить статус оплачено поставщику.
         * @param {string} guid GUID заказа
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidPayToSupplierPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidPayToSupplierPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/{guid}/pay_to_supplier`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.   При вызове данного метода ставиться статус cancelByBuyer: 35 Средства обратно возвращаются на баланс клиента.  (если оплатили посташику то от баланса админа клиенту, если не было оплаты поставщику, то разморозка средств клиента)  Проверки:  Требуется комментарий байера. Нельзя вернуть заказ если заказ закрыт клиентом
         * @summary # Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.
         * @param {string} guid GUID заказа.
         * @param {InlineObject66} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidReturnOrderPatch: async (guid: string, body?: InlineObject66, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidReturnOrderPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/{guid}/return_order`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Задать изменение итоговой цены, totalPriceChanged.   При повышении цены ставиться статус 19 needConfirmingToPriceChange, далее нужно ожидать подтверждения от клиента.  Если вернуть цену на старое значение, то статус возвращается к 15 atProcess. При понижении цены автоматом происходит возврат разницы клиенту, статус ставится 15 atProcess.  Проверки:  Нельзя менять цену после оплаты поставщику. paidAt !== null
         * @summary # Задать изменение итоговой цены, totalPriceChanged.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject67} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidSetTotalPriceChangedPatch: async (guid: string, body?: InlineObject67, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidSetTotalPriceChangedPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/{guid}/set_totalPriceChanged`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Выставить статус \"выдан трек номер\".  При вызове данного метода статус меняется на 25 trackNumberIssued  Если ранее не была произведена оплата(paidAt === null), то производит оплату:   при оплате снимает средства с замороженных средств клиента и переводит админу Проверки:  пока нет проверок
         * @summary # Выставить статус \"выдан трек номер\".
         * @param {string} guid GUID заказа
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidTrackNumberIssuedPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersGuidTrackNumberIssuedPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/{guid}/track_number_issued`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список заказов текущего байера.   
         * @summary # Получить список заказов текущего байера.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersMyGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/orders/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список заказов текущего байера с пагинацией.   
         * @summary # Получить список заказов текущего байера с пагинацией.
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [status] Статусы заказов, по которым идет фильтрация, разделенные запятыми
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPagMyGet: async (filters?: string, status?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/orders/pag/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Переместить заказ в статус partiallyPaid
         * @summary # Переместить заказ в статус partiallyPaid
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPartiallyPaidGuidPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersPartiallyPaidGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/partially_paid/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить общую стоимость заказов по статусам
         * @summary # Получить общую стоимость заказов по статусам
         * @param {string} status Order status
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPaymentAmountGet: async (status: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('apiV1BuyersOrdersPaymentAmountGet', 'status', status)
            const localVarPath = `/api/v1/buyers/orders/payment_amount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменить реквезиты ордера
         * @summary # Изменить реквезиты ордера
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject65} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPaymentGuidPatch: async (guid: string, body?: InlineObject65, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersPaymentGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/payment/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Закрепить заказ за байером. Взять его в работу.  ##  На основании заказа НУЖНО СФОРМИРОВАТЬ коробки по кол-ву товаров в заказе.   ## Эндпоинт НЕ ВЕРНЕТ сформированные коробки что бы не плодить МАГИЮ или ГЛЮКИ.   ## Запросите закрепление заказа. Если операция пройдет успешно 204 - запросите создание коробки.   ## Следующим этапом сделаем возможность закреплять пачку заказов и пачку коробок готовить одним запросом. Но потом.   ## Текущая база не поддерживает транзакции.   
         * @summary # Закрепить заказ за байером. Взять его в работу.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPickupGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersPickupGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/pickup/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Переместить заказ в статус readyForPayment
         * @summary # Переместить заказ в статус readyForPayment
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject64} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersReadyForPaymentGuidPatch: async (guid: string, body?: InlineObject64, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersReadyForPaymentGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/ready_for_payment/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать номер заказа на inStock (30)
         * @summary # Редактировать номер заказа на inStock (30).
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject70} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersSetInStockGuidPatch: async (guid: string, body?: InlineObject70, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersOrdersSetInStockGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/orders/set_in_stock/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список свободных заказов.   
         * @summary # Получить список свободных заказов. (DEPRECATED)
         * @param {'deadline'} [sortField] Поле, по которому сортировать запрос
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersVacGet: async (sortField?: 'deadline', sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/orders/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список свободных заказов.   
         * @summary # Получить список свободных заказов. (PAGINATED)
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Поле, по которому сортировать запрос
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersVacPagGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/orders/vac/pag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в продукт.  ## Байер может редактировать только товары со статусом: 35, 40, 50, 60, 235, 240, 250, 260.   
         * @summary # Внести изменения в продукт.
         * @param {string} guid GUID продукта, который планируем изменить
         * @param {InlineObject63} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsGuidPatch: async (guid: string, body?: InlineObject63, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersProductsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/buyers/products/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров, где пользователь - баер товара(не архив).
         * @summary # Получить список товаров, где пользователь - баер товара(не архив).
         * @param {boolean} [isCreatedByClient] Если true отдает товары созданные клиентом.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsLightGet: async (isCreatedByClient?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/products/light`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isCreatedByClient !== undefined) {
                localVarQueryParameter['isCreatedByClient'] = isCreatedByClient;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров взятых в работу байером.   
         * @summary # Получить список товаров взятых в работу байером.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsMyGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/products/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров взятых в работу байером с пагинацией.   
         * @summary # Получить список товаров взятых в работу байером с пагинацией.
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsPagMyGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/products/pag/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Закрепить продукт за байером. Взять его в работу.  
         * @param {string} guid GUID продукта, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsPickupGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersProductsPickupGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/buyers/products/pickup/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список вакантных товаров.   ## Товары со статусом 30 у которых не заполнен buyer   
         * @summary # Получить список вакантных товаров.
         * @param {boolean} [isCreatedByClient] Если true отдает товары созданные клиентом.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsVacGet: async (isCreatedByClient?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/products/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isCreatedByClient !== undefined) {
                localVarQueryParameter['isCreatedByClient'] = isCreatedByClient;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отменить задачу. Выставляет задаче статус 30.  
         * @summary # Отменить задачу.
         * @param {string} guid guid отменяемой задачи
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersTasksCancelGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BuyersTasksCancelGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/buyers/tasks/cancel/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Показать все задачи данного пользователя.   
         * @summary # Показать все задачи данного пользователя.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersTasksGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать задачу.   Проверки: Все коробки должны быть от одного сторкипера. Все коробки должны быть от одного клиента.
         * @summary # Создать задачу.
         * @param {InlineObject69} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersTasksPost: async (body?: InlineObject69, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/buyers/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuyerApi - functional programming interface
 * @export
 */
export const BuyerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuyerApiAxiosParamCreator(configuration)
    return {
        /**
         * Переместить заказ в статус atProcess
         * @summary # Переместить заказ в статус atProcess
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersAtProcessGuidPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersAtProcessGuidPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать номер заказа
         * @summary # Редактировать номер заказа.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} item 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidEditItemItemPatch(guid: string, item: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidEditItemItemPatch(guid, item, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать заказ.   Данный метод позволяет редактировать все поля кроме status и totalPriceChanged Проверки:  Пока нет проверок
         * @summary # Редактировать заказ.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject68} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidEditPatch(guid: string, body?: InlineObject68, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidEditPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить конкретный заказ по его GUID.   
         * @summary # Получить конкретный заказ по его GUID.
         * @param {string} guid GUID заказа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Выставить статус оплачено поставщику.  При вызове данного метода статус меняется на 20 paid  Снимает средства с замороженных средств клиента и переводятся админу Проверки:  Нельзя повторно оплачивать поставщику. paidAt !== null
         * @summary # Выставить статус оплачено поставщику.
         * @param {string} guid GUID заказа
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidPayToSupplierPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidPayToSupplierPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.   При вызове данного метода ставиться статус cancelByBuyer: 35 Средства обратно возвращаются на баланс клиента.  (если оплатили посташику то от баланса админа клиенту, если не было оплаты поставщику, то разморозка средств клиента)  Проверки:  Требуется комментарий байера. Нельзя вернуть заказ если заказ закрыт клиентом
         * @summary # Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.
         * @param {string} guid GUID заказа.
         * @param {InlineObject66} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidReturnOrderPatch(guid: string, body?: InlineObject66, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidReturnOrderPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Задать изменение итоговой цены, totalPriceChanged.   При повышении цены ставиться статус 19 needConfirmingToPriceChange, далее нужно ожидать подтверждения от клиента.  Если вернуть цену на старое значение, то статус возвращается к 15 atProcess. При понижении цены автоматом происходит возврат разницы клиенту, статус ставится 15 atProcess.  Проверки:  Нельзя менять цену после оплаты поставщику. paidAt !== null
         * @summary # Задать изменение итоговой цены, totalPriceChanged.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject67} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidSetTotalPriceChangedPatch(guid: string, body?: InlineObject67, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidSetTotalPriceChangedPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Выставить статус \"выдан трек номер\".  При вызове данного метода статус меняется на 25 trackNumberIssued  Если ранее не была произведена оплата(paidAt === null), то производит оплату:   при оплате снимает средства с замороженных средств клиента и переводит админу Проверки:  пока нет проверок
         * @summary # Выставить статус \"выдан трек номер\".
         * @param {string} guid GUID заказа
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersGuidTrackNumberIssuedPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersGuidTrackNumberIssuedPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список заказов текущего байера.   
         * @summary # Получить список заказов текущего байера.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersMyGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20050>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersMyGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список заказов текущего байера с пагинацией.   
         * @summary # Получить список заказов текущего байера с пагинацией.
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [status] Статусы заказов, по которым идет фильтрация, разделенные запятыми
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersPagMyGet(filters?: string, status?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersPagMyGet(filters, status, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Переместить заказ в статус partiallyPaid
         * @summary # Переместить заказ в статус partiallyPaid
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersPartiallyPaidGuidPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersPartiallyPaidGuidPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить общую стоимость заказов по статусам
         * @summary # Получить общую стоимость заказов по статусам
         * @param {string} status Order status
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersPaymentAmountGet(status: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersPaymentAmountGet(status, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Изменить реквезиты ордера
         * @summary # Изменить реквезиты ордера
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject65} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersPaymentGuidPatch(guid: string, body?: InlineObject65, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersPaymentGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Закрепить заказ за байером. Взять его в работу.  ##  На основании заказа НУЖНО СФОРМИРОВАТЬ коробки по кол-ву товаров в заказе.   ## Эндпоинт НЕ ВЕРНЕТ сформированные коробки что бы не плодить МАГИЮ или ГЛЮКИ.   ## Запросите закрепление заказа. Если операция пройдет успешно 204 - запросите создание коробки.   ## Следующим этапом сделаем возможность закреплять пачку заказов и пачку коробок готовить одним запросом. Но потом.   ## Текущая база не поддерживает транзакции.   
         * @summary # Закрепить заказ за байером. Взять его в работу.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersPickupGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersPickupGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Переместить заказ в статус readyForPayment
         * @summary # Переместить заказ в статус readyForPayment
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject64} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersReadyForPaymentGuidPatch(guid: string, body?: InlineObject64, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersReadyForPaymentGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать номер заказа на inStock (30)
         * @summary # Редактировать номер заказа на inStock (30).
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject70} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersSetInStockGuidPatch(guid: string, body?: InlineObject70, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersSetInStockGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список свободных заказов.   
         * @summary # Получить список свободных заказов. (DEPRECATED)
         * @param {'deadline'} [sortField] Поле, по которому сортировать запрос
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersVacGet(sortField?: 'deadline', sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersVacGet(sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список свободных заказов.   
         * @summary # Получить список свободных заказов. (PAGINATED)
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Поле, по которому сортировать запрос
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersOrdersVacPagGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersOrdersVacPagGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в продукт.  ## Байер может редактировать только товары со статусом: 35, 40, 50, 60, 235, 240, 250, 260.   
         * @summary # Внести изменения в продукт.
         * @param {string} guid GUID продукта, который планируем изменить
         * @param {InlineObject63} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersProductsGuidPatch(guid: string, body?: InlineObject63, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersProductsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров, где пользователь - баер товара(не архив).
         * @summary # Получить список товаров, где пользователь - баер товара(не архив).
         * @param {boolean} [isCreatedByClient] Если true отдает товары созданные клиентом.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersProductsLightGet(isCreatedByClient?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20046>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersProductsLightGet(isCreatedByClient, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров взятых в работу байером.   
         * @summary # Получить список товаров взятых в работу байером.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersProductsMyGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20045>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersProductsMyGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров взятых в работу байером с пагинацией.   
         * @summary # Получить список товаров взятых в работу байером с пагинацией.
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersProductsPagMyGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersProductsPagMyGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Закрепить продукт за байером. Взять его в работу.  
         * @param {string} guid GUID продукта, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersProductsPickupGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersProductsPickupGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список вакантных товаров.   ## Товары со статусом 30 у которых не заполнен buyer   
         * @summary # Получить список вакантных товаров.
         * @param {boolean} [isCreatedByClient] Если true отдает товары созданные клиентом.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersProductsVacGet(isCreatedByClient?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20045>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersProductsVacGet(isCreatedByClient, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отменить задачу. Выставляет задаче статус 30.  
         * @summary # Отменить задачу.
         * @param {string} guid guid отменяемой задачи
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersTasksCancelGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersTasksCancelGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Показать все задачи данного пользователя.   
         * @summary # Показать все задачи данного пользователя.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersTasksGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20052>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersTasksGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать задачу.   Проверки: Все коробки должны быть от одного сторкипера. Все коробки должны быть от одного клиента.
         * @summary # Создать задачу.
         * @param {InlineObject69} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BuyersTasksPost(body?: InlineObject69, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BuyersTasksPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuyerApi - factory interface
 * @export
 */
export const BuyerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuyerApiFp(configuration)
    return {
        /**
         * Переместить заказ в статус atProcess
         * @summary # Переместить заказ в статус atProcess
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersAtProcessGuidPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersAtProcessGuidPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать номер заказа
         * @summary # Редактировать номер заказа.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} item 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidEditItemItemPatch(guid: string, item: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersGuidEditItemItemPatch(guid, item, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать заказ.   Данный метод позволяет редактировать все поля кроме status и totalPriceChanged Проверки:  Пока нет проверок
         * @summary # Редактировать заказ.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject68} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidEditPatch(guid: string, body?: InlineObject68, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersGuidEditPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить конкретный заказ по его GUID.   
         * @summary # Получить конкретный заказ по его GUID.
         * @param {string} guid GUID заказа.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1BuyersOrdersGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Выставить статус оплачено поставщику.  При вызове данного метода статус меняется на 20 paid  Снимает средства с замороженных средств клиента и переводятся админу Проверки:  Нельзя повторно оплачивать поставщику. paidAt !== null
         * @summary # Выставить статус оплачено поставщику.
         * @param {string} guid GUID заказа
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidPayToSupplierPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersGuidPayToSupplierPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.   При вызове данного метода ставиться статус cancelByBuyer: 35 Средства обратно возвращаются на баланс клиента.  (если оплатили посташику то от баланса админа клиенту, если не было оплаты поставщику, то разморозка средств клиента)  Проверки:  Требуется комментарий байера. Нельзя вернуть заказ если заказ закрыт клиентом
         * @summary # Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.
         * @param {string} guid GUID заказа.
         * @param {InlineObject66} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidReturnOrderPatch(guid: string, body?: InlineObject66, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersGuidReturnOrderPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Задать изменение итоговой цены, totalPriceChanged.   При повышении цены ставиться статус 19 needConfirmingToPriceChange, далее нужно ожидать подтверждения от клиента.  Если вернуть цену на старое значение, то статус возвращается к 15 atProcess. При понижении цены автоматом происходит возврат разницы клиенту, статус ставится 15 atProcess.  Проверки:  Нельзя менять цену после оплаты поставщику. paidAt !== null
         * @summary # Задать изменение итоговой цены, totalPriceChanged.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject67} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidSetTotalPriceChangedPatch(guid: string, body?: InlineObject67, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersGuidSetTotalPriceChangedPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Выставить статус \"выдан трек номер\".  При вызове данного метода статус меняется на 25 trackNumberIssued  Если ранее не была произведена оплата(paidAt === null), то производит оплату:   при оплате снимает средства с замороженных средств клиента и переводит админу Проверки:  пока нет проверок
         * @summary # Выставить статус \"выдан трек номер\".
         * @param {string} guid GUID заказа
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersGuidTrackNumberIssuedPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersGuidTrackNumberIssuedPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список заказов текущего байера.   
         * @summary # Получить список заказов текущего байера.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersMyGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20050>> {
            return localVarFp.apiV1BuyersOrdersMyGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список заказов текущего байера с пагинацией.   
         * @summary # Получить список заказов текущего байера с пагинацией.
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [status] Статусы заказов, по которым идет фильтрация, разделенные запятыми
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPagMyGet(filters?: string, status?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20051> {
            return localVarFp.apiV1BuyersOrdersPagMyGet(filters, status, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Переместить заказ в статус partiallyPaid
         * @summary # Переместить заказ в статус partiallyPaid
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPartiallyPaidGuidPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersPartiallyPaidGuidPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить общую стоимость заказов по статусам
         * @summary # Получить общую стоимость заказов по статусам
         * @param {string} status Order status
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPaymentAmountGet(status: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20049> {
            return localVarFp.apiV1BuyersOrdersPaymentAmountGet(status, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Изменить реквезиты ордера
         * @summary # Изменить реквезиты ордера
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject65} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPaymentGuidPatch(guid: string, body?: InlineObject65, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersPaymentGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Закрепить заказ за байером. Взять его в работу.  ##  На основании заказа НУЖНО СФОРМИРОВАТЬ коробки по кол-ву товаров в заказе.   ## Эндпоинт НЕ ВЕРНЕТ сформированные коробки что бы не плодить МАГИЮ или ГЛЮКИ.   ## Запросите закрепление заказа. Если операция пройдет успешно 204 - запросите создание коробки.   ## Следующим этапом сделаем возможность закреплять пачку заказов и пачку коробок готовить одним запросом. Но потом.   ## Текущая база не поддерживает транзакции.   
         * @summary # Закрепить заказ за байером. Взять его в работу.
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersPickupGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersPickupGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Переместить заказ в статус readyForPayment
         * @summary # Переместить заказ в статус readyForPayment
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject64} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersReadyForPaymentGuidPatch(guid: string, body?: InlineObject64, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersReadyForPaymentGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать номер заказа на inStock (30)
         * @summary # Редактировать номер заказа на inStock (30).
         * @param {string} guid GUID заказа, который планируем изменить
         * @param {InlineObject70} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersSetInStockGuidPatch(guid: string, body?: InlineObject70, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersOrdersSetInStockGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список свободных заказов.   
         * @summary # Получить список свободных заказов. (DEPRECATED)
         * @param {'deadline'} [sortField] Поле, по которому сортировать запрос
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersVacGet(sortField?: 'deadline', sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2001>> {
            return localVarFp.apiV1BuyersOrdersVacGet(sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список свободных заказов.   
         * @summary # Получить список свободных заказов. (PAGINATED)
         * @param {string} [filters]                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Поле, по которому сортировать запрос
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersOrdersVacPagGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.apiV1BuyersOrdersVacPagGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в продукт.  ## Байер может редактировать только товары со статусом: 35, 40, 50, 60, 235, 240, 250, 260.   
         * @summary # Внести изменения в продукт.
         * @param {string} guid GUID продукта, который планируем изменить
         * @param {InlineObject63} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsGuidPatch(guid: string, body?: InlineObject63, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersProductsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров, где пользователь - баер товара(не архив).
         * @summary # Получить список товаров, где пользователь - баер товара(не архив).
         * @param {boolean} [isCreatedByClient] Если true отдает товары созданные клиентом.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsLightGet(isCreatedByClient?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20046>> {
            return localVarFp.apiV1BuyersProductsLightGet(isCreatedByClient, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров взятых в работу байером.   
         * @summary # Получить список товаров взятых в работу байером.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsMyGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20045>> {
            return localVarFp.apiV1BuyersProductsMyGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров взятых в работу байером с пагинацией.   
         * @summary # Получить список товаров взятых в работу байером с пагинацией.
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsPagMyGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.apiV1BuyersProductsPagMyGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Закрепить продукт за байером. Взять его в работу.  
         * @param {string} guid GUID продукта, который планируем изменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsPickupGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersProductsPickupGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список вакантных товаров.   ## Товары со статусом 30 у которых не заполнен buyer   
         * @summary # Получить список вакантных товаров.
         * @param {boolean} [isCreatedByClient] Если true отдает товары созданные клиентом.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersProductsVacGet(isCreatedByClient?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20045>> {
            return localVarFp.apiV1BuyersProductsVacGet(isCreatedByClient, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отменить задачу. Выставляет задаче статус 30.  
         * @summary # Отменить задачу.
         * @param {string} guid guid отменяемой задачи
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersTasksCancelGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BuyersTasksCancelGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Показать все задачи данного пользователя.   
         * @summary # Показать все задачи данного пользователя.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersTasksGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20052>> {
            return localVarFp.apiV1BuyersTasksGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать задачу.   Проверки: Все коробки должны быть от одного сторкипера. Все коробки должны быть от одного клиента.
         * @summary # Создать задачу.
         * @param {InlineObject69} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BuyersTasksPost(body?: InlineObject69, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.apiV1BuyersTasksPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1BuyersOrdersAtProcessGuidPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersAtProcessGuidPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersAtProcessGuidPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersAtProcessGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersAtProcessGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidEditItemItemPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidEditItemItemPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidEditItemItemPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidEditItemItemPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidEditItemItemPatch
     */
    readonly item: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidEditItemItemPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidEditPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidEditPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidEditPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidEditPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject68}
     * @memberof BuyerApiApiV1BuyersOrdersGuidEditPatch
     */
    readonly body?: InlineObject68

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidEditPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidGetRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidGetRequest {
    /**
     * GUID заказа.
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidPayToSupplierPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidPayToSupplierPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidPayToSupplierPatchRequest {
    /**
     * GUID заказа
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidPayToSupplierPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidPayToSupplierPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidReturnOrderPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidReturnOrderPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidReturnOrderPatchRequest {
    /**
     * GUID заказа.
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidReturnOrderPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject66}
     * @memberof BuyerApiApiV1BuyersOrdersGuidReturnOrderPatch
     */
    readonly body?: InlineObject66

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidReturnOrderPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidSetTotalPriceChangedPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject67}
     * @memberof BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatch
     */
    readonly body?: InlineObject67

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersGuidTrackNumberIssuedPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersGuidTrackNumberIssuedPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersGuidTrackNumberIssuedPatchRequest {
    /**
     * GUID заказа
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidTrackNumberIssuedPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersGuidTrackNumberIssuedPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersMyGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersMyGetRequest
 */
export interface BuyerApiApiV1BuyersOrdersMyGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersPagMyGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersPagMyGetRequest
 */
export interface BuyerApiApiV1BuyersOrdersPagMyGetRequest {
    /**
     *                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly filters?: string

    /**
     * Статусы заказов, по которым идет фильтрация, разделенные запятыми
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly status?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPagMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersPartiallyPaidGuidPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersPartiallyPaidGuidPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersPartiallyPaidGuidPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPartiallyPaidGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPartiallyPaidGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersPaymentAmountGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersPaymentAmountGetRequest
 */
export interface BuyerApiApiV1BuyersOrdersPaymentAmountGetRequest {
    /**
     * Order status
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPaymentAmountGet
     */
    readonly status: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersOrdersPaymentAmountGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPaymentAmountGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersPaymentGuidPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersPaymentGuidPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersPaymentGuidPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPaymentGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject65}
     * @memberof BuyerApiApiV1BuyersOrdersPaymentGuidPatch
     */
    readonly body?: InlineObject65

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPaymentGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersPickupGuidPost operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersPickupGuidPostRequest
 */
export interface BuyerApiApiV1BuyersOrdersPickupGuidPostRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPickupGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersPickupGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersReadyForPaymentGuidPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject64}
     * @memberof BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatch
     */
    readonly body?: InlineObject64

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersSetInStockGuidPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersSetInStockGuidPatchRequest
 */
export interface BuyerApiApiV1BuyersOrdersSetInStockGuidPatchRequest {
    /**
     * GUID заказа, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersSetInStockGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject70}
     * @memberof BuyerApiApiV1BuyersOrdersSetInStockGuidPatch
     */
    readonly body?: InlineObject70

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersSetInStockGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersVacGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersVacGetRequest
 */
export interface BuyerApiApiV1BuyersOrdersVacGetRequest {
    /**
     * Поле, по которому сортировать запрос
     * @type {'deadline'}
     * @memberof BuyerApiApiV1BuyersOrdersVacGet
     */
    readonly sortField?: 'deadline'

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BuyerApiApiV1BuyersOrdersVacGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersOrdersVacGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersOrdersVacPagGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersOrdersVacPagGetRequest
 */
export interface BuyerApiApiV1BuyersOrdersVacPagGetRequest {
    /**
     *                Возможные поля:               asin, amazonTitle, skuByClient, id, item               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly offset?: number

    /**
     * Поле, по которому сортировать запрос
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersOrdersVacPagGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersProductsGuidPatch operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersProductsGuidPatchRequest
 */
export interface BuyerApiApiV1BuyersProductsGuidPatchRequest {
    /**
     * GUID продукта, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject63}
     * @memberof BuyerApiApiV1BuyersProductsGuidPatch
     */
    readonly body?: InlineObject63

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersProductsLightGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersProductsLightGetRequest
 */
export interface BuyerApiApiV1BuyersProductsLightGetRequest {
    /**
     * Если true отдает товары созданные клиентом.
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersProductsLightGet
     */
    readonly isCreatedByClient?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersProductsLightGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsLightGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersProductsMyGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersProductsMyGetRequest
 */
export interface BuyerApiApiV1BuyersProductsMyGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersProductsPagMyGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersProductsPagMyGetRequest
 */
export interface BuyerApiApiV1BuyersProductsPagMyGetRequest {
    /**
     *                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsPagMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersProductsPickupGuidPost operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersProductsPickupGuidPostRequest
 */
export interface BuyerApiApiV1BuyersProductsPickupGuidPostRequest {
    /**
     * GUID продукта, который планируем изменить
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsPickupGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsPickupGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersProductsVacGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersProductsVacGetRequest
 */
export interface BuyerApiApiV1BuyersProductsVacGetRequest {
    /**
     * Если true отдает товары созданные клиентом.
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersProductsVacGet
     */
    readonly isCreatedByClient?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BuyerApiApiV1BuyersProductsVacGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersProductsVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersTasksCancelGuidPost operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersTasksCancelGuidPostRequest
 */
export interface BuyerApiApiV1BuyersTasksCancelGuidPostRequest {
    /**
     * guid отменяемой задачи
     * @type {string}
     * @memberof BuyerApiApiV1BuyersTasksCancelGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersTasksCancelGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersTasksGet operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersTasksGetRequest
 */
export interface BuyerApiApiV1BuyersTasksGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersTasksGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BuyersTasksPost operation in BuyerApi.
 * @export
 * @interface BuyerApiApiV1BuyersTasksPostRequest
 */
export interface BuyerApiApiV1BuyersTasksPostRequest {
    /**
     * 
     * @type {InlineObject69}
     * @memberof BuyerApiApiV1BuyersTasksPost
     */
    readonly body?: InlineObject69

    /**
     * 
     * @type {string}
     * @memberof BuyerApiApiV1BuyersTasksPost
     */
    readonly acceptEncoding?: string
}

/**
 * BuyerApi - object-oriented interface
 * @export
 * @class BuyerApi
 * @extends {BaseAPI}
 */
export class BuyerApi extends BaseAPI {
    /**
     * Переместить заказ в статус atProcess
     * @summary # Переместить заказ в статус atProcess
     * @param {BuyerApiApiV1BuyersOrdersAtProcessGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersAtProcessGuidPatch(requestParameters: BuyerApiApiV1BuyersOrdersAtProcessGuidPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersAtProcessGuidPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать номер заказа
     * @summary # Редактировать номер заказа.
     * @param {BuyerApiApiV1BuyersOrdersGuidEditItemItemPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidEditItemItemPatch(requestParameters: BuyerApiApiV1BuyersOrdersGuidEditItemItemPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidEditItemItemPatch(requestParameters.guid, requestParameters.item, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать заказ.   Данный метод позволяет редактировать все поля кроме status и totalPriceChanged Проверки:  Пока нет проверок
     * @summary # Редактировать заказ.
     * @param {BuyerApiApiV1BuyersOrdersGuidEditPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidEditPatch(requestParameters: BuyerApiApiV1BuyersOrdersGuidEditPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidEditPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить конкретный заказ по его GUID.   
     * @summary # Получить конкретный заказ по его GUID.
     * @param {BuyerApiApiV1BuyersOrdersGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidGet(requestParameters: BuyerApiApiV1BuyersOrdersGuidGetRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Выставить статус оплачено поставщику.  При вызове данного метода статус меняется на 20 paid  Снимает средства с замороженных средств клиента и переводятся админу Проверки:  Нельзя повторно оплачивать поставщику. paidAt !== null
     * @summary # Выставить статус оплачено поставщику.
     * @param {BuyerApiApiV1BuyersOrdersGuidPayToSupplierPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidPayToSupplierPatch(requestParameters: BuyerApiApiV1BuyersOrdersGuidPayToSupplierPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidPayToSupplierPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.   При вызове данного метода ставиться статус cancelByBuyer: 35 Средства обратно возвращаются на баланс клиента.  (если оплатили посташику то от баланса админа клиенту, если не было оплаты поставщику, то разморозка средств клиента)  Проверки:  Требуется комментарий байера. Нельзя вернуть заказ если заказ закрыт клиентом
     * @summary # Выставить статус пришёл не кондиционный - \"возврат заказа\", returnOrder: 35.
     * @param {BuyerApiApiV1BuyersOrdersGuidReturnOrderPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidReturnOrderPatch(requestParameters: BuyerApiApiV1BuyersOrdersGuidReturnOrderPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidReturnOrderPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Задать изменение итоговой цены, totalPriceChanged.   При повышении цены ставиться статус 19 needConfirmingToPriceChange, далее нужно ожидать подтверждения от клиента.  Если вернуть цену на старое значение, то статус возвращается к 15 atProcess. При понижении цены автоматом происходит возврат разницы клиенту, статус ставится 15 atProcess.  Проверки:  Нельзя менять цену после оплаты поставщику. paidAt !== null
     * @summary # Задать изменение итоговой цены, totalPriceChanged.
     * @param {BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidSetTotalPriceChangedPatch(requestParameters: BuyerApiApiV1BuyersOrdersGuidSetTotalPriceChangedPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidSetTotalPriceChangedPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Выставить статус \"выдан трек номер\".  При вызове данного метода статус меняется на 25 trackNumberIssued  Если ранее не была произведена оплата(paidAt === null), то производит оплату:   при оплате снимает средства с замороженных средств клиента и переводит админу Проверки:  пока нет проверок
     * @summary # Выставить статус \"выдан трек номер\".
     * @param {BuyerApiApiV1BuyersOrdersGuidTrackNumberIssuedPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersGuidTrackNumberIssuedPatch(requestParameters: BuyerApiApiV1BuyersOrdersGuidTrackNumberIssuedPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersGuidTrackNumberIssuedPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список заказов текущего байера.   
     * @summary # Получить список заказов текущего байера.
     * @param {BuyerApiApiV1BuyersOrdersMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersMyGet(requestParameters: BuyerApiApiV1BuyersOrdersMyGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersMyGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список заказов текущего байера с пагинацией.   
     * @summary # Получить список заказов текущего байера с пагинацией.
     * @param {BuyerApiApiV1BuyersOrdersPagMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersPagMyGet(requestParameters: BuyerApiApiV1BuyersOrdersPagMyGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersPagMyGet(requestParameters.filters, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Переместить заказ в статус partiallyPaid
     * @summary # Переместить заказ в статус partiallyPaid
     * @param {BuyerApiApiV1BuyersOrdersPartiallyPaidGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersPartiallyPaidGuidPatch(requestParameters: BuyerApiApiV1BuyersOrdersPartiallyPaidGuidPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersPartiallyPaidGuidPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить общую стоимость заказов по статусам
     * @summary # Получить общую стоимость заказов по статусам
     * @param {BuyerApiApiV1BuyersOrdersPaymentAmountGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersPaymentAmountGet(requestParameters: BuyerApiApiV1BuyersOrdersPaymentAmountGetRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersPaymentAmountGet(requestParameters.status, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Изменить реквезиты ордера
     * @summary # Изменить реквезиты ордера
     * @param {BuyerApiApiV1BuyersOrdersPaymentGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersPaymentGuidPatch(requestParameters: BuyerApiApiV1BuyersOrdersPaymentGuidPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersPaymentGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Закрепить заказ за байером. Взять его в работу.  ##  На основании заказа НУЖНО СФОРМИРОВАТЬ коробки по кол-ву товаров в заказе.   ## Эндпоинт НЕ ВЕРНЕТ сформированные коробки что бы не плодить МАГИЮ или ГЛЮКИ.   ## Запросите закрепление заказа. Если операция пройдет успешно 204 - запросите создание коробки.   ## Следующим этапом сделаем возможность закреплять пачку заказов и пачку коробок готовить одним запросом. Но потом.   ## Текущая база не поддерживает транзакции.   
     * @summary # Закрепить заказ за байером. Взять его в работу.
     * @param {BuyerApiApiV1BuyersOrdersPickupGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersPickupGuidPost(requestParameters: BuyerApiApiV1BuyersOrdersPickupGuidPostRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersPickupGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Переместить заказ в статус readyForPayment
     * @summary # Переместить заказ в статус readyForPayment
     * @param {BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersReadyForPaymentGuidPatch(requestParameters: BuyerApiApiV1BuyersOrdersReadyForPaymentGuidPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersReadyForPaymentGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать номер заказа на inStock (30)
     * @summary # Редактировать номер заказа на inStock (30).
     * @param {BuyerApiApiV1BuyersOrdersSetInStockGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersSetInStockGuidPatch(requestParameters: BuyerApiApiV1BuyersOrdersSetInStockGuidPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersSetInStockGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список свободных заказов.   
     * @summary # Получить список свободных заказов. (DEPRECATED)
     * @param {BuyerApiApiV1BuyersOrdersVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersVacGet(requestParameters: BuyerApiApiV1BuyersOrdersVacGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersVacGet(requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список свободных заказов.   
     * @summary # Получить список свободных заказов. (PAGINATED)
     * @param {BuyerApiApiV1BuyersOrdersVacPagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersOrdersVacPagGet(requestParameters: BuyerApiApiV1BuyersOrdersVacPagGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersOrdersVacPagGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в продукт.  ## Байер может редактировать только товары со статусом: 35, 40, 50, 60, 235, 240, 250, 260.   
     * @summary # Внести изменения в продукт.
     * @param {BuyerApiApiV1BuyersProductsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersProductsGuidPatch(requestParameters: BuyerApiApiV1BuyersProductsGuidPatchRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersProductsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров, где пользователь - баер товара(не архив).
     * @summary # Получить список товаров, где пользователь - баер товара(не архив).
     * @param {BuyerApiApiV1BuyersProductsLightGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersProductsLightGet(requestParameters: BuyerApiApiV1BuyersProductsLightGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersProductsLightGet(requestParameters.isCreatedByClient, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров взятых в работу байером.   
     * @summary # Получить список товаров взятых в работу байером.
     * @param {BuyerApiApiV1BuyersProductsMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersProductsMyGet(requestParameters: BuyerApiApiV1BuyersProductsMyGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersProductsMyGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров взятых в работу байером с пагинацией.   
     * @summary # Получить список товаров взятых в работу байером с пагинацией.
     * @param {BuyerApiApiV1BuyersProductsPagMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersProductsPagMyGet(requestParameters: BuyerApiApiV1BuyersProductsPagMyGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersProductsPagMyGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Закрепить продукт за байером. Взять его в работу.  
     * @param {BuyerApiApiV1BuyersProductsPickupGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersProductsPickupGuidPost(requestParameters: BuyerApiApiV1BuyersProductsPickupGuidPostRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersProductsPickupGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список вакантных товаров.   ## Товары со статусом 30 у которых не заполнен buyer   
     * @summary # Получить список вакантных товаров.
     * @param {BuyerApiApiV1BuyersProductsVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersProductsVacGet(requestParameters: BuyerApiApiV1BuyersProductsVacGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersProductsVacGet(requestParameters.isCreatedByClient, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отменить задачу. Выставляет задаче статус 30.  
     * @summary # Отменить задачу.
     * @param {BuyerApiApiV1BuyersTasksCancelGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersTasksCancelGuidPost(requestParameters: BuyerApiApiV1BuyersTasksCancelGuidPostRequest, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersTasksCancelGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Показать все задачи данного пользователя.   
     * @summary # Показать все задачи данного пользователя.
     * @param {BuyerApiApiV1BuyersTasksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersTasksGet(requestParameters: BuyerApiApiV1BuyersTasksGetRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersTasksGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать задачу.   Проверки: Все коробки должны быть от одного сторкипера. Все коробки должны быть от одного клиента.
     * @summary # Создать задачу.
     * @param {BuyerApiApiV1BuyersTasksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuyerApi
     */
    public apiV1BuyersTasksPost(requestParameters: BuyerApiApiV1BuyersTasksPostRequest = {}, options?: any) {
        return BuyerApiFp(this.configuration).apiV1BuyersTasksPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
