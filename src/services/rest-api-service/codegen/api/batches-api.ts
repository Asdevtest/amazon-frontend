/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { InlineObject10 } from '../models';
// @ts-ignore
import { InlineObject3 } from '../models';
// @ts-ignore
import { InlineObject4 } from '../models';
// @ts-ignore
import { InlineObject5 } from '../models';
// @ts-ignore
import { InlineObject6 } from '../models';
// @ts-ignore
import { InlineObject7 } from '../models';
// @ts-ignore
import { InlineObject8 } from '../models';
// @ts-ignore
import { InlineObject9 } from '../models';
// @ts-ignore
import { InlineResponse2002 } from '../models';
// @ts-ignore
import { InlineResponse2003 } from '../models';
// @ts-ignore
import { InlineResponse2004 } from '../models';
// @ts-ignore
import { InlineResponse2005 } from '../models';
// @ts-ignore
import { InlineResponse2011 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Изменить у массива партий поле archive
         * @summary # Изменить у массива партий поле archive
         * @param {InlineObject10} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesArchivePatch: async (body?: InlineObject10, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/batches/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить партии по гуиду продукта.   
         * @summary # Получить партии по гуиду продукта
         * @param {string} guid GUID продукта.
         * @param {boolean} [archive] Заархивирована ли партия
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesByProductGuidGet: async (guid: string, archive?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesByProductGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/batches/by_product/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Рассчитать стоимость доставки коробов.   
         * @summary # Рассчитать стоимость доставки коробов.
         * @param {InlineObject8} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesCalculateBoxDeliveryCostsInBatchPost: async (body?: InlineObject8, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/batches/calculate_box_delivery_costs_in_batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'} [status] GUID склада который нужно получить.
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGet: async (status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/batches/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Добавить коробки в партию.   В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только партии со статусом IS_BEING_COLLECTED         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH,  IN_BATCH         В партии все коробки должны быть от данного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         Актуальный тариф доставки всех коробок.         В партии все коробки должны быть с одинаковым тариф доставки         Наличие шипинг лейбла у всех коробок.
         * @summary # Добавить коробки в партию.
         * @param {string} guid GUID партии.
         * @param {InlineObject5} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidAddBoxesPatch: async (guid: string, body?: InlineObject5, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesGuidAddBoxesPatch', 'guid', guid)
            const localVarPath = `/api/v1/batches/{guid}/add_boxes`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Выставить статус отбытия партии из склада  Этот метод будет дергать склад,         Статус партии поменяется на HAS_DISPATCHED.         Статус коробок поменяется на IN_BATCH_ON_THE_WAY.         Проверки:         Сторкипер может редактировать только свою партию         Статус партии должен быть ранее: IS_BEING_COLLECTED         В партии должна быть хотя бы одно коробка.         у всех коробок статус должен быть ранее: IN_BATCH         Итоговая цена за доставку должна быть больше 0.
         * @summary # Выставить статус отбытия партии из склада.
         * @param {string} guid GUID партии.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidBatchHasDispatchedPatch: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesGuidBatchHasDispatchedPatch', 'guid', guid)
            const localVarPath = `/api/v1/batches/{guid}/batch_has_dispatched`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать прикрепленные документы партии.   ## Проверки:         Доступно только для сторкипера
         * @summary # Редактировать прикрепленные документы партии.
         * @param {string} guid GUID партии.
         * @param {InlineObject9} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidEditAttachedDocumentsPatch: async (guid: string, body?: InlineObject9, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesGuidEditAttachedDocumentsPatch', 'guid', guid)
            const localVarPath = `/api/v1/batches/{guid}/edit_attachedDocuments`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {string} guid GUID партии.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/batches/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменение партии   
         * @summary # Изменение партии
         * @param {string} guid GUID продукта.
         * @param {InlineObject7} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidPatch: async (guid: string, body?: InlineObject7, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/batches/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить коробки из партии.   В коробках поле batchId становиться null, и статус возвращается на REQUESTED_SEND_TO_BATCH         Проверки:         Доступно только для сторкипера или клиента владелец коробки.         Только коробки которые есть в партии
         * @summary # Удалить коробки из партии.
         * @param {string} guid GUID партии.
         * @param {InlineObject6} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidRemoveBoxesPatch: async (guid: string, body?: InlineObject6, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BatchesGuidRemoveBoxesPatch', 'guid', guid)
            const localVarPath = `/api/v1/batches/{guid}/remove_boxes`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать партию.   При выполнении этого запроса создается партия со статусом IS_BEING_COLLECTED - набирается         В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH, IN_BATCH         В партии все коробки должны быть от одного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         В партии все коробки должны быть с одинаковым тарифом доставки         Коробку нельзя повторно добавить в партию         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
         * @summary # Создать партию.
         * @param {InlineObject4} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesPost: async (body?: InlineObject4, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/batches/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить репорт по партии.       Возвращает файл xlsx, есть 2 версии       
         * @summary # Получить репорт по партии
         * @param {number} batchId GUID продукта.
         * @param {boolean} [getOldVer] Если true то заполнит старую версию отчета
         * @param {boolean} [woPicture] Не скачивать файлы?
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesReportBatchIdGet: async (batchId: number, getOldVer?: boolean, woPicture?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('apiV1BatchesReportBatchIdGet', 'batchId', batchId)
            const localVarPath = `/api/v1/batches/report/{batchId}`
                .replace(`{${"batchId"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (getOldVer !== undefined) {
                localVarQueryParameter['getOldVer'] = getOldVer;
            }

            if (woPicture !== undefined) {
                localVarQueryParameter['woPicture'] = woPicture;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Запросить отправку набора коробок в партию.  при выполнении этого запроса у всех этих коробок поле статус меняется на  REQUESTED_SEND_TO_BATCH.         У клиента замораживаются средства.         Стоимость доставки записывается в поле deliveryTotalPrice         Проверки:         Доступно только для клиента         Коробку нельзя повторно отправлять для набора в партию, статус должен быть IN_STOCK         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
         * @summary # Запросить отправку набора коробок в партию.
         * @param {InlineObject3} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesRequestSendBoxesToBatchPost: async (body?: InlineObject3, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/batches/request_send_boxes_to_batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'} [status] GUID склада который нужно получить.
         * @param {boolean} [archive] Заархивирована ли партия
         * @param {string} [filters]                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesWithFiltersGet: async (status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED', archive?: boolean, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/batches/with_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Изменить у массива партий поле archive
         * @summary # Изменить у массива партий поле archive
         * @param {InlineObject10} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesArchivePatch(body?: InlineObject10, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesArchivePatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить партии по гуиду продукта.   
         * @summary # Получить партии по гуиду продукта
         * @param {string} guid GUID продукта.
         * @param {boolean} [archive] Заархивирована ли партия
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesByProductGuidGet(guid: string, archive?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2005>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesByProductGuidGet(guid, archive, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Рассчитать стоимость доставки коробов.   
         * @summary # Рассчитать стоимость доставки коробов.
         * @param {InlineObject8} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesCalculateBoxDeliveryCostsInBatchPost(body?: InlineObject8, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesCalculateBoxDeliveryCostsInBatchPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'} [status] GUID склада который нужно получить.
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGet(status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2002>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGet(status, storekeeperId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Добавить коробки в партию.   В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только партии со статусом IS_BEING_COLLECTED         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH,  IN_BATCH         В партии все коробки должны быть от данного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         Актуальный тариф доставки всех коробок.         В партии все коробки должны быть с одинаковым тариф доставки         Наличие шипинг лейбла у всех коробок.
         * @summary # Добавить коробки в партию.
         * @param {string} guid GUID партии.
         * @param {InlineObject5} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGuidAddBoxesPatch(guid: string, body?: InlineObject5, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGuidAddBoxesPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Выставить статус отбытия партии из склада  Этот метод будет дергать склад,         Статус партии поменяется на HAS_DISPATCHED.         Статус коробок поменяется на IN_BATCH_ON_THE_WAY.         Проверки:         Сторкипер может редактировать только свою партию         Статус партии должен быть ранее: IS_BEING_COLLECTED         В партии должна быть хотя бы одно коробка.         у всех коробок статус должен быть ранее: IN_BATCH         Итоговая цена за доставку должна быть больше 0.
         * @summary # Выставить статус отбытия партии из склада.
         * @param {string} guid GUID партии.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGuidBatchHasDispatchedPatch(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGuidBatchHasDispatchedPatch(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать прикрепленные документы партии.   ## Проверки:         Доступно только для сторкипера
         * @summary # Редактировать прикрепленные документы партии.
         * @param {string} guid GUID партии.
         * @param {InlineObject9} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGuidEditAttachedDocumentsPatch(guid: string, body?: InlineObject9, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGuidEditAttachedDocumentsPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {string} guid GUID партии.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменение партии   
         * @summary # Изменение партии
         * @param {string} guid GUID продукта.
         * @param {InlineObject7} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGuidPatch(guid: string, body?: InlineObject7, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить коробки из партии.   В коробках поле batchId становиться null, и статус возвращается на REQUESTED_SEND_TO_BATCH         Проверки:         Доступно только для сторкипера или клиента владелец коробки.         Только коробки которые есть в партии
         * @summary # Удалить коробки из партии.
         * @param {string} guid GUID партии.
         * @param {InlineObject6} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesGuidRemoveBoxesPatch(guid: string, body?: InlineObject6, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesGuidRemoveBoxesPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать партию.   При выполнении этого запроса создается партия со статусом IS_BEING_COLLECTED - набирается         В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH, IN_BATCH         В партии все коробки должны быть от одного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         В партии все коробки должны быть с одинаковым тарифом доставки         Коробку нельзя повторно добавить в партию         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
         * @summary # Создать партию.
         * @param {InlineObject4} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesPost(body?: InlineObject4, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить репорт по партии.       Возвращает файл xlsx, есть 2 версии       
         * @summary # Получить репорт по партии
         * @param {number} batchId GUID продукта.
         * @param {boolean} [getOldVer] Если true то заполнит старую версию отчета
         * @param {boolean} [woPicture] Не скачивать файлы?
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesReportBatchIdGet(batchId: number, getOldVer?: boolean, woPicture?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesReportBatchIdGet(batchId, getOldVer, woPicture, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Запросить отправку набора коробок в партию.  при выполнении этого запроса у всех этих коробок поле статус меняется на  REQUESTED_SEND_TO_BATCH.         У клиента замораживаются средства.         Стоимость доставки записывается в поле deliveryTotalPrice         Проверки:         Доступно только для клиента         Коробку нельзя повторно отправлять для набора в партию, статус должен быть IN_STOCK         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
         * @summary # Запросить отправку набора коробок в партию.
         * @param {InlineObject3} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesRequestSendBoxesToBatchPost(body?: InlineObject3, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesRequestSendBoxesToBatchPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'} [status] GUID склада который нужно получить.
         * @param {boolean} [archive] Заархивирована ли партия
         * @param {string} [filters]                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BatchesWithFiltersGet(status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED', archive?: boolean, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BatchesWithFiltersGet(status, archive, filters, limit, offset, sortField, sortType, storekeeperId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchesApiFp(configuration)
    return {
        /**
         * ## Изменить у массива партий поле archive
         * @summary # Изменить у массива партий поле archive
         * @param {InlineObject10} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesArchivePatch(body?: InlineObject10, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BatchesArchivePatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить партии по гуиду продукта.   
         * @summary # Получить партии по гуиду продукта
         * @param {string} guid GUID продукта.
         * @param {boolean} [archive] Заархивирована ли партия
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesByProductGuidGet(guid: string, archive?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2005>> {
            return localVarFp.apiV1BatchesByProductGuidGet(guid, archive, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Рассчитать стоимость доставки коробов.   
         * @summary # Рассчитать стоимость доставки коробов.
         * @param {InlineObject8} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesCalculateBoxDeliveryCostsInBatchPost(body?: InlineObject8, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2004>> {
            return localVarFp.apiV1BatchesCalculateBoxDeliveryCostsInBatchPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'} [status] GUID склада который нужно получить.
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGet(status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse2002>> {
            return localVarFp.apiV1BatchesGet(status, storekeeperId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Добавить коробки в партию.   В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только партии со статусом IS_BEING_COLLECTED         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH,  IN_BATCH         В партии все коробки должны быть от данного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         Актуальный тариф доставки всех коробок.         В партии все коробки должны быть с одинаковым тариф доставки         Наличие шипинг лейбла у всех коробок.
         * @summary # Добавить коробки в партию.
         * @param {string} guid GUID партии.
         * @param {InlineObject5} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidAddBoxesPatch(guid: string, body?: InlineObject5, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BatchesGuidAddBoxesPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Выставить статус отбытия партии из склада  Этот метод будет дергать склад,         Статус партии поменяется на HAS_DISPATCHED.         Статус коробок поменяется на IN_BATCH_ON_THE_WAY.         Проверки:         Сторкипер может редактировать только свою партию         Статус партии должен быть ранее: IS_BEING_COLLECTED         В партии должна быть хотя бы одно коробка.         у всех коробок статус должен быть ранее: IN_BATCH         Итоговая цена за доставку должна быть больше 0.
         * @summary # Выставить статус отбытия партии из склада.
         * @param {string} guid GUID партии.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidBatchHasDispatchedPatch(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BatchesGuidBatchHasDispatchedPatch(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать прикрепленные документы партии.   ## Проверки:         Доступно только для сторкипера
         * @summary # Редактировать прикрепленные документы партии.
         * @param {string} guid GUID партии.
         * @param {InlineObject9} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidEditAttachedDocumentsPatch(guid: string, body?: InlineObject9, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.apiV1BatchesGuidEditAttachedDocumentsPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {string} guid GUID партии.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.apiV1BatchesGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменение партии   
         * @summary # Изменение партии
         * @param {string} guid GUID продукта.
         * @param {InlineObject7} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidPatch(guid: string, body?: InlineObject7, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BatchesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить коробки из партии.   В коробках поле batchId становиться null, и статус возвращается на REQUESTED_SEND_TO_BATCH         Проверки:         Доступно только для сторкипера или клиента владелец коробки.         Только коробки которые есть в партии
         * @summary # Удалить коробки из партии.
         * @param {string} guid GUID партии.
         * @param {InlineObject6} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesGuidRemoveBoxesPatch(guid: string, body?: InlineObject6, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BatchesGuidRemoveBoxesPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать партию.   При выполнении этого запроса создается партия со статусом IS_BEING_COLLECTED - набирается         В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH, IN_BATCH         В партии все коробки должны быть от одного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         В партии все коробки должны быть с одинаковым тарифом доставки         Коробку нельзя повторно добавить в партию         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
         * @summary # Создать партию.
         * @param {InlineObject4} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesPost(body?: InlineObject4, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.apiV1BatchesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить репорт по партии.       Возвращает файл xlsx, есть 2 версии       
         * @summary # Получить репорт по партии
         * @param {number} batchId GUID продукта.
         * @param {boolean} [getOldVer] Если true то заполнит старую версию отчета
         * @param {boolean} [woPicture] Не скачивать файлы?
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesReportBatchIdGet(batchId: number, getOldVer?: boolean, woPicture?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<any> {
            return localVarFp.apiV1BatchesReportBatchIdGet(batchId, getOldVer, woPicture, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Запросить отправку набора коробок в партию.  при выполнении этого запроса у всех этих коробок поле статус меняется на  REQUESTED_SEND_TO_BATCH.         У клиента замораживаются средства.         Стоимость доставки записывается в поле deliveryTotalPrice         Проверки:         Доступно только для клиента         Коробку нельзя повторно отправлять для набора в партию, статус должен быть IN_STOCK         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
         * @summary # Запросить отправку набора коробок в партию.
         * @param {InlineObject3} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesRequestSendBoxesToBatchPost(body?: InlineObject3, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BatchesRequestSendBoxesToBatchPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
         * @summary # Получить партии.
         * @param {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'} [status] GUID склада который нужно получить.
         * @param {boolean} [archive] Заархивирована ли партия
         * @param {string} [filters]                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BatchesWithFiltersGet(status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED', archive?: boolean, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.apiV1BatchesWithFiltersGet(status, archive, filters, limit, offset, sortField, sortType, storekeeperId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1BatchesArchivePatch operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesArchivePatchRequest
 */
export interface BatchesApiApiV1BatchesArchivePatchRequest {
    /**
     * 
     * @type {InlineObject10}
     * @memberof BatchesApiApiV1BatchesArchivePatch
     */
    readonly body?: InlineObject10

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesArchivePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesByProductGuidGet operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesByProductGuidGetRequest
 */
export interface BatchesApiApiV1BatchesByProductGuidGetRequest {
    /**
     * GUID продукта.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesByProductGuidGet
     */
    readonly guid: string

    /**
     * Заархивирована ли партия
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesByProductGuidGet
     */
    readonly archive?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesByProductGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesByProductGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesCalculateBoxDeliveryCostsInBatchPost operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesCalculateBoxDeliveryCostsInBatchPostRequest
 */
export interface BatchesApiApiV1BatchesCalculateBoxDeliveryCostsInBatchPostRequest {
    /**
     * 
     * @type {InlineObject8}
     * @memberof BatchesApiApiV1BatchesCalculateBoxDeliveryCostsInBatchPost
     */
    readonly body?: InlineObject8

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesCalculateBoxDeliveryCostsInBatchPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGet operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGetRequest
 */
export interface BatchesApiApiV1BatchesGetRequest {
    /**
     * GUID склада который нужно получить.
     * @type {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'}
     * @memberof BatchesApiApiV1BatchesGet
     */
    readonly status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'

    /**
     * GUID склада который нужно получить.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGet
     */
    readonly storekeeperId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGuidAddBoxesPatch operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGuidAddBoxesPatchRequest
 */
export interface BatchesApiApiV1BatchesGuidAddBoxesPatchRequest {
    /**
     * GUID партии.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidAddBoxesPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject5}
     * @memberof BatchesApiApiV1BatchesGuidAddBoxesPatch
     */
    readonly body?: InlineObject5

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidAddBoxesPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGuidBatchHasDispatchedPatch operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGuidBatchHasDispatchedPatchRequest
 */
export interface BatchesApiApiV1BatchesGuidBatchHasDispatchedPatchRequest {
    /**
     * GUID партии.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidBatchHasDispatchedPatch
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidBatchHasDispatchedPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGuidEditAttachedDocumentsPatch operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatchRequest
 */
export interface BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatchRequest {
    /**
     * GUID партии.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject9}
     * @memberof BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatch
     */
    readonly body?: InlineObject9

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGuidGet operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGuidGetRequest
 */
export interface BatchesApiApiV1BatchesGuidGetRequest {
    /**
     * GUID партии.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGuidPatch operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGuidPatchRequest
 */
export interface BatchesApiApiV1BatchesGuidPatchRequest {
    /**
     * GUID продукта.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject7}
     * @memberof BatchesApiApiV1BatchesGuidPatch
     */
    readonly body?: InlineObject7

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesGuidRemoveBoxesPatch operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesGuidRemoveBoxesPatchRequest
 */
export interface BatchesApiApiV1BatchesGuidRemoveBoxesPatchRequest {
    /**
     * GUID партии.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidRemoveBoxesPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof BatchesApiApiV1BatchesGuidRemoveBoxesPatch
     */
    readonly body?: InlineObject6

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesGuidRemoveBoxesPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesPost operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesPostRequest
 */
export interface BatchesApiApiV1BatchesPostRequest {
    /**
     * 
     * @type {InlineObject4}
     * @memberof BatchesApiApiV1BatchesPost
     */
    readonly body?: InlineObject4

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesReportBatchIdGet operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesReportBatchIdGetRequest
 */
export interface BatchesApiApiV1BatchesReportBatchIdGetRequest {
    /**
     * GUID продукта.
     * @type {number}
     * @memberof BatchesApiApiV1BatchesReportBatchIdGet
     */
    readonly batchId: number

    /**
     * Если true то заполнит старую версию отчета
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesReportBatchIdGet
     */
    readonly getOldVer?: boolean

    /**
     * Не скачивать файлы?
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesReportBatchIdGet
     */
    readonly woPicture?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesReportBatchIdGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesReportBatchIdGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesRequestSendBoxesToBatchPost operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesRequestSendBoxesToBatchPostRequest
 */
export interface BatchesApiApiV1BatchesRequestSendBoxesToBatchPostRequest {
    /**
     * 
     * @type {InlineObject3}
     * @memberof BatchesApiApiV1BatchesRequestSendBoxesToBatchPost
     */
    readonly body?: InlineObject3

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesRequestSendBoxesToBatchPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BatchesWithFiltersGet operation in BatchesApi.
 * @export
 * @interface BatchesApiApiV1BatchesWithFiltersGetRequest
 */
export interface BatchesApiApiV1BatchesWithFiltersGetRequest {
    /**
     * GUID склада который нужно получить.
     * @type {'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly status?: 'IS_BEING_COLLECTED' | 'HAS_DISPATCHED'

    /**
     * Заархивирована ли партия
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly archive?: boolean

    /**
     *                Возможные поля: asin:, amazonTitle, skuByClient, orderHumanFriendlyId, trackNumberText, orderItem, humanFriendlyId               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * GUID склада который нужно получить.
     * @type {string}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly storekeeperId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BatchesApiApiV1BatchesWithFiltersGet
     */
    readonly acceptEncoding?: string
}

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
    /**
     * ## Изменить у массива партий поле archive
     * @summary # Изменить у массива партий поле archive
     * @param {BatchesApiApiV1BatchesArchivePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesArchivePatch(requestParameters: BatchesApiApiV1BatchesArchivePatchRequest = {}, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesArchivePatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить партии по гуиду продукта.   
     * @summary # Получить партии по гуиду продукта
     * @param {BatchesApiApiV1BatchesByProductGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesByProductGuidGet(requestParameters: BatchesApiApiV1BatchesByProductGuidGetRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesByProductGuidGet(requestParameters.guid, requestParameters.archive, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Рассчитать стоимость доставки коробов.   
     * @summary # Рассчитать стоимость доставки коробов.
     * @param {BatchesApiApiV1BatchesCalculateBoxDeliveryCostsInBatchPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesCalculateBoxDeliveryCostsInBatchPost(requestParameters: BatchesApiApiV1BatchesCalculateBoxDeliveryCostsInBatchPostRequest = {}, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesCalculateBoxDeliveryCostsInBatchPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
     * @summary # Получить партии.
     * @param {BatchesApiApiV1BatchesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGet(requestParameters: BatchesApiApiV1BatchesGetRequest = {}, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGet(requestParameters.status, requestParameters.storekeeperId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Добавить коробки в партию.   В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только партии со статусом IS_BEING_COLLECTED         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH,  IN_BATCH         В партии все коробки должны быть от данного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         Актуальный тариф доставки всех коробок.         В партии все коробки должны быть с одинаковым тариф доставки         Наличие шипинг лейбла у всех коробок.
     * @summary # Добавить коробки в партию.
     * @param {BatchesApiApiV1BatchesGuidAddBoxesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGuidAddBoxesPatch(requestParameters: BatchesApiApiV1BatchesGuidAddBoxesPatchRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGuidAddBoxesPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Выставить статус отбытия партии из склада  Этот метод будет дергать склад,         Статус партии поменяется на HAS_DISPATCHED.         Статус коробок поменяется на IN_BATCH_ON_THE_WAY.         Проверки:         Сторкипер может редактировать только свою партию         Статус партии должен быть ранее: IS_BEING_COLLECTED         В партии должна быть хотя бы одно коробка.         у всех коробок статус должен быть ранее: IN_BATCH         Итоговая цена за доставку должна быть больше 0.
     * @summary # Выставить статус отбытия партии из склада.
     * @param {BatchesApiApiV1BatchesGuidBatchHasDispatchedPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGuidBatchHasDispatchedPatch(requestParameters: BatchesApiApiV1BatchesGuidBatchHasDispatchedPatchRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGuidBatchHasDispatchedPatch(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать прикрепленные документы партии.   ## Проверки:         Доступно только для сторкипера
     * @summary # Редактировать прикрепленные документы партии.
     * @param {BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGuidEditAttachedDocumentsPatch(requestParameters: BatchesApiApiV1BatchesGuidEditAttachedDocumentsPatchRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGuidEditAttachedDocumentsPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
     * @summary # Получить партии.
     * @param {BatchesApiApiV1BatchesGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGuidGet(requestParameters: BatchesApiApiV1BatchesGuidGetRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменение партии   
     * @summary # Изменение партии
     * @param {BatchesApiApiV1BatchesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGuidPatch(requestParameters: BatchesApiApiV1BatchesGuidPatchRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить коробки из партии.   В коробках поле batchId становиться null, и статус возвращается на REQUESTED_SEND_TO_BATCH         Проверки:         Доступно только для сторкипера или клиента владелец коробки.         Только коробки которые есть в партии
     * @summary # Удалить коробки из партии.
     * @param {BatchesApiApiV1BatchesGuidRemoveBoxesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesGuidRemoveBoxesPatch(requestParameters: BatchesApiApiV1BatchesGuidRemoveBoxesPatchRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesGuidRemoveBoxesPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать партию.   При выполнении этого запроса создается партия со статусом IS_BEING_COLLECTED - набирается         В коробки вписывается id партии и статус меняется на IN_BATCH         Проверки:         Доступно только для сторкипера         Только коробки которые запросили отправить в партию, REQUESTED_SEND_TO_BATCH, IN_BATCH         В партии все коробки должны быть от одного сторкипера         В партии у всех коробок должен быть одинаковый адрес склада прибытия.         В партии все коробки должны быть с одинаковым тарифом доставки         Коробку нельзя повторно добавить в партию         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
     * @summary # Создать партию.
     * @param {BatchesApiApiV1BatchesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesPost(requestParameters: BatchesApiApiV1BatchesPostRequest = {}, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить репорт по партии.       Возвращает файл xlsx, есть 2 версии       
     * @summary # Получить репорт по партии
     * @param {BatchesApiApiV1BatchesReportBatchIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesReportBatchIdGet(requestParameters: BatchesApiApiV1BatchesReportBatchIdGetRequest, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesReportBatchIdGet(requestParameters.batchId, requestParameters.getOldVer, requestParameters.woPicture, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Запросить отправку набора коробок в партию.  при выполнении этого запроса у всех этих коробок поле статус меняется на  REQUESTED_SEND_TO_BATCH.         У клиента замораживаются средства.         Стоимость доставки записывается в поле deliveryTotalPrice         Проверки:         Доступно только для клиента         Коробку нельзя повторно отправлять для набора в партию, статус должен быть IN_STOCK         Наличие шипинг лейбла у всех коробок.         Актуальный тариф доставки всех коробок.
     * @summary # Запросить отправку набора коробок в партию.
     * @param {BatchesApiApiV1BatchesRequestSendBoxesToBatchPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesRequestSendBoxesToBatchPost(requestParameters: BatchesApiApiV1BatchesRequestSendBoxesToBatchPostRequest = {}, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesRequestSendBoxesToBatchPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить партии. В зависимости от роли:  админ - получает все партии без исключения.         клиент - получает все партии в которых есть его коробки.         супер: получает все партии без исключения.         байер: получает все партии в которых есть его коробки, которые он создал.         сторкипер: получает только свои партии.
     * @summary # Получить партии.
     * @param {BatchesApiApiV1BatchesWithFiltersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatchesApi
     */
    public apiV1BatchesWithFiltersGet(requestParameters: BatchesApiApiV1BatchesWithFiltersGetRequest = {}, options?: any) {
        return BatchesApiFp(this.configuration).apiV1BatchesWithFiltersGet(requestParameters.status, requestParameters.archive, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.storekeeperId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
