/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject } from '../models';
// @ts-ignore
import { InlineObject19 } from '../models';
// @ts-ignore
import { InlineObject20 } from '../models';
// @ts-ignore
import { InlineObject21 } from '../models';
// @ts-ignore
import { InlineObject22 } from '../models';
// @ts-ignore
import { InlineObject23 } from '../models';
// @ts-ignore
import { InlineObject24 } from '../models';
// @ts-ignore
import { InlineObject25 } from '../models';
// @ts-ignore
import { InlineObject26 } from '../models';
// @ts-ignore
import { InlineObject27 } from '../models';
// @ts-ignore
import { InlineObject28 } from '../models';
// @ts-ignore
import { InlineObject29 } from '../models';
// @ts-ignore
import { InlineObject30 } from '../models';
// @ts-ignore
import { InlineObject31 } from '../models';
// @ts-ignore
import { InlineObject32 } from '../models';
// @ts-ignore
import { InlineObject33 } from '../models';
// @ts-ignore
import { InlineObject34 } from '../models';
// @ts-ignore
import { InlineResponse20016 } from '../models';
// @ts-ignore
import { InlineResponse20016Rows } from '../models';
// @ts-ignore
import { InlineResponse20017 } from '../models';
// @ts-ignore
import { InlineResponse20018 } from '../models';
// @ts-ignore
import { InlineResponse20019 } from '../models';
// @ts-ignore
import { InlineResponse20020 } from '../models';
// @ts-ignore
import { InlineResponse20021 } from '../models';
// @ts-ignore
import { InlineResponse20022 } from '../models';
// @ts-ignore
import { InlineResponse20023 } from '../models';
// @ts-ignore
import { InlineResponse20024 } from '../models';
// @ts-ignore
import { InlineResponse20025 } from '../models';
// @ts-ignore
import { InlineResponse2011 } from '../models';
// @ts-ignore
import { InlineResponse2012 } from '../models';
// @ts-ignore
import { InlineResponse2013 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
/**
 * BoxesApi - axios parameter creator
 * @export
 */
export const BoxesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Изменить дополнительную информацию коробки.
         * @summary # Изменить дополнительную информацию коробки.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject33} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesAdditionalInfoGuidPatch: async (guid: string, body?: InlineObject33, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesAdditionalInfoGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/boxes/additional_info/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Подтвердить операцию объединения/разъединения коробок.  
         * @summary # Подтвердить операцию объединения/разъединения коробок.
         * @param {InlineObject28} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesApprovePost: async (body?: InlineObject28, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/approve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## # Получить коробки и их строки по GUID заказа.   
         * @summary # Получить коробки и их строки по GUID заказа.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesByOrderGuidGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesByOrderGuidGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/boxes/by_order_guid/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesByProductGuidGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesByProductGuidGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/boxes/by_product_guid/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesByProductGuidLightGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesByProductGuidLightGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/boxes/by_product_guid_light/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отменить редактирование коробок.  
         * @summary # Отменить редактирование коробок.
         * @param {InlineObject23} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelEditPost: async (body?: InlineObject23, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/cancel-edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отменить редактирование коробок сотрудником склада.  
         * @summary # Отменить редактирование коробок сотрудником склада.
         * @param {string} guid GUID коробки, объединение которой нужно отменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelEditWithDraftGuidPost: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesCancelEditWithDraftGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/boxes/cancel_edit_with_draft/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отменить объединение коробок.  
         * @summary # Отменить объединение коробок.
         * @param {InlineObject25} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelMergePost: async (body?: InlineObject25, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/cancel-merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отменить разделение коробок.   ## !!! У каждой коробки которая была создана разделением есть братья.    ## !!! Братья - коробки которые были созданы с этой, при разделении родителя.    ## !!! При отмене текущая коробка и все ee братья будут удалены. Родитель восстановлен.   
         * @summary # Отменить разделение коробок.
         * @param {InlineObject27} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelSplitPost: async (body?: InlineObject27, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/cancel-split`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить полей габаритов, массы коробки.
         * @summary # Изменить полей габаритов, массы коробки.
         * @param {string} guid GUID коробки.
         * @param {InlineObject31} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesChangeDimensionsGuidPatch: async (guid: string, body?: InlineObject31, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesChangeDimensionsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/boxes/change-dimensions/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {string} status Статусы коробок разделенные запятой
         * @param {boolean} [hasBatch] Должна ли коробка иметь свою партию
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {string} [destinationId] GUID дестинейшна, который должен быть у боксов. Может быть null
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsGet: async (status: string, hasBatch?: boolean, storekeeperId?: string, destinationId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('apiV1BoxesClientsGet', 'status', status)
            const localVarPath = `/api/v1/boxes/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (hasBatch !== undefined) {
                localVarQueryParameter['hasBatch'] = hasBatch;
            }

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (destinationId !== undefined) {
                localVarQueryParameter['destinationId'] = destinationId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отредактировать коробку клиентом  Клиент может отредактировать только свои коробки.  проверка на наличие склада назначения  проверка на наличие тарифа к сторкипера
         * @summary # Отредактировать коробку клиентом
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject21} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsGuidPatch: async (guid: string, body?: InlineObject21, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesClientsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/boxes/clients/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
         * @summary # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
         * @param {string} guid poroduct GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsInTransferGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesClientsInTransferGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/boxes/clients/in_transfer/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'} status 
         * @param {string} [shopId] Гуид магазина
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsLightGet: async (status: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING', shopId?: string, storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('apiV1BoxesClientsLightGet', 'status', status)
            const localVarPath = `/api/v1/boxes/clients_light`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (shopId !== undefined) {
                localVarQueryParameter['shopId'] = shopId;
            }

            if (storekeeperId !== undefined) {
                localVarQueryParameter['storekeeperId'] = storekeeperId;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [onAmazon] On Amazon
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsProductInBatchGuidGet: async (guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', onAmazon?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesClientsProductInBatchGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/boxes/clients/product_in_batch/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (onAmazon !== undefined) {
                localVarQueryParameter['onAmazon'] = onAmazon;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки по текущему клиенту отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
         * @summary # Получить коробки по текущему клиенту отправленные в партию.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsSentToBatchGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/clients/sent_to_batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## ЭТО МЕТОД ИСОЛЬЗУЕТСЯ ДЛЯ ТАСКОВ  ## Отредактировать коробку. Коробка после редактирования станет черновиком. Ее нужно будет подтвердить  ## ВНИМАНИЕ - фактически будет создана новая коробка а старая пометится как удаленная.   ## ВНИМАНИЕ - передайте весь набор параметров как на создание новой коробки. Не только те которые нужно изменить.  
         * @summary # Отредактировать коробку. Сликом гибкий метод
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject20} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesEditGuidPost: async (guid: string, body?: InlineObject20, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesEditGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/boxes/edit/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки их строки.   
         * @summary # Получить коробки и их строки.
         * @param {string} [filters]                Возможные поля: humanFriendlyId, asin, sku_by_client, amazon_title,               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить сгруппированные коробки
         * @summary # Получить сгруппированные коробки
         * @param {string} [additionalGroupParameter]                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
         * @param {number} [limit] Сколько вернуть полей
         * @param {number} [offset] Сколько отступить от начала полей
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGroupedGet: async (additionalGroupParameter?: string, limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/grouped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (additionalGroupParameter !== undefined) {
                localVarQueryParameter['additionalGroupParameter'] = additionalGroupParameter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить группы
         * @summary # Получить группы
         * @param {string} [additionalGroupParameter]                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
         * @param {number} [limit] Сколько вернуть полей
         * @param {number} [offset] Сколько отступить от начала полей
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGroupedGroupsGet: async (additionalGroupParameter?: string, limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/grouped/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (additionalGroupParameter !== undefined) {
                localVarQueryParameter['additionalGroupParameter'] = additionalGroupParameter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить похожие коробки  
         * @summary # Получить похожие коробки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGroupedSimilarGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/grouped/similar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить данные коробки по GUID.   
         * @summary # Получить данные коробки по GUID.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/boxes/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Изменить поле isFormed
         * @summary # Изменить поле isFormed
         * @param {string} guid GUID коробки.
         * @param {InlineObject34} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesIsFormedGuidPatch: async (guid: string, body?: InlineObject34, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesIsFormedGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/boxes/is_formed/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить несколько коробок сторкипером.   
         * @summary # Изменить несколько коробок сторкипером.
         * @param {InlineObject22} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesManyPatch: async (body?: InlineObject22, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/many`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Объединить две и более коробок.  Данный методод только для клиента Проверки: Все коробки должны быть от одного сторкипера, принадлежать одному клиенту, Тариф доставки должен принадлежать данному сторкиперу Провверки:  Все item-ы иметь одинаковый баркод Проверяем чтобы баркоды были проклеены у всех, иначе в новой коробке будет false.
         * @summary # Объединить две и более коробок.
         * @param {InlineObject24} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesMergePost: async (body?: InlineObject24, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [destinationId] GUID дестинейшна, который должен быть у боксов.
         * @param {boolean} [isFormed] Сформирована ли коробка
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [hasBatch] Должна ли коробка иметь свою партию
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [productGuid] 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesPagClientsLightGet: async (filters?: string, destinationId?: string, isFormed?: boolean, shopIds?: string, hasBatch?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', productGuid?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/pag/clients_light`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (destinationId !== undefined) {
                localVarQueryParameter['destinationId'] = destinationId;
            }

            if (isFormed !== undefined) {
                localVarQueryParameter['isFormed'] = isFormed;
            }

            if (shopIds !== undefined) {
                localVarQueryParameter['shopIds'] = shopIds;
            }

            if (hasBatch !== undefined) {
                localVarQueryParameter['hasBatch'] = hasBatch;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (productGuid !== undefined) {
                localVarQueryParameter['productGuid'] = productGuid;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать коробку и ее строки.  При создании коробка получает статус \"IN_STOCK\" ## Коробка состоит из шапки и строк (как накладная)  ## Коллекция Boxes содержит основные параметры коробки.  ## BoxesItems - коллекция которая содержит строки позиций в коробке.  У коробок есть еще такие параметры:         isActual - если false, то коробка удалена.         isDraft - если true, то коробка является черновиком. Его создал клиента при объеденении / разделении коробки         У клиента и у сотрудника склада их можно отфильтровать и обрабатывать в отдельном окне.         Сотрудник склада обработав позитивно изменение коробок от клиента просто ставит здесь (isDraft) false и коробка становится обычной.         Также у коробки созданной из других коробок заполнено поле parents. Это массив guid родительских коробок.         При отмене объединения коробок в базе по этим guid восстановим коробки isActual = true. А новые будут удалены isActual = false.         Также у коробки созданной при объединении/разделении будет заполнено поле brothers. Это guid других коробок которые были созданы вместе с этой из общих родителей.         Когда для любой из объединённых коробок будет запрошено удаление, восстановим старые коробки и кроме текущей коробки         будут удалены все ее братья.
         * @summary # Создать коробку и ее строки.
         * @param {InlineObject19} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesPost: async (body?: InlineObject19, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Изменить поле prepId
         * @summary # Изменить поле prepId
         * @param {Array<InlineObject>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesPrepIdPatch: async (body?: Array<InlineObject>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/prep_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Разделить коробку.   При разделении коробок странная сущность передается. Там массив массивов.Первый массив это          новые коробки - сколько элементов, столько и создаст коробок. Второй массив - это элементы в коробке.          В нем строки новой коробки. Фронт отвечает за то, что суммарное содержание новых коробок,          было ровно содержанию исходной коробки.
         * @summary # Разделить коробку.
         * @param {InlineObject26} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesSplitPost: async (body?: InlineObject26, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/split`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить коробку сотрудником склада.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
         * @summary # Изменить коробку сотрудником склада.
         * @param {string} guid 
         * @param {InlineObject29} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesStorekeepersGuidPatch: async (guid: string, body?: InlineObject29, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesStorekeepersGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/boxes/storekeepers/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить чекбоксы баркода.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
         * @summary # Изменить чекбоксы баркода.
         * @param {string} guid 
         * @param {InlineObject30} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesStorekeepersGuidSetItemsBarCodePatch: async (guid: string, body?: InlineObject30, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1BoxesStorekeepersGuidSetItemsBarCodePatch', 'guid', guid)
            const localVarPath = `/api/v1/boxes/storekeepers/{guid}/set_itemsBarCode`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить коробки по текущему сторкипера отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
         * @summary # Получить коробки по текущему сторкипера отправленные в партию.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesStorekeepersSentToBatchGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/storekeepers/sent_to_batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## делать из нескольких боксов один супербокс
         * @summary # Сделать из нескольких боксов один супербокс
         * @param {InlineObject32} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesSuperboxRegroupPatch: async (body?: InlineObject32, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/boxes/superbox/regroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoxesApi - functional programming interface
 * @export
 */
export const BoxesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoxesApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Изменить дополнительную информацию коробки.
         * @summary # Изменить дополнительную информацию коробки.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject33} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesAdditionalInfoGuidPatch(guid: string, body?: InlineObject33, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesAdditionalInfoGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Подтвердить операцию объединения/разъединения коробок.  
         * @summary # Подтвердить операцию объединения/разъединения коробок.
         * @param {InlineObject28} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesApprovePost(body?: InlineObject28, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesApprovePost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## # Получить коробки и их строки по GUID заказа.   
         * @summary # Получить коробки и их строки по GUID заказа.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesByOrderGuidGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20016Rows>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesByOrderGuidGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesByProductGuidGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20016Rows>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesByProductGuidGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesByProductGuidLightGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20016Rows>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesByProductGuidLightGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отменить редактирование коробок.  
         * @summary # Отменить редактирование коробок.
         * @param {InlineObject23} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesCancelEditPost(body?: InlineObject23, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesCancelEditPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отменить редактирование коробок сотрудником склада.  
         * @summary # Отменить редактирование коробок сотрудником склада.
         * @param {string} guid GUID коробки, объединение которой нужно отменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesCancelEditWithDraftGuidPost(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesCancelEditWithDraftGuidPost(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отменить объединение коробок.  
         * @summary # Отменить объединение коробок.
         * @param {InlineObject25} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesCancelMergePost(body?: InlineObject25, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesCancelMergePost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отменить разделение коробок.   ## !!! У каждой коробки которая была создана разделением есть братья.    ## !!! Братья - коробки которые были созданы с этой, при разделении родителя.    ## !!! При отмене текущая коробка и все ee братья будут удалены. Родитель восстановлен.   
         * @summary # Отменить разделение коробок.
         * @param {InlineObject27} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesCancelSplitPost(body?: InlineObject27, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesCancelSplitPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить полей габаритов, массы коробки.
         * @summary # Изменить полей габаритов, массы коробки.
         * @param {string} guid GUID коробки.
         * @param {InlineObject31} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesChangeDimensionsGuidPatch(guid: string, body?: InlineObject31, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesChangeDimensionsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {string} status Статусы коробок разделенные запятой
         * @param {boolean} [hasBatch] Должна ли коробка иметь свою партию
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {string} [destinationId] GUID дестинейшна, который должен быть у боксов. Может быть null
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesClientsGet(status: string, hasBatch?: boolean, storekeeperId?: string, destinationId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20016Rows>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesClientsGet(status, hasBatch, storekeeperId, destinationId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отредактировать коробку клиентом  Клиент может отредактировать только свои коробки.  проверка на наличие склада назначения  проверка на наличие тарифа к сторкипера
         * @summary # Отредактировать коробку клиентом
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject21} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesClientsGuidPatch(guid: string, body?: InlineObject21, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesClientsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
         * @summary # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
         * @param {string} guid poroduct GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesClientsInTransferGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20020>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesClientsInTransferGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'} status 
         * @param {string} [shopId] Гуид магазина
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesClientsLightGet(status: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING', shopId?: string, storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20019>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesClientsLightGet(status, shopId, storekeeperId, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [onAmazon] On Amazon
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesClientsProductInBatchGuidGet(guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', onAmazon?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesClientsProductInBatchGuidGet(guid, filters, limit, offset, sortField, sortType, onAmazon, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки по текущему клиенту отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
         * @summary # Получить коробки по текущему клиенту отправленные в партию.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesClientsSentToBatchGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20023>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesClientsSentToBatchGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## ЭТО МЕТОД ИСОЛЬЗУЕТСЯ ДЛЯ ТАСКОВ  ## Отредактировать коробку. Коробка после редактирования станет черновиком. Ее нужно будет подтвердить  ## ВНИМАНИЕ - фактически будет создана новая коробка а старая пометится как удаленная.   ## ВНИМАНИЕ - передайте весь набор параметров как на создание новой коробки. Не только те которые нужно изменить.  
         * @summary # Отредактировать коробку. Сликом гибкий метод
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject20} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesEditGuidPost(guid: string, body?: InlineObject20, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesEditGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки их строки.   
         * @summary # Получить коробки и их строки.
         * @param {string} [filters]                Возможные поля: humanFriendlyId, asin, sku_by_client, amazon_title,               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesGet(filters, limit, offset, sortField, sortType, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить сгруппированные коробки
         * @summary # Получить сгруппированные коробки
         * @param {string} [additionalGroupParameter]                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
         * @param {number} [limit] Сколько вернуть полей
         * @param {number} [offset] Сколько отступить от начала полей
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesGroupedGet(additionalGroupParameter?: string, limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesGroupedGet(additionalGroupParameter, limit, offset, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить группы
         * @summary # Получить группы
         * @param {string} [additionalGroupParameter]                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
         * @param {number} [limit] Сколько вернуть полей
         * @param {number} [offset] Сколько отступить от начала полей
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesGroupedGroupsGet(additionalGroupParameter?: string, limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesGroupedGroupsGet(additionalGroupParameter, limit, offset, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить похожие коробки  
         * @summary # Получить похожие коробки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesGroupedSimilarGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20018>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesGroupedSimilarGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить данные коробки по GUID.   
         * @summary # Получить данные коробки по GUID.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Изменить поле isFormed
         * @summary # Изменить поле isFormed
         * @param {string} guid GUID коробки.
         * @param {InlineObject34} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesIsFormedGuidPatch(guid: string, body?: InlineObject34, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesIsFormedGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить несколько коробок сторкипером.   
         * @summary # Изменить несколько коробок сторкипером.
         * @param {InlineObject22} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesManyPatch(body?: InlineObject22, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesManyPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Объединить две и более коробок.  Данный методод только для клиента Проверки: Все коробки должны быть от одного сторкипера, принадлежать одному клиенту, Тариф доставки должен принадлежать данному сторкиперу Провверки:  Все item-ы иметь одинаковый баркод Проверяем чтобы баркоды были проклеены у всех, иначе в новой коробке будет false.
         * @summary # Объединить две и более коробок.
         * @param {InlineObject24} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesMergePost(body?: InlineObject24, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesMergePost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [destinationId] GUID дестинейшна, который должен быть у боксов.
         * @param {boolean} [isFormed] Сформирована ли коробка
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [hasBatch] Должна ли коробка иметь свою партию
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [productGuid] 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesPagClientsLightGet(filters?: string, destinationId?: string, isFormed?: boolean, shopIds?: string, hasBatch?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', productGuid?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesPagClientsLightGet(filters, destinationId, isFormed, shopIds, hasBatch, limit, offset, sortField, sortType, productGuid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать коробку и ее строки.  При создании коробка получает статус \"IN_STOCK\" ## Коробка состоит из шапки и строк (как накладная)  ## Коллекция Boxes содержит основные параметры коробки.  ## BoxesItems - коллекция которая содержит строки позиций в коробке.  У коробок есть еще такие параметры:         isActual - если false, то коробка удалена.         isDraft - если true, то коробка является черновиком. Его создал клиента при объеденении / разделении коробки         У клиента и у сотрудника склада их можно отфильтровать и обрабатывать в отдельном окне.         Сотрудник склада обработав позитивно изменение коробок от клиента просто ставит здесь (isDraft) false и коробка становится обычной.         Также у коробки созданной из других коробок заполнено поле parents. Это массив guid родительских коробок.         При отмене объединения коробок в базе по этим guid восстановим коробки isActual = true. А новые будут удалены isActual = false.         Также у коробки созданной при объединении/разделении будет заполнено поле brothers. Это guid других коробок которые были созданы вместе с этой из общих родителей.         Когда для любой из объединённых коробок будет запрошено удаление, восстановим старые коробки и кроме текущей коробки         будут удалены все ее братья.
         * @summary # Создать коробку и ее строки.
         * @param {InlineObject19} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesPost(body?: InlineObject19, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Изменить поле prepId
         * @summary # Изменить поле prepId
         * @param {Array<InlineObject>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesPrepIdPatch(body?: Array<InlineObject>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesPrepIdPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Разделить коробку.   При разделении коробок странная сущность передается. Там массив массивов.Первый массив это          новые коробки - сколько элементов, столько и создаст коробок. Второй массив - это элементы в коробке.          В нем строки новой коробки. Фронт отвечает за то, что суммарное содержание новых коробок,          было ровно содержанию исходной коробки.
         * @summary # Разделить коробку.
         * @param {InlineObject26} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesSplitPost(body?: InlineObject26, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesSplitPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить коробку сотрудником склада.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
         * @summary # Изменить коробку сотрудником склада.
         * @param {string} guid 
         * @param {InlineObject29} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesStorekeepersGuidPatch(guid: string, body?: InlineObject29, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesStorekeepersGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить чекбоксы баркода.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
         * @summary # Изменить чекбоксы баркода.
         * @param {string} guid 
         * @param {InlineObject30} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesStorekeepersGuidSetItemsBarCodePatch(guid: string, body?: InlineObject30, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesStorekeepersGuidSetItemsBarCodePatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить коробки по текущему сторкипера отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
         * @summary # Получить коробки по текущему сторкипера отправленные в партию.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesStorekeepersSentToBatchGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20023>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesStorekeepersSentToBatchGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## делать из нескольких боксов один супербокс
         * @summary # Сделать из нескольких боксов один супербокс
         * @param {InlineObject32} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BoxesSuperboxRegroupPatch(body?: InlineObject32, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BoxesSuperboxRegroupPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoxesApi - factory interface
 * @export
 */
export const BoxesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoxesApiFp(configuration)
    return {
        /**
         * ## Изменить дополнительную информацию коробки.
         * @summary # Изменить дополнительную информацию коробки.
         * @param {string} guid GUID тарифа.
         * @param {InlineObject33} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesAdditionalInfoGuidPatch(guid: string, body?: InlineObject33, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesAdditionalInfoGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Подтвердить операцию объединения/разъединения коробок.  
         * @summary # Подтвердить операцию объединения/разъединения коробок.
         * @param {InlineObject28} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesApprovePost(body?: InlineObject28, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesApprovePost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## # Получить коробки и их строки по GUID заказа.   
         * @summary # Получить коробки и их строки по GUID заказа.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesByOrderGuidGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20016Rows>> {
            return localVarFp.apiV1BoxesByOrderGuidGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesByProductGuidGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20016Rows>> {
            return localVarFp.apiV1BoxesByProductGuidGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesByProductGuidLightGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20016Rows>> {
            return localVarFp.apiV1BoxesByProductGuidLightGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отменить редактирование коробок.  
         * @summary # Отменить редактирование коробок.
         * @param {InlineObject23} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelEditPost(body?: InlineObject23, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesCancelEditPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отменить редактирование коробок сотрудником склада.  
         * @summary # Отменить редактирование коробок сотрудником склада.
         * @param {string} guid GUID коробки, объединение которой нужно отменить
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelEditWithDraftGuidPost(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesCancelEditWithDraftGuidPost(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отменить объединение коробок.  
         * @summary # Отменить объединение коробок.
         * @param {InlineObject25} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelMergePost(body?: InlineObject25, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesCancelMergePost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отменить разделение коробок.   ## !!! У каждой коробки которая была создана разделением есть братья.    ## !!! Братья - коробки которые были созданы с этой, при разделении родителя.    ## !!! При отмене текущая коробка и все ee братья будут удалены. Родитель восстановлен.   
         * @summary # Отменить разделение коробок.
         * @param {InlineObject27} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesCancelSplitPost(body?: InlineObject27, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesCancelSplitPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить полей габаритов, массы коробки.
         * @summary # Изменить полей габаритов, массы коробки.
         * @param {string} guid GUID коробки.
         * @param {InlineObject31} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesChangeDimensionsGuidPatch(guid: string, body?: InlineObject31, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesChangeDimensionsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {string} status Статусы коробок разделенные запятой
         * @param {boolean} [hasBatch] Должна ли коробка иметь свою партию
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {string} [destinationId] GUID дестинейшна, который должен быть у боксов. Может быть null
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsGet(status: string, hasBatch?: boolean, storekeeperId?: string, destinationId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20016Rows>> {
            return localVarFp.apiV1BoxesClientsGet(status, hasBatch, storekeeperId, destinationId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отредактировать коробку клиентом  Клиент может отредактировать только свои коробки.  проверка на наличие склада назначения  проверка на наличие тарифа к сторкипера
         * @summary # Отредактировать коробку клиентом
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject21} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsGuidPatch(guid: string, body?: InlineObject21, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.apiV1BoxesClientsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
         * @summary # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
         * @param {string} guid poroduct GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsInTransferGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20020>> {
            return localVarFp.apiV1BoxesClientsInTransferGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'} status 
         * @param {string} [shopId] Гуид магазина
         * @param {string} [storekeeperId] GUID склада который нужно получить.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsLightGet(status: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING', shopId?: string, storekeeperId?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20019>> {
            return localVarFp.apiV1BoxesClientsLightGet(status, shopId, storekeeperId, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки и их строки по GUID продукта.   
         * @summary # Получить коробки и их строки по GUID продукта.
         * @param {string} guid GUID
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [onAmazon] On Amazon
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsProductInBatchGuidGet(guid: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', onAmazon?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.apiV1BoxesClientsProductInBatchGuidGet(guid, filters, limit, offset, sortField, sortType, onAmazon, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки по текущему клиенту отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
         * @summary # Получить коробки по текущему клиенту отправленные в партию.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesClientsSentToBatchGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20023>> {
            return localVarFp.apiV1BoxesClientsSentToBatchGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## ЭТО МЕТОД ИСОЛЬЗУЕТСЯ ДЛЯ ТАСКОВ  ## Отредактировать коробку. Коробка после редактирования станет черновиком. Ее нужно будет подтвердить  ## ВНИМАНИЕ - фактически будет создана новая коробка а старая пометится как удаленная.   ## ВНИМАНИЕ - передайте весь набор параметров как на создание новой коробки. Не только те которые нужно изменить.  
         * @summary # Отредактировать коробку. Сликом гибкий метод
         * @param {string} guid GUID в сущности в БД
         * @param {InlineObject20} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesEditGuidPost(guid: string, body?: InlineObject20, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.apiV1BoxesEditGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки их строки.   
         * @summary # Получить коробки и их строки.
         * @param {string} [filters]                Возможные поля: humanFriendlyId, asin, sku_by_client, amazon_title,               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.apiV1BoxesGet(filters, limit, offset, sortField, sortType, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить сгруппированные коробки
         * @summary # Получить сгруппированные коробки
         * @param {string} [additionalGroupParameter]                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
         * @param {number} [limit] Сколько вернуть полей
         * @param {number} [offset] Сколько отступить от начала полей
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGroupedGet(additionalGroupParameter?: string, limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.apiV1BoxesGroupedGet(additionalGroupParameter, limit, offset, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить группы
         * @summary # Получить группы
         * @param {string} [additionalGroupParameter]                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
         * @param {number} [limit] Сколько вернуть полей
         * @param {number} [offset] Сколько отступить от начала полей
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGroupedGroupsGet(additionalGroupParameter?: string, limit?: number, offset?: number, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.apiV1BoxesGroupedGroupsGet(additionalGroupParameter, limit, offset, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить похожие коробки  
         * @summary # Получить похожие коробки
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGroupedSimilarGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20018>> {
            return localVarFp.apiV1BoxesGroupedSimilarGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить данные коробки по GUID.   
         * @summary # Получить данные коробки по GUID.
         * @param {string} guid GUID
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.apiV1BoxesGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Изменить поле isFormed
         * @summary # Изменить поле isFormed
         * @param {string} guid GUID коробки.
         * @param {InlineObject34} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesIsFormedGuidPatch(guid: string, body?: InlineObject34, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesIsFormedGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить несколько коробок сторкипером.   
         * @summary # Изменить несколько коробок сторкипером.
         * @param {InlineObject22} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesManyPatch(body?: InlineObject22, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesManyPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Объединить две и более коробок.  Данный методод только для клиента Проверки: Все коробки должны быть от одного сторкипера, принадлежать одному клиенту, Тариф доставки должен принадлежать данному сторкиперу Провверки:  Все item-ы иметь одинаковый баркод Проверяем чтобы баркоды были проклеены у всех, иначе в новой коробке будет false.
         * @summary # Объединить две и более коробок.
         * @param {InlineObject24} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesMergePost(body?: InlineObject24, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.apiV1BoxesMergePost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
         * @summary # Получить коробки и их строки по текущему клиенту.
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {string} [destinationId] GUID дестинейшна, который должен быть у боксов.
         * @param {boolean} [isFormed] Сформирована ли коробка
         * @param {string} [shopIds] Гуиды магазинов
         * @param {boolean} [hasBatch] Должна ли коробка иметь свою партию
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {string} [productGuid] 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesPagClientsLightGet(filters?: string, destinationId?: string, isFormed?: boolean, shopIds?: string, hasBatch?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', productGuid?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.apiV1BoxesPagClientsLightGet(filters, destinationId, isFormed, shopIds, hasBatch, limit, offset, sortField, sortType, productGuid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать коробку и ее строки.  При создании коробка получает статус \"IN_STOCK\" ## Коробка состоит из шапки и строк (как накладная)  ## Коллекция Boxes содержит основные параметры коробки.  ## BoxesItems - коллекция которая содержит строки позиций в коробке.  У коробок есть еще такие параметры:         isActual - если false, то коробка удалена.         isDraft - если true, то коробка является черновиком. Его создал клиента при объеденении / разделении коробки         У клиента и у сотрудника склада их можно отфильтровать и обрабатывать в отдельном окне.         Сотрудник склада обработав позитивно изменение коробок от клиента просто ставит здесь (isDraft) false и коробка становится обычной.         Также у коробки созданной из других коробок заполнено поле parents. Это массив guid родительских коробок.         При отмене объединения коробок в базе по этим guid восстановим коробки isActual = true. А новые будут удалены isActual = false.         Также у коробки созданной при объединении/разделении будет заполнено поле brothers. Это guid других коробок которые были созданы вместе с этой из общих родителей.         Когда для любой из объединённых коробок будет запрошено удаление, восстановим старые коробки и кроме текущей коробки         будут удалены все ее братья.
         * @summary # Создать коробку и ее строки.
         * @param {InlineObject19} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesPost(body?: InlineObject19, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.apiV1BoxesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * # Изменить поле prepId
         * @summary # Изменить поле prepId
         * @param {Array<InlineObject>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesPrepIdPatch(body?: Array<InlineObject>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesPrepIdPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Разделить коробку.   При разделении коробок странная сущность передается. Там массив массивов.Первый массив это          новые коробки - сколько элементов, столько и создаст коробок. Второй массив - это элементы в коробке.          В нем строки новой коробки. Фронт отвечает за то, что суммарное содержание новых коробок,          было ровно содержанию исходной коробки.
         * @summary # Разделить коробку.
         * @param {InlineObject26} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesSplitPost(body?: InlineObject26, acceptEncoding?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiV1BoxesSplitPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить коробку сотрудником склада.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
         * @summary # Изменить коробку сотрудником склада.
         * @param {string} guid 
         * @param {InlineObject29} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesStorekeepersGuidPatch(guid: string, body?: InlineObject29, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesStorekeepersGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить чекбоксы баркода.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
         * @summary # Изменить чекбоксы баркода.
         * @param {string} guid 
         * @param {InlineObject30} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesStorekeepersGuidSetItemsBarCodePatch(guid: string, body?: InlineObject30, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1BoxesStorekeepersGuidSetItemsBarCodePatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить коробки по текущему сторкипера отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
         * @summary # Получить коробки по текущему сторкипера отправленные в партию.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesStorekeepersSentToBatchGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20023>> {
            return localVarFp.apiV1BoxesStorekeepersSentToBatchGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## делать из нескольких боксов один супербокс
         * @summary # Сделать из нескольких боксов один супербокс
         * @param {InlineObject32} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BoxesSuperboxRegroupPatch(body?: InlineObject32, acceptEncoding?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiV1BoxesSuperboxRegroupPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1BoxesAdditionalInfoGuidPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesAdditionalInfoGuidPatchRequest
 */
export interface BoxesApiApiV1BoxesAdditionalInfoGuidPatchRequest {
    /**
     * GUID тарифа.
     * @type {string}
     * @memberof BoxesApiApiV1BoxesAdditionalInfoGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject33}
     * @memberof BoxesApiApiV1BoxesAdditionalInfoGuidPatch
     */
    readonly body?: InlineObject33

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesAdditionalInfoGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesApprovePost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesApprovePostRequest
 */
export interface BoxesApiApiV1BoxesApprovePostRequest {
    /**
     * 
     * @type {InlineObject28}
     * @memberof BoxesApiApiV1BoxesApprovePost
     */
    readonly body?: InlineObject28

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesApprovePost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesByOrderGuidGuidGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesByOrderGuidGuidGetRequest
 */
export interface BoxesApiApiV1BoxesByOrderGuidGuidGetRequest {
    /**
     * GUID
     * @type {string}
     * @memberof BoxesApiApiV1BoxesByOrderGuidGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesByOrderGuidGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesByProductGuidGuidGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesByProductGuidGuidGetRequest
 */
export interface BoxesApiApiV1BoxesByProductGuidGuidGetRequest {
    /**
     * GUID
     * @type {string}
     * @memberof BoxesApiApiV1BoxesByProductGuidGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesByProductGuidGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesByProductGuidLightGuidGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesByProductGuidLightGuidGetRequest
 */
export interface BoxesApiApiV1BoxesByProductGuidLightGuidGetRequest {
    /**
     * GUID
     * @type {string}
     * @memberof BoxesApiApiV1BoxesByProductGuidLightGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesByProductGuidLightGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesCancelEditPost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesCancelEditPostRequest
 */
export interface BoxesApiApiV1BoxesCancelEditPostRequest {
    /**
     * 
     * @type {InlineObject23}
     * @memberof BoxesApiApiV1BoxesCancelEditPost
     */
    readonly body?: InlineObject23

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesCancelEditPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesCancelEditWithDraftGuidPost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesCancelEditWithDraftGuidPostRequest
 */
export interface BoxesApiApiV1BoxesCancelEditWithDraftGuidPostRequest {
    /**
     * GUID коробки, объединение которой нужно отменить
     * @type {string}
     * @memberof BoxesApiApiV1BoxesCancelEditWithDraftGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesCancelEditWithDraftGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesCancelMergePost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesCancelMergePostRequest
 */
export interface BoxesApiApiV1BoxesCancelMergePostRequest {
    /**
     * 
     * @type {InlineObject25}
     * @memberof BoxesApiApiV1BoxesCancelMergePost
     */
    readonly body?: InlineObject25

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesCancelMergePost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesCancelSplitPost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesCancelSplitPostRequest
 */
export interface BoxesApiApiV1BoxesCancelSplitPostRequest {
    /**
     * 
     * @type {InlineObject27}
     * @memberof BoxesApiApiV1BoxesCancelSplitPost
     */
    readonly body?: InlineObject27

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesCancelSplitPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesChangeDimensionsGuidPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesChangeDimensionsGuidPatchRequest
 */
export interface BoxesApiApiV1BoxesChangeDimensionsGuidPatchRequest {
    /**
     * GUID коробки.
     * @type {string}
     * @memberof BoxesApiApiV1BoxesChangeDimensionsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject31}
     * @memberof BoxesApiApiV1BoxesChangeDimensionsGuidPatch
     */
    readonly body?: InlineObject31

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesChangeDimensionsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesClientsGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesClientsGetRequest
 */
export interface BoxesApiApiV1BoxesClientsGetRequest {
    /**
     * Статусы коробок разделенные запятой
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsGet
     */
    readonly status: string

    /**
     * Должна ли коробка иметь свою партию
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesClientsGet
     */
    readonly hasBatch?: boolean

    /**
     * GUID склада который нужно получить.
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsGet
     */
    readonly storekeeperId?: string

    /**
     * GUID дестинейшна, который должен быть у боксов. Может быть null
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsGet
     */
    readonly destinationId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesClientsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesClientsGuidPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesClientsGuidPatchRequest
 */
export interface BoxesApiApiV1BoxesClientsGuidPatchRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject21}
     * @memberof BoxesApiApiV1BoxesClientsGuidPatch
     */
    readonly body?: InlineObject21

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesClientsInTransferGuidGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesClientsInTransferGuidGetRequest
 */
export interface BoxesApiApiV1BoxesClientsInTransferGuidGetRequest {
    /**
     * poroduct GUID
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsInTransferGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsInTransferGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesClientsLightGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesClientsLightGetRequest
 */
export interface BoxesApiApiV1BoxesClientsLightGetRequest {
    /**
     * 
     * @type {'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'}
     * @memberof BoxesApiApiV1BoxesClientsLightGet
     */
    readonly status: 'NEW' | 'IN_STOCK' | 'REQUESTED_SEND_TO_BATCH' | 'NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE' | 'IN_BATCH' | 'NEED_TO_UPDATE_THE_TARIFF' | 'IN_BATCH_ON_THE_WAY' | 'FINISH_PREP_CENTR_USA' | 'ACCEPTED_IN_PROCESSING'

    /**
     * Гуид магазина
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsLightGet
     */
    readonly shopId?: string

    /**
     * GUID склада который нужно получить.
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsLightGet
     */
    readonly storekeeperId?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesClientsLightGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsLightGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesClientsProductInBatchGuidGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesClientsProductInBatchGuidGetRequest
 */
export interface BoxesApiApiV1BoxesClientsProductInBatchGuidGetRequest {
    /**
     * GUID
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly guid: string

    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * On Amazon
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly onAmazon?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsProductInBatchGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesClientsSentToBatchGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesClientsSentToBatchGetRequest
 */
export interface BoxesApiApiV1BoxesClientsSentToBatchGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesClientsSentToBatchGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesEditGuidPost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesEditGuidPostRequest
 */
export interface BoxesApiApiV1BoxesEditGuidPostRequest {
    /**
     * GUID в сущности в БД
     * @type {string}
     * @memberof BoxesApiApiV1BoxesEditGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject20}
     * @memberof BoxesApiApiV1BoxesEditGuidPost
     */
    readonly body?: InlineObject20

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesEditGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesGetRequest
 */
export interface BoxesApiApiV1BoxesGetRequest {
    /**
     *                Возможные поля: humanFriendlyId, asin, sku_by_client, amazon_title,               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BoxesApiApiV1BoxesGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BoxesApiApiV1BoxesGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BoxesApiApiV1BoxesGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesGroupedGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesGroupedGetRequest
 */
export interface BoxesApiApiV1BoxesGroupedGetRequest {
    /**
     *                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGroupedGet
     */
    readonly additionalGroupParameter?: string

    /**
     * Сколько вернуть полей
     * @type {number}
     * @memberof BoxesApiApiV1BoxesGroupedGet
     */
    readonly limit?: number

    /**
     * Сколько отступить от начала полей
     * @type {number}
     * @memberof BoxesApiApiV1BoxesGroupedGet
     */
    readonly offset?: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesGroupedGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGroupedGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesGroupedGroupsGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesGroupedGroupsGetRequest
 */
export interface BoxesApiApiV1BoxesGroupedGroupsGetRequest {
    /**
     *                Пример: /boxes/grouped?fields&#x3D;orderId,logicsTariffId,destinationId,amount             
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGroupedGroupsGet
     */
    readonly additionalGroupParameter?: string

    /**
     * Сколько вернуть полей
     * @type {number}
     * @memberof BoxesApiApiV1BoxesGroupedGroupsGet
     */
    readonly limit?: number

    /**
     * Сколько отступить от начала полей
     * @type {number}
     * @memberof BoxesApiApiV1BoxesGroupedGroupsGet
     */
    readonly offset?: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesGroupedGroupsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGroupedGroupsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesGroupedSimilarGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesGroupedSimilarGetRequest
 */
export interface BoxesApiApiV1BoxesGroupedSimilarGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGroupedSimilarGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesGuidGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesGuidGetRequest
 */
export interface BoxesApiApiV1BoxesGuidGetRequest {
    /**
     * GUID
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesIsFormedGuidPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesIsFormedGuidPatchRequest
 */
export interface BoxesApiApiV1BoxesIsFormedGuidPatchRequest {
    /**
     * GUID коробки.
     * @type {string}
     * @memberof BoxesApiApiV1BoxesIsFormedGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject34}
     * @memberof BoxesApiApiV1BoxesIsFormedGuidPatch
     */
    readonly body?: InlineObject34

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesIsFormedGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesManyPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesManyPatchRequest
 */
export interface BoxesApiApiV1BoxesManyPatchRequest {
    /**
     * 
     * @type {InlineObject22}
     * @memberof BoxesApiApiV1BoxesManyPatch
     */
    readonly body?: InlineObject22

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesManyPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesMergePost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesMergePostRequest
 */
export interface BoxesApiApiV1BoxesMergePostRequest {
    /**
     * 
     * @type {InlineObject24}
     * @memberof BoxesApiApiV1BoxesMergePost
     */
    readonly body?: InlineObject24

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesMergePost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesPagClientsLightGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesPagClientsLightGetRequest
 */
export interface BoxesApiApiV1BoxesPagClientsLightGetRequest {
    /**
     *                Возможные поля: asin, amazonTitle, title, humanFriendlyId, orderHumanFriendlyId, orderItem               Поиск для полей продукта идет через схему Коробка -&gt; Айтем коробки -&gt; Продукт               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly filters?: string

    /**
     * GUID дестинейшна, который должен быть у боксов.
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly destinationId?: string

    /**
     * Сформирована ли коробка
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly isFormed?: boolean

    /**
     * Гуиды магазинов
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly shopIds?: string

    /**
     * Должна ли коробка иметь свою партию
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly hasBatch?: boolean

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly productGuid?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPagClientsLightGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesPost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesPostRequest
 */
export interface BoxesApiApiV1BoxesPostRequest {
    /**
     * 
     * @type {InlineObject19}
     * @memberof BoxesApiApiV1BoxesPost
     */
    readonly body?: InlineObject19

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesPrepIdPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesPrepIdPatchRequest
 */
export interface BoxesApiApiV1BoxesPrepIdPatchRequest {
    /**
     * 
     * @type {Array<InlineObject>}
     * @memberof BoxesApiApiV1BoxesPrepIdPatch
     */
    readonly body?: Array<InlineObject>

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesPrepIdPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesSplitPost operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesSplitPostRequest
 */
export interface BoxesApiApiV1BoxesSplitPostRequest {
    /**
     * 
     * @type {InlineObject26}
     * @memberof BoxesApiApiV1BoxesSplitPost
     */
    readonly body?: InlineObject26

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesSplitPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesStorekeepersGuidPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesStorekeepersGuidPatchRequest
 */
export interface BoxesApiApiV1BoxesStorekeepersGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesStorekeepersGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject29}
     * @memberof BoxesApiApiV1BoxesStorekeepersGuidPatch
     */
    readonly body?: InlineObject29

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesStorekeepersGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesStorekeepersGuidSetItemsBarCodePatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatchRequest
 */
export interface BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject30}
     * @memberof BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatch
     */
    readonly body?: InlineObject30

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesStorekeepersSentToBatchGet operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesStorekeepersSentToBatchGetRequest
 */
export interface BoxesApiApiV1BoxesStorekeepersSentToBatchGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesStorekeepersSentToBatchGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1BoxesSuperboxRegroupPatch operation in BoxesApi.
 * @export
 * @interface BoxesApiApiV1BoxesSuperboxRegroupPatchRequest
 */
export interface BoxesApiApiV1BoxesSuperboxRegroupPatchRequest {
    /**
     * 
     * @type {InlineObject32}
     * @memberof BoxesApiApiV1BoxesSuperboxRegroupPatch
     */
    readonly body?: InlineObject32

    /**
     * 
     * @type {string}
     * @memberof BoxesApiApiV1BoxesSuperboxRegroupPatch
     */
    readonly acceptEncoding?: string
}

/**
 * BoxesApi - object-oriented interface
 * @export
 * @class BoxesApi
 * @extends {BaseAPI}
 */
export class BoxesApi extends BaseAPI {
    /**
     * ## Изменить дополнительную информацию коробки.
     * @summary # Изменить дополнительную информацию коробки.
     * @param {BoxesApiApiV1BoxesAdditionalInfoGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesAdditionalInfoGuidPatch(requestParameters: BoxesApiApiV1BoxesAdditionalInfoGuidPatchRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesAdditionalInfoGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Подтвердить операцию объединения/разъединения коробок.  
     * @summary # Подтвердить операцию объединения/разъединения коробок.
     * @param {BoxesApiApiV1BoxesApprovePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesApprovePost(requestParameters: BoxesApiApiV1BoxesApprovePostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesApprovePost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## # Получить коробки и их строки по GUID заказа.   
     * @summary # Получить коробки и их строки по GUID заказа.
     * @param {BoxesApiApiV1BoxesByOrderGuidGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesByOrderGuidGuidGet(requestParameters: BoxesApiApiV1BoxesByOrderGuidGuidGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesByOrderGuidGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки и их строки по GUID продукта.   
     * @summary # Получить коробки и их строки по GUID продукта.
     * @param {BoxesApiApiV1BoxesByProductGuidGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesByProductGuidGuidGet(requestParameters: BoxesApiApiV1BoxesByProductGuidGuidGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesByProductGuidGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки и их строки по GUID продукта.   
     * @summary # Получить коробки и их строки по GUID продукта.
     * @param {BoxesApiApiV1BoxesByProductGuidLightGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesByProductGuidLightGuidGet(requestParameters: BoxesApiApiV1BoxesByProductGuidLightGuidGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesByProductGuidLightGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отменить редактирование коробок.  
     * @summary # Отменить редактирование коробок.
     * @param {BoxesApiApiV1BoxesCancelEditPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesCancelEditPost(requestParameters: BoxesApiApiV1BoxesCancelEditPostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesCancelEditPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отменить редактирование коробок сотрудником склада.  
     * @summary # Отменить редактирование коробок сотрудником склада.
     * @param {BoxesApiApiV1BoxesCancelEditWithDraftGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesCancelEditWithDraftGuidPost(requestParameters: BoxesApiApiV1BoxesCancelEditWithDraftGuidPostRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesCancelEditWithDraftGuidPost(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отменить объединение коробок.  
     * @summary # Отменить объединение коробок.
     * @param {BoxesApiApiV1BoxesCancelMergePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesCancelMergePost(requestParameters: BoxesApiApiV1BoxesCancelMergePostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesCancelMergePost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отменить разделение коробок.   ## !!! У каждой коробки которая была создана разделением есть братья.    ## !!! Братья - коробки которые были созданы с этой, при разделении родителя.    ## !!! При отмене текущая коробка и все ee братья будут удалены. Родитель восстановлен.   
     * @summary # Отменить разделение коробок.
     * @param {BoxesApiApiV1BoxesCancelSplitPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesCancelSplitPost(requestParameters: BoxesApiApiV1BoxesCancelSplitPostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesCancelSplitPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить полей габаритов, массы коробки.
     * @summary # Изменить полей габаритов, массы коробки.
     * @param {BoxesApiApiV1BoxesChangeDimensionsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesChangeDimensionsGuidPatch(requestParameters: BoxesApiApiV1BoxesChangeDimensionsGuidPatchRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesChangeDimensionsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
     * @summary # Получить коробки и их строки по текущему клиенту.
     * @param {BoxesApiApiV1BoxesClientsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesClientsGet(requestParameters: BoxesApiApiV1BoxesClientsGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesClientsGet(requestParameters.status, requestParameters.hasBatch, requestParameters.storekeeperId, requestParameters.destinationId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отредактировать коробку клиентом  Клиент может отредактировать только свои коробки.  проверка на наличие склада назначения  проверка на наличие тарифа к сторкипера
     * @summary # Отредактировать коробку клиентом
     * @param {BoxesApiApiV1BoxesClientsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesClientsGuidPatch(requestParameters: BoxesApiApiV1BoxesClientsGuidPatchRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesClientsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
     * @summary # Получить коробки  в статусах “REQUESTED_SEND_TO_BATCH“, “In Batch“, “In Batch on the way”, \"NEED_CONFIRMING_TO_DELIVERY_PRICE_CHANGE\", “NEED_TO_UPDATE_THE_TARIFF“, с фильтрацией по продукту
     * @param {BoxesApiApiV1BoxesClientsInTransferGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesClientsInTransferGuidGet(requestParameters: BoxesApiApiV1BoxesClientsInTransferGuidGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesClientsInTransferGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
     * @summary # Получить коробки и их строки по текущему клиенту.
     * @param {BoxesApiApiV1BoxesClientsLightGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesClientsLightGet(requestParameters: BoxesApiApiV1BoxesClientsLightGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesClientsLightGet(requestParameters.status, requestParameters.shopId, requestParameters.storekeeperId, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки и их строки по GUID продукта.   
     * @summary # Получить коробки и их строки по GUID продукта.
     * @param {BoxesApiApiV1BoxesClientsProductInBatchGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesClientsProductInBatchGuidGet(requestParameters: BoxesApiApiV1BoxesClientsProductInBatchGuidGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesClientsProductInBatchGuidGet(requestParameters.guid, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.onAmazon, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки по текущему клиенту отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
     * @summary # Получить коробки по текущему клиенту отправленные в партию.
     * @param {BoxesApiApiV1BoxesClientsSentToBatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesClientsSentToBatchGet(requestParameters: BoxesApiApiV1BoxesClientsSentToBatchGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesClientsSentToBatchGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## ЭТО МЕТОД ИСОЛЬЗУЕТСЯ ДЛЯ ТАСКОВ  ## Отредактировать коробку. Коробка после редактирования станет черновиком. Ее нужно будет подтвердить  ## ВНИМАНИЕ - фактически будет создана новая коробка а старая пометится как удаленная.   ## ВНИМАНИЕ - передайте весь набор параметров как на создание новой коробки. Не только те которые нужно изменить.  
     * @summary # Отредактировать коробку. Сликом гибкий метод
     * @param {BoxesApiApiV1BoxesEditGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesEditGuidPost(requestParameters: BoxesApiApiV1BoxesEditGuidPostRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesEditGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки их строки.   
     * @summary # Получить коробки и их строки.
     * @param {BoxesApiApiV1BoxesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesGet(requestParameters: BoxesApiApiV1BoxesGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить сгруппированные коробки
     * @summary # Получить сгруппированные коробки
     * @param {BoxesApiApiV1BoxesGroupedGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesGroupedGet(requestParameters: BoxesApiApiV1BoxesGroupedGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesGroupedGet(requestParameters.additionalGroupParameter, requestParameters.limit, requestParameters.offset, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить группы
     * @summary # Получить группы
     * @param {BoxesApiApiV1BoxesGroupedGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesGroupedGroupsGet(requestParameters: BoxesApiApiV1BoxesGroupedGroupsGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesGroupedGroupsGet(requestParameters.additionalGroupParameter, requestParameters.limit, requestParameters.offset, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить похожие коробки  
     * @summary # Получить похожие коробки
     * @param {BoxesApiApiV1BoxesGroupedSimilarGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesGroupedSimilarGet(requestParameters: BoxesApiApiV1BoxesGroupedSimilarGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesGroupedSimilarGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить данные коробки по GUID.   
     * @summary # Получить данные коробки по GUID.
     * @param {BoxesApiApiV1BoxesGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesGuidGet(requestParameters: BoxesApiApiV1BoxesGuidGetRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Изменить поле isFormed
     * @summary # Изменить поле isFormed
     * @param {BoxesApiApiV1BoxesIsFormedGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesIsFormedGuidPatch(requestParameters: BoxesApiApiV1BoxesIsFormedGuidPatchRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesIsFormedGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить несколько коробок сторкипером.   
     * @summary # Изменить несколько коробок сторкипером.
     * @param {BoxesApiApiV1BoxesManyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesManyPatch(requestParameters: BoxesApiApiV1BoxesManyPatchRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesManyPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Объединить две и более коробок.  Данный методод только для клиента Проверки: Все коробки должны быть от одного сторкипера, принадлежать одному клиенту, Тариф доставки должен принадлежать данному сторкиперу Провверки:  Все item-ы иметь одинаковый баркод Проверяем чтобы баркоды были проклеены у всех, иначе в новой коробке будет false.
     * @summary # Объединить две и более коробок.
     * @param {BoxesApiApiV1BoxesMergePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesMergePost(requestParameters: BoxesApiApiV1BoxesMergePostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesMergePost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки(без черновиков) и их строки по текущему клиенту. (Без отправленных в партию)  ## GUID клиента получаем из токена.   По статусу коробок
     * @summary # Получить коробки и их строки по текущему клиенту.
     * @param {BoxesApiApiV1BoxesPagClientsLightGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesPagClientsLightGet(requestParameters: BoxesApiApiV1BoxesPagClientsLightGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesPagClientsLightGet(requestParameters.filters, requestParameters.destinationId, requestParameters.isFormed, requestParameters.shopIds, requestParameters.hasBatch, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.productGuid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать коробку и ее строки.  При создании коробка получает статус \"IN_STOCK\" ## Коробка состоит из шапки и строк (как накладная)  ## Коллекция Boxes содержит основные параметры коробки.  ## BoxesItems - коллекция которая содержит строки позиций в коробке.  У коробок есть еще такие параметры:         isActual - если false, то коробка удалена.         isDraft - если true, то коробка является черновиком. Его создал клиента при объеденении / разделении коробки         У клиента и у сотрудника склада их можно отфильтровать и обрабатывать в отдельном окне.         Сотрудник склада обработав позитивно изменение коробок от клиента просто ставит здесь (isDraft) false и коробка становится обычной.         Также у коробки созданной из других коробок заполнено поле parents. Это массив guid родительских коробок.         При отмене объединения коробок в базе по этим guid восстановим коробки isActual = true. А новые будут удалены isActual = false.         Также у коробки созданной при объединении/разделении будет заполнено поле brothers. Это guid других коробок которые были созданы вместе с этой из общих родителей.         Когда для любой из объединённых коробок будет запрошено удаление, восстановим старые коробки и кроме текущей коробки         будут удалены все ее братья.
     * @summary # Создать коробку и ее строки.
     * @param {BoxesApiApiV1BoxesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesPost(requestParameters: BoxesApiApiV1BoxesPostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Изменить поле prepId
     * @summary # Изменить поле prepId
     * @param {BoxesApiApiV1BoxesPrepIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesPrepIdPatch(requestParameters: BoxesApiApiV1BoxesPrepIdPatchRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesPrepIdPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Разделить коробку.   При разделении коробок странная сущность передается. Там массив массивов.Первый массив это          новые коробки - сколько элементов, столько и создаст коробок. Второй массив - это элементы в коробке.          В нем строки новой коробки. Фронт отвечает за то, что суммарное содержание новых коробок,          было ровно содержанию исходной коробки.
     * @summary # Разделить коробку.
     * @param {BoxesApiApiV1BoxesSplitPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesSplitPost(requestParameters: BoxesApiApiV1BoxesSplitPostRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesSplitPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить коробку сотрудником склада.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
     * @summary # Изменить коробку сотрудником склада.
     * @param {BoxesApiApiV1BoxesStorekeepersGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesStorekeepersGuidPatch(requestParameters: BoxesApiApiV1BoxesStorekeepersGuidPatchRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesStorekeepersGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить чекбоксы баркода.   Сотрудник склада не может редактировать содержание коробки, но ему доступно для         редактирования параметры коробки.
     * @summary # Изменить чекбоксы баркода.
     * @param {BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesStorekeepersGuidSetItemsBarCodePatch(requestParameters: BoxesApiApiV1BoxesStorekeepersGuidSetItemsBarCodePatchRequest, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesStorekeepersGuidSetItemsBarCodePatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить коробки по текущему сторкипера отправленные в партию. REQUESTED_SEND_TO_BATCH  ## GUID клиента получаем из токена.   
     * @summary # Получить коробки по текущему сторкипера отправленные в партию.
     * @param {BoxesApiApiV1BoxesStorekeepersSentToBatchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesStorekeepersSentToBatchGet(requestParameters: BoxesApiApiV1BoxesStorekeepersSentToBatchGetRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesStorekeepersSentToBatchGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## делать из нескольких боксов один супербокс
     * @summary # Сделать из нескольких боксов один супербокс
     * @param {BoxesApiApiV1BoxesSuperboxRegroupPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoxesApi
     */
    public apiV1BoxesSuperboxRegroupPatch(requestParameters: BoxesApiApiV1BoxesSuperboxRegroupPatchRequest = {}, options?: any) {
        return BoxesApiFp(this.configuration).apiV1BoxesSuperboxRegroupPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
