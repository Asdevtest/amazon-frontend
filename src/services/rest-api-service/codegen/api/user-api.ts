/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiV1AnnouncementsMyCreatedBy } from '../models';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { ForbiddenError } from '../models';
// @ts-ignore
import { InlineObject144 } from '../models';
// @ts-ignore
import { InlineObject145 } from '../models';
// @ts-ignore
import { InlineObject146 } from '../models';
// @ts-ignore
import { InlineObject147 } from '../models';
// @ts-ignore
import { InlineObject148 } from '../models';
// @ts-ignore
import { InlineObject149 } from '../models';
// @ts-ignore
import { InlineObject150 } from '../models';
// @ts-ignore
import { InlineObject151 } from '../models';
// @ts-ignore
import { InlineObject152 } from '../models';
// @ts-ignore
import { InlineObject153 } from '../models';
// @ts-ignore
import { InlineObject154 } from '../models';
// @ts-ignore
import { InlineObject155 } from '../models';
// @ts-ignore
import { InlineObject156 } from '../models';
// @ts-ignore
import { InlineResponse200105 } from '../models';
// @ts-ignore
import { InlineResponse200106 } from '../models';
// @ts-ignore
import { InlineResponse200106Rows } from '../models';
// @ts-ignore
import { InlineResponse200107 } from '../models';
// @ts-ignore
import { InlineResponse200108 } from '../models';
// @ts-ignore
import { InlineResponse200109 } from '../models';
// @ts-ignore
import { InlineResponse200110 } from '../models';
// @ts-ignore
import { InlineResponse200111 } from '../models';
// @ts-ignore
import { InlineResponse200112 } from '../models';
// @ts-ignore
import { InlineResponse200113 } from '../models';
// @ts-ignore
import { InlineResponse200114 } from '../models';
// @ts-ignore
import { InlineResponse20112 } from '../models';
// @ts-ignore
import { InlineResponse20115 } from '../models';
// @ts-ignore
import { InlineResponse20116 } from '../models';
// @ts-ignore
import { InlineResponse20117 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { LinkSubuserInputSchema } from '../models';
// @ts-ignore
import { MePatchInputSchema } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
// @ts-ignore
import { SigninInputSchema } from '../models';
// @ts-ignore
import { SubUserPatchDtoSchema } from '../models';
// @ts-ignore
import { UnLinkSubuserInputSchema } from '../models';
// @ts-ignore
import { UserFullSchema } from '../models';
// @ts-ignore
import { UserInfoSchema } from '../models';
// @ts-ignore
import { UserRegisterSchema } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Поменять пароль, если его забыли
         * @summary Поменять пароль, если его забыли
         * @param {InlineObject154} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangeForgottenPasswordPost: async (body?: InlineObject154, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/change_forgotten_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Сменить пароль
         * @summary Сменить пароль
         * @param {InlineObject152} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePasswordPatch: async (body?: InlineObject152, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Выдача массива перечень всех контактов пользователя.   
         * @summary Выдача массива перечень всех контактов пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersContactsGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получение всех устройств
         * @summary # Получение всех устройств
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersDevicesGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Редактирование сабюзера мастер юзером.  Только мастер пользователь может редактировать Запрешено редактировать мастер юзера Мастер может редактировать только своих сабов Пермишены должны принадлежать роли сабюзера
         * @summary Редактирование сабюзера мастер юзером.
         * @param {string} guid GUID в БД.
         * @param {SubUserPatchDtoSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersEditMySubUsersGuidPatch: async (guid: string, body?: SubUserPatchDtoSchema, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersEditMySubUsersGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/users/edit_my_sub-users/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить отзыв
         * @summary Удалить отзыв
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersFeedbackGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/users/feedback/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить отзывы оставленые юзеру по его гуиду
         * @summary Получить отзывы оставленые юзеру по его гуиду
         * @param {string} guid 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [role] Фиьлтр по роли создателя отзыва на момент создания
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidGet: async (guid: string, noCache?: boolean, role?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersFeedbackGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/users/feedback/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить отзыв
         * @summary Изменить отзыв
         * @param {string} guid 
         * @param {InlineObject156} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidPatch: async (guid: string, body?: InlineObject156, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersFeedbackGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/users/feedback/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Оставить юзеру отзыв
         * @summary Оставить юзеру отзыв
         * @param {string} guid 
         * @param {InlineObject155} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidPost: async (guid: string, body?: InlineObject155, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersFeedbackGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/users/feedback/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить отзывы оставленые юзеру
         * @summary Получить отзывы оставленые юзеру
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [role] Фиьлтр по роли создателя отзыва на момент создания
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackMyGet: async (noCache?: boolean, role?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/feedback/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Запросить смену пароля
         * @summary Запросить смену пароля
         * @param {InlineObject153} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersForgotPasswordPost: async (body?: InlineObject153, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/forgot_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить freelance-notices.  
         * @summary Получить freelance-notices.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFreelanceNoticesGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/freelance-notices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список доступных спеков freelance_specs
         * @summary Получить список доступных спеков freelance_specs
         * @param {boolean} [archive] Статус архива спека
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFreelanceSpecsGet: async (archive?: boolean, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/freelance/specs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
         * @summary # Получение токена авторизации.
         * @param {InlineObject144} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersGetAccessTokenPost: async (body?: InlineObject144, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/get_access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить счетчики-информации пользователя.  
         * @summary Получить счетчики-информации пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersInfoCountersGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/info-counters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить информацию от текущем пользователе.   
         * @summary Получить информацию от текущем пользователе.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersInfoGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить информацию от текущем пользователе.   
         * @summary Получить информацию от текущем пользователе.
         * @param {string} guid 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersInfoGuidGet: async (guid: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersInfoGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/users/info/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Этот эндпоинт может быть вызван из любой роли кроме админа.  По email пользователя которого к себе хочет привязать мастер пользователь.  Проверки: у админа не может быть сабюзера, сабюзер не может иметь сабюзера,  Может ли данный пользователь быть мастер юзером, такую возможность дает только администратор. только кандидата можно привязать к качестве субпользователя
         * @summary # Привязка субпользователя.
         * @param {LinkSubuserInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersLinkSubUserPatch: async (body?: LinkSubuserInputSchema, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/link_sub-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Отозвать токены
         * @summary # Отозвать токены
         * @param {InlineObject145} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersLogoutPost: async (body?: InlineObject145, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список мастеров       role - Для клиента - 35 и 40, для админа - все       specs - Необязательный, может быть CSV       
         * @summary Получить список мастеров
         * @param {number} role Роль юзеров
         * @param {string} guid 
         * @param {string} [specs] Роль юзеров
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersMastersGet: async (role: number, guid: string, specs?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('apiV1UsersMastersGet', 'role', role)
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersMastersGet', 'guid', guid)
            const localVarPath = `/api/v1/users/masters`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Сейчас возможно только редактирование поля role.  ## Можно выбрать роль из массива allowedRoles.  Данный метод не доступен для сабюзера и админа   новое имя или почта должна быть уникальной.
         * @summary # Обновления информации о себе самим пользователем.
         * @param {MePatchInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersMePatch: async (body?: MePatchInputSchema, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список сабюзеров мастер пользователя.   
         * @summary Получить список сабюзеров мастер пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersMySubUsersGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my_sub-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Архивировать нотификации пользователя.   
         * @summary Архивировать нотификации пользователя.
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersNotificationsArchivePatch: async (body?: Array<string>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/notifications/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить нотификации пользователя.   
         * @summary Получить нотификации пользователя.
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [archive] Заархивирована ли нотификация
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersNotificationsPagMyGet: async (filters?: string, archive?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/notifications/pag/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить patch_note-ы   
         * @summary Получить patch_note-ы
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPatchNotesGet: async (limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/patch_notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить patch_note по GUID   
         * @summary Получить patch_note по GUID
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPatchNotesGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersPatchNotesGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/users/patch_notes/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Выдача настроек сервера.   
         * @summary Выдача настроек сервера.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPlatformSettingsGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/platform_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создание нового пользователя. Регистрация.   
         * @summary Создание нового пользователя. Регистрация.
         * @param {UserRegisterSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPost: async (body?: UserRegisterSchema, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получение пресетов юзера
         * @summary # Получение пресетов юзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удаление пресета по guid.
         * @summary # Удаление пресета по guid.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersPresetsGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/users/presets/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменение пресета
         * @summary # Изменение пресета
         * @param {string} guid 
         * @param {InlineObject148} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsGuidPatch: async (guid: string, body?: InlineObject148, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersPresetsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/users/presets/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создание нового пресета
         * @summary # Создание нового пресета
         * @param {InlineObject146} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsPost: async (body?: InlineObject146, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменение preset-settings
         * @summary # Изменение preset-settings
         * @param {string} guid 
         * @param {InlineObject149} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsSettingsGuidPatch: async (guid: string, body?: InlineObject149, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersPresetsSettingsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/users/presets/settings/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получение preset-settings юзера
         * @summary # Получение preset-settings юзера
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsSettingsMyGet: async (filters?: string, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/presets/settings/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать новый preset-settings
         * @summary # Создать новый preset-settings
         * @param {InlineObject147} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsSettingsPost: async (body?: InlineObject147, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/presets/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Добавление определенных специализаций сабам фрилансера Принимает массив специализаций
         * @summary #  Добавление определенных специализаций сабам фрилансера
         * @param {string} guid 
         * @param {InlineObject150} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersShareSpecSubGuidPost: async (guid: string, body?: InlineObject150, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1UsersShareSpecSubGuidPost', 'guid', guid)
            const localVarPath = `/api/v1/users/share_spec_sub/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
         * @summary # Получение токена авторизации.
         * @param {SigninInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSignInPost: async (body?: SigninInputSchema, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/sign_in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создание/изменение subNote, если null, то удаляется
         * @summary Создание/изменение subNote
         * @param {InlineObject151} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSubNotePatch: async (body?: InlineObject151, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/sub_note`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  По guid саб пользователя которого хочет отвязать мастер пользователь.  Саб пользователь просто блокируется. Проверки: по guid должен существовать пользователь,    У суб пользователя поле masterUser должно совпадать с id мастер пользователя.
         * @summary # Отвязка суб пользователя.
         * @param {UnLinkSubuserInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersUnlinkSubUserPatch: async (body?: UnLinkSubuserInputSchema, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/unlink_sub-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Deprecated!  Выдача массива доступных настроек пользователя..   
         * @summary Deprecated! Выдача массива доступных настроек пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersUserSettingsAvailableGet: async (noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/user-settings/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Поменять пароль, если его забыли
         * @summary Поменять пароль, если его забыли
         * @param {InlineObject154} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersChangeForgottenPasswordPost(body?: InlineObject154, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersChangeForgottenPasswordPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Сменить пароль
         * @summary Сменить пароль
         * @param {InlineObject152} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersChangePasswordPatch(body?: InlineObject152, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersChangePasswordPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Выдача массива перечень всех контактов пользователя.   
         * @summary Выдача массива перечень всех контактов пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersContactsGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200113>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersContactsGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получение всех устройств
         * @summary # Получение всех устройств
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersDevicesGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200109>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersDevicesGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Редактирование сабюзера мастер юзером.  Только мастер пользователь может редактировать Запрешено редактировать мастер юзера Мастер может редактировать только своих сабов Пермишены должны принадлежать роли сабюзера
         * @summary Редактирование сабюзера мастер юзером.
         * @param {string} guid GUID в БД.
         * @param {SubUserPatchDtoSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersEditMySubUsersGuidPatch(guid: string, body?: SubUserPatchDtoSchema, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersEditMySubUsersGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить отзыв
         * @summary Удалить отзыв
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFeedbackGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFeedbackGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить отзывы оставленые юзеру по его гуиду
         * @summary Получить отзывы оставленые юзеру по его гуиду
         * @param {string} guid 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [role] Фиьлтр по роли создателя отзыва на момент создания
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFeedbackGuidGet(guid: string, noCache?: boolean, role?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200114>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFeedbackGuidGet(guid, noCache, role, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить отзыв
         * @summary Изменить отзыв
         * @param {string} guid 
         * @param {InlineObject156} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFeedbackGuidPatch(guid: string, body?: InlineObject156, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFeedbackGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Оставить юзеру отзыв
         * @summary Оставить юзеру отзыв
         * @param {string} guid 
         * @param {InlineObject155} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFeedbackGuidPost(guid: string, body?: InlineObject155, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20112>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFeedbackGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить отзывы оставленые юзеру
         * @summary Получить отзывы оставленые юзеру
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [role] Фиьлтр по роли создателя отзыва на момент создания
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFeedbackMyGet(noCache?: boolean, role?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200114>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFeedbackMyGet(noCache, role, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Запросить смену пароля
         * @summary Запросить смену пароля
         * @param {InlineObject153} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersForgotPasswordPost(body?: InlineObject153, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersForgotPasswordPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить freelance-notices.  
         * @summary Получить freelance-notices.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFreelanceNoticesGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200105>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFreelanceNoticesGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список доступных спеков freelance_specs
         * @summary Получить список доступных спеков freelance_specs
         * @param {boolean} [archive] Статус архива спека
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersFreelanceSpecsGet(archive?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200108>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersFreelanceSpecsGet(archive, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
         * @summary # Получение токена авторизации.
         * @param {InlineObject144} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersGetAccessTokenPost(body?: InlineObject144, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20116>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersGetAccessTokenPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить счетчики-информации пользователя.  
         * @summary Получить счетчики-информации пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersInfoCountersGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersInfoCountersGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить информацию от текущем пользователе.   
         * @summary Получить информацию от текущем пользователе.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersInfoGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersInfoGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить информацию от текущем пользователе.   
         * @summary Получить информацию от текущем пользователе.
         * @param {string} guid 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersInfoGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersInfoGuidGet(guid, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Этот эндпоинт может быть вызван из любой роли кроме админа.  По email пользователя которого к себе хочет привязать мастер пользователь.  Проверки: у админа не может быть сабюзера, сабюзер не может иметь сабюзера,  Может ли данный пользователь быть мастер юзером, такую возможность дает только администратор. только кандидата можно привязать к качестве субпользователя
         * @summary # Привязка субпользователя.
         * @param {LinkSubuserInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersLinkSubUserPatch(body?: LinkSubuserInputSchema, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersLinkSubUserPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Отозвать токены
         * @summary # Отозвать токены
         * @param {InlineObject145} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersLogoutPost(body?: InlineObject145, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersLogoutPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список мастеров       role - Для клиента - 35 и 40, для админа - все       specs - Необязательный, может быть CSV       
         * @summary Получить список мастеров
         * @param {number} role Роль юзеров
         * @param {string} guid 
         * @param {string} [specs] Роль юзеров
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersMastersGet(role: number, guid: string, specs?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AnnouncementsMyCreatedBy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersMastersGet(role, guid, specs, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Сейчас возможно только редактирование поля role.  ## Можно выбрать роль из массива allowedRoles.  Данный метод не доступен для сабюзера и админа   новое имя или почта должна быть уникальной.
         * @summary # Обновления информации о себе самим пользователем.
         * @param {MePatchInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersMePatch(body?: MePatchInputSchema, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersMePatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список сабюзеров мастер пользователя.   
         * @summary Получить список сабюзеров мастер пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersMySubUsersGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserFullSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersMySubUsersGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Архивировать нотификации пользователя.   
         * @summary Архивировать нотификации пользователя.
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersNotificationsArchivePatch(body?: Array<string>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersNotificationsArchivePatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить нотификации пользователя.   
         * @summary Получить нотификации пользователя.
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [archive] Заархивирована ли нотификация
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersNotificationsPagMyGet(filters?: string, archive?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200107>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersNotificationsPagMyGet(filters, archive, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить patch_note-ы   
         * @summary Получить patch_note-ы
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPatchNotesGet(limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200106>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPatchNotesGet(limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить patch_note по GUID   
         * @summary Получить patch_note по GUID
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPatchNotesGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200106Rows>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPatchNotesGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Выдача настроек сервера.   
         * @summary Выдача настроек сервера.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPlatformSettingsGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200112>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPlatformSettingsGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создание нового пользователя. Регистрация.   
         * @summary Создание нового пользователя. Регистрация.
         * @param {UserRegisterSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPost(body?: UserRegisterSchema, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFullSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получение пресетов юзера
         * @summary # Получение пресетов юзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200110>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удаление пресета по guid.
         * @summary # Удаление пресета по guid.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменение пресета
         * @summary # Изменение пресета
         * @param {string} guid 
         * @param {InlineObject148} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsGuidPatch(guid: string, body?: InlineObject148, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создание нового пресета
         * @summary # Создание нового пресета
         * @param {InlineObject146} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsPost(body?: InlineObject146, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20117>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменение preset-settings
         * @summary # Изменение preset-settings
         * @param {string} guid 
         * @param {InlineObject149} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsSettingsGuidPatch(guid: string, body?: InlineObject149, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsSettingsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получение preset-settings юзера
         * @summary # Получение preset-settings юзера
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsSettingsMyGet(filters?: string, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200111>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsSettingsMyGet(filters, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать новый preset-settings
         * @summary # Создать новый preset-settings
         * @param {InlineObject147} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPresetsSettingsPost(body?: InlineObject147, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20117>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPresetsSettingsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Добавление определенных специализаций сабам фрилансера Принимает массив специализаций
         * @summary #  Добавление определенных специализаций сабам фрилансера
         * @param {string} guid 
         * @param {InlineObject150} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersShareSpecSubGuidPost(guid: string, body?: InlineObject150, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersShareSpecSubGuidPost(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
         * @summary # Получение токена авторизации.
         * @param {SigninInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersSignInPost(body?: SigninInputSchema, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20115>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersSignInPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создание/изменение subNote, если null, то удаляется
         * @summary Создание/изменение subNote
         * @param {InlineObject151} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersSubNotePatch(body?: InlineObject151, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersSubNotePatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  По guid саб пользователя которого хочет отвязать мастер пользователь.  Саб пользователь просто блокируется. Проверки: по guid должен существовать пользователь,    У суб пользователя поле masterUser должно совпадать с id мастер пользователя.
         * @summary # Отвязка суб пользователя.
         * @param {UnLinkSubuserInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersUnlinkSubUserPatch(body?: UnLinkSubuserInputSchema, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersUnlinkSubUserPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Deprecated!  Выдача массива доступных настроек пользователя..   
         * @summary Deprecated! Выдача массива доступных настроек пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersUserSettingsAvailableGet(noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersUserSettingsAvailableGet(noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * ## Поменять пароль, если его забыли
         * @summary Поменять пароль, если его забыли
         * @param {InlineObject154} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangeForgottenPasswordPost(body?: InlineObject154, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersChangeForgottenPasswordPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Сменить пароль
         * @summary Сменить пароль
         * @param {InlineObject152} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePasswordPatch(body?: InlineObject152, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersChangePasswordPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Выдача массива перечень всех контактов пользователя.   
         * @summary Выдача массива перечень всех контактов пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersContactsGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200113>> {
            return localVarFp.apiV1UsersContactsGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получение всех устройств
         * @summary # Получение всех устройств
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersDevicesGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200109>> {
            return localVarFp.apiV1UsersDevicesGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Редактирование сабюзера мастер юзером.  Только мастер пользователь может редактировать Запрешено редактировать мастер юзера Мастер может редактировать только своих сабов Пермишены должны принадлежать роли сабюзера
         * @summary Редактирование сабюзера мастер юзером.
         * @param {string} guid GUID в БД.
         * @param {SubUserPatchDtoSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersEditMySubUsersGuidPatch(guid: string, body?: SubUserPatchDtoSchema, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersEditMySubUsersGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить отзыв
         * @summary Удалить отзыв
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersFeedbackGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить отзывы оставленые юзеру по его гуиду
         * @summary Получить отзывы оставленые юзеру по его гуиду
         * @param {string} guid 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [role] Фиьлтр по роли создателя отзыва на момент создания
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidGet(guid: string, noCache?: boolean, role?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200114>> {
            return localVarFp.apiV1UsersFeedbackGuidGet(guid, noCache, role, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить отзыв
         * @summary Изменить отзыв
         * @param {string} guid 
         * @param {InlineObject156} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidPatch(guid: string, body?: InlineObject156, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersFeedbackGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Оставить юзеру отзыв
         * @summary Оставить юзеру отзыв
         * @param {string} guid 
         * @param {InlineObject155} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackGuidPost(guid: string, body?: InlineObject155, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20112> {
            return localVarFp.apiV1UsersFeedbackGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить отзывы оставленые юзеру
         * @summary Получить отзывы оставленые юзеру
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {number} [role] Фиьлтр по роли создателя отзыва на момент создания
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFeedbackMyGet(noCache?: boolean, role?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200114>> {
            return localVarFp.apiV1UsersFeedbackMyGet(noCache, role, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Запросить смену пароля
         * @summary Запросить смену пароля
         * @param {InlineObject153} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersForgotPasswordPost(body?: InlineObject153, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersForgotPasswordPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить freelance-notices.  
         * @summary Получить freelance-notices.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFreelanceNoticesGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200105>> {
            return localVarFp.apiV1UsersFreelanceNoticesGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список доступных спеков freelance_specs
         * @summary Получить список доступных спеков freelance_specs
         * @param {boolean} [archive] Статус архива спека
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersFreelanceSpecsGet(archive?: boolean, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200108>> {
            return localVarFp.apiV1UsersFreelanceSpecsGet(archive, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
         * @summary # Получение токена авторизации.
         * @param {InlineObject144} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersGetAccessTokenPost(body?: InlineObject144, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20116> {
            return localVarFp.apiV1UsersGetAccessTokenPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить счетчики-информации пользователя.  
         * @summary Получить счетчики-информации пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersInfoCountersGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<UserInfoSchema> {
            return localVarFp.apiV1UsersInfoCountersGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить информацию от текущем пользователе.   
         * @summary Получить информацию от текущем пользователе.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersInfoGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<UserInfoSchema> {
            return localVarFp.apiV1UsersInfoGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить информацию от текущем пользователе.   
         * @summary Получить информацию от текущем пользователе.
         * @param {string} guid 
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersInfoGuidGet(guid: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<UserInfoSchema> {
            return localVarFp.apiV1UsersInfoGuidGet(guid, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Этот эндпоинт может быть вызван из любой роли кроме админа.  По email пользователя которого к себе хочет привязать мастер пользователь.  Проверки: у админа не может быть сабюзера, сабюзер не может иметь сабюзера,  Может ли данный пользователь быть мастер юзером, такую возможность дает только администратор. только кандидата можно привязать к качестве субпользователя
         * @summary # Привязка субпользователя.
         * @param {LinkSubuserInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersLinkSubUserPatch(body?: LinkSubuserInputSchema, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersLinkSubUserPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Отозвать токены
         * @summary # Отозвать токены
         * @param {InlineObject145} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersLogoutPost(body?: InlineObject145, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersLogoutPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список мастеров       role - Для клиента - 35 и 40, для админа - все       specs - Необязательный, может быть CSV       
         * @summary Получить список мастеров
         * @param {number} role Роль юзеров
         * @param {string} guid 
         * @param {string} [specs] Роль юзеров
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersMastersGet(role: number, guid: string, specs?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1AnnouncementsMyCreatedBy>> {
            return localVarFp.apiV1UsersMastersGet(role, guid, specs, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Сейчас возможно только редактирование поля role.  ## Можно выбрать роль из массива allowedRoles.  Данный метод не доступен для сабюзера и админа   новое имя или почта должна быть уникальной.
         * @summary # Обновления информации о себе самим пользователем.
         * @param {MePatchInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersMePatch(body?: MePatchInputSchema, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersMePatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список сабюзеров мастер пользователя.   
         * @summary Получить список сабюзеров мастер пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersMySubUsersGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<UserFullSchema>> {
            return localVarFp.apiV1UsersMySubUsersGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Архивировать нотификации пользователя.   
         * @summary Архивировать нотификации пользователя.
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersNotificationsArchivePatch(body?: Array<string>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersNotificationsArchivePatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить нотификации пользователя.   
         * @summary Получить нотификации пользователя.
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [archive] Заархивирована ли нотификация
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersNotificationsPagMyGet(filters?: string, archive?: boolean, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200107> {
            return localVarFp.apiV1UsersNotificationsPagMyGet(filters, archive, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить patch_note-ы   
         * @summary Получить patch_note-ы
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPatchNotesGet(limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200106> {
            return localVarFp.apiV1UsersPatchNotesGet(limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить patch_note по GUID   
         * @summary Получить patch_note по GUID
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPatchNotesGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200106Rows>> {
            return localVarFp.apiV1UsersPatchNotesGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Выдача настроек сервера.   
         * @summary Выдача настроек сервера.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPlatformSettingsGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse200112> {
            return localVarFp.apiV1UsersPlatformSettingsGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создание нового пользователя. Регистрация.   
         * @summary Создание нового пользователя. Регистрация.
         * @param {UserRegisterSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPost(body?: UserRegisterSchema, acceptEncoding?: string, options?: any): AxiosPromise<UserFullSchema> {
            return localVarFp.apiV1UsersPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получение пресетов юзера
         * @summary # Получение пресетов юзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200110>> {
            return localVarFp.apiV1UsersPresetsGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удаление пресета по guid.
         * @summary # Удаление пресета по guid.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersPresetsGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменение пресета
         * @summary # Изменение пресета
         * @param {string} guid 
         * @param {InlineObject148} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsGuidPatch(guid: string, body?: InlineObject148, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersPresetsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создание нового пресета
         * @summary # Создание нового пресета
         * @param {InlineObject146} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsPost(body?: InlineObject146, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20117> {
            return localVarFp.apiV1UsersPresetsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменение preset-settings
         * @summary # Изменение preset-settings
         * @param {string} guid 
         * @param {InlineObject149} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsSettingsGuidPatch(guid: string, body?: InlineObject149, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersPresetsSettingsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получение preset-settings юзера
         * @summary # Получение preset-settings юзера
         * @param {string} [filters]                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsSettingsMyGet(filters?: string, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse200111>> {
            return localVarFp.apiV1UsersPresetsSettingsMyGet(filters, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать новый preset-settings
         * @summary # Создать новый preset-settings
         * @param {InlineObject147} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPresetsSettingsPost(body?: InlineObject147, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20117> {
            return localVarFp.apiV1UsersPresetsSettingsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Добавление определенных специализаций сабам фрилансера Принимает массив специализаций
         * @summary #  Добавление определенных специализаций сабам фрилансера
         * @param {string} guid 
         * @param {InlineObject150} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersShareSpecSubGuidPost(guid: string, body?: InlineObject150, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersShareSpecSubGuidPost(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
         * @summary # Получение токена авторизации.
         * @param {SigninInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSignInPost(body?: SigninInputSchema, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20115> {
            return localVarFp.apiV1UsersSignInPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создание/изменение subNote, если null, то удаляется
         * @summary Создание/изменение subNote
         * @param {InlineObject151} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersSubNotePatch(body?: InlineObject151, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersSubNotePatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  По guid саб пользователя которого хочет отвязать мастер пользователь.  Саб пользователь просто блокируется. Проверки: по guid должен существовать пользователь,    У суб пользователя поле masterUser должно совпадать с id мастер пользователя.
         * @summary # Отвязка суб пользователя.
         * @param {UnLinkSubuserInputSchema} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersUnlinkSubUserPatch(body?: UnLinkSubuserInputSchema, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1UsersUnlinkSubUserPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Deprecated!  Выдача массива доступных настроек пользователя..   
         * @summary Deprecated! Выдача массива доступных настроек пользователя.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersUserSettingsAvailableGet(noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiV1UsersUserSettingsAvailableGet(noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1UsersChangeForgottenPasswordPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersChangeForgottenPasswordPostRequest
 */
export interface UserApiApiV1UsersChangeForgottenPasswordPostRequest {
    /**
     * 
     * @type {InlineObject154}
     * @memberof UserApiApiV1UsersChangeForgottenPasswordPost
     */
    readonly body?: InlineObject154

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersChangeForgottenPasswordPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersChangePasswordPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersChangePasswordPatchRequest
 */
export interface UserApiApiV1UsersChangePasswordPatchRequest {
    /**
     * 
     * @type {InlineObject152}
     * @memberof UserApiApiV1UsersChangePasswordPatch
     */
    readonly body?: InlineObject152

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersChangePasswordPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersContactsGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersContactsGetRequest
 */
export interface UserApiApiV1UsersContactsGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersContactsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersContactsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersDevicesGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersDevicesGetRequest
 */
export interface UserApiApiV1UsersDevicesGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersDevicesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersDevicesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersEditMySubUsersGuidPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersEditMySubUsersGuidPatchRequest
 */
export interface UserApiApiV1UsersEditMySubUsersGuidPatchRequest {
    /**
     * GUID в БД.
     * @type {string}
     * @memberof UserApiApiV1UsersEditMySubUsersGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {SubUserPatchDtoSchema}
     * @memberof UserApiApiV1UsersEditMySubUsersGuidPatch
     */
    readonly body?: SubUserPatchDtoSchema

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersEditMySubUsersGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFeedbackGuidDelete operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFeedbackGuidDeleteRequest
 */
export interface UserApiApiV1UsersFeedbackGuidDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFeedbackGuidGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFeedbackGuidGetRequest
 */
export interface UserApiApiV1UsersFeedbackGuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersFeedbackGuidGet
     */
    readonly noCache?: boolean

    /**
     * Фиьлтр по роли создателя отзыва на момент создания
     * @type {number}
     * @memberof UserApiApiV1UsersFeedbackGuidGet
     */
    readonly role?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFeedbackGuidPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFeedbackGuidPatchRequest
 */
export interface UserApiApiV1UsersFeedbackGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject156}
     * @memberof UserApiApiV1UsersFeedbackGuidPatch
     */
    readonly body?: InlineObject156

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFeedbackGuidPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFeedbackGuidPostRequest
 */
export interface UserApiApiV1UsersFeedbackGuidPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject155}
     * @memberof UserApiApiV1UsersFeedbackGuidPost
     */
    readonly body?: InlineObject155

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFeedbackMyGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFeedbackMyGetRequest
 */
export interface UserApiApiV1UsersFeedbackMyGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersFeedbackMyGet
     */
    readonly noCache?: boolean

    /**
     * Фиьлтр по роли создателя отзыва на момент создания
     * @type {number}
     * @memberof UserApiApiV1UsersFeedbackMyGet
     */
    readonly role?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFeedbackMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersForgotPasswordPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersForgotPasswordPostRequest
 */
export interface UserApiApiV1UsersForgotPasswordPostRequest {
    /**
     * 
     * @type {InlineObject153}
     * @memberof UserApiApiV1UsersForgotPasswordPost
     */
    readonly body?: InlineObject153

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersForgotPasswordPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFreelanceNoticesGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFreelanceNoticesGetRequest
 */
export interface UserApiApiV1UsersFreelanceNoticesGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersFreelanceNoticesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFreelanceNoticesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersFreelanceSpecsGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersFreelanceSpecsGetRequest
 */
export interface UserApiApiV1UsersFreelanceSpecsGetRequest {
    /**
     * Статус архива спека
     * @type {boolean}
     * @memberof UserApiApiV1UsersFreelanceSpecsGet
     */
    readonly archive?: boolean

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersFreelanceSpecsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersFreelanceSpecsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersGetAccessTokenPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersGetAccessTokenPostRequest
 */
export interface UserApiApiV1UsersGetAccessTokenPostRequest {
    /**
     * 
     * @type {InlineObject144}
     * @memberof UserApiApiV1UsersGetAccessTokenPost
     */
    readonly body?: InlineObject144

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersGetAccessTokenPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersInfoCountersGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersInfoCountersGetRequest
 */
export interface UserApiApiV1UsersInfoCountersGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersInfoCountersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersInfoCountersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersInfoGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersInfoGetRequest
 */
export interface UserApiApiV1UsersInfoGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersInfoGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersInfoGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersInfoGuidGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersInfoGuidGetRequest
 */
export interface UserApiApiV1UsersInfoGuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersInfoGuidGet
     */
    readonly guid: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersInfoGuidGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersInfoGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersLinkSubUserPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersLinkSubUserPatchRequest
 */
export interface UserApiApiV1UsersLinkSubUserPatchRequest {
    /**
     * 
     * @type {LinkSubuserInputSchema}
     * @memberof UserApiApiV1UsersLinkSubUserPatch
     */
    readonly body?: LinkSubuserInputSchema

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersLinkSubUserPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersLogoutPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersLogoutPostRequest
 */
export interface UserApiApiV1UsersLogoutPostRequest {
    /**
     * 
     * @type {InlineObject145}
     * @memberof UserApiApiV1UsersLogoutPost
     */
    readonly body?: InlineObject145

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersLogoutPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersMastersGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersMastersGetRequest
 */
export interface UserApiApiV1UsersMastersGetRequest {
    /**
     * Роль юзеров
     * @type {number}
     * @memberof UserApiApiV1UsersMastersGet
     */
    readonly role: number

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersMastersGet
     */
    readonly guid: string

    /**
     * Роль юзеров
     * @type {string}
     * @memberof UserApiApiV1UsersMastersGet
     */
    readonly specs?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersMastersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersMastersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersMePatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersMePatchRequest
 */
export interface UserApiApiV1UsersMePatchRequest {
    /**
     * 
     * @type {MePatchInputSchema}
     * @memberof UserApiApiV1UsersMePatch
     */
    readonly body?: MePatchInputSchema

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersMePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersMySubUsersGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersMySubUsersGetRequest
 */
export interface UserApiApiV1UsersMySubUsersGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersMySubUsersGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersMySubUsersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersNotificationsArchivePatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersNotificationsArchivePatchRequest
 */
export interface UserApiApiV1UsersNotificationsArchivePatchRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserApiApiV1UsersNotificationsArchivePatch
     */
    readonly body?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersNotificationsArchivePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersNotificationsPagMyGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersNotificationsPagMyGetRequest
 */
export interface UserApiApiV1UsersNotificationsPagMyGetRequest {
    /**
     *                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly filters?: string

    /**
     * Заархивирована ли нотификация
     * @type {boolean}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly archive?: boolean

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersNotificationsPagMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPatchNotesGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPatchNotesGetRequest
 */
export interface UserApiApiV1UsersPatchNotesGetRequest {
    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof UserApiApiV1UsersPatchNotesGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof UserApiApiV1UsersPatchNotesGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof UserApiApiV1UsersPatchNotesGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof UserApiApiV1UsersPatchNotesGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersPatchNotesGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPatchNotesGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPatchNotesGuidGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPatchNotesGuidGetRequest
 */
export interface UserApiApiV1UsersPatchNotesGuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPatchNotesGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPatchNotesGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPlatformSettingsGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPlatformSettingsGetRequest
 */
export interface UserApiApiV1UsersPlatformSettingsGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersPlatformSettingsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPlatformSettingsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPostRequest
 */
export interface UserApiApiV1UsersPostRequest {
    /**
     * 
     * @type {UserRegisterSchema}
     * @memberof UserApiApiV1UsersPost
     */
    readonly body?: UserRegisterSchema

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsGetRequest
 */
export interface UserApiApiV1UsersPresetsGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersPresetsGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsGuidDelete operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsGuidDeleteRequest
 */
export interface UserApiApiV1UsersPresetsGuidDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsGuidPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsGuidPatchRequest
 */
export interface UserApiApiV1UsersPresetsGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject148}
     * @memberof UserApiApiV1UsersPresetsGuidPatch
     */
    readonly body?: InlineObject148

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsPostRequest
 */
export interface UserApiApiV1UsersPresetsPostRequest {
    /**
     * 
     * @type {InlineObject146}
     * @memberof UserApiApiV1UsersPresetsPost
     */
    readonly body?: InlineObject146

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsSettingsGuidPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsSettingsGuidPatchRequest
 */
export interface UserApiApiV1UsersPresetsSettingsGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsSettingsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject149}
     * @memberof UserApiApiV1UsersPresetsSettingsGuidPatch
     */
    readonly body?: InlineObject149

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsSettingsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsSettingsMyGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsSettingsMyGetRequest
 */
export interface UserApiApiV1UsersPresetsSettingsMyGetRequest {
    /**
     *                Возможные поля:                type: (request,order,box,proposal,idea),                data: ($contains -&gt; anyValue)               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsSettingsMyGet
     */
    readonly filters?: string

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersPresetsSettingsMyGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsSettingsMyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersPresetsSettingsPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersPresetsSettingsPostRequest
 */
export interface UserApiApiV1UsersPresetsSettingsPostRequest {
    /**
     * 
     * @type {InlineObject147}
     * @memberof UserApiApiV1UsersPresetsSettingsPost
     */
    readonly body?: InlineObject147

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersPresetsSettingsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersShareSpecSubGuidPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersShareSpecSubGuidPostRequest
 */
export interface UserApiApiV1UsersShareSpecSubGuidPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersShareSpecSubGuidPost
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject150}
     * @memberof UserApiApiV1UsersShareSpecSubGuidPost
     */
    readonly body?: InlineObject150

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersShareSpecSubGuidPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersSignInPost operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersSignInPostRequest
 */
export interface UserApiApiV1UsersSignInPostRequest {
    /**
     * 
     * @type {SigninInputSchema}
     * @memberof UserApiApiV1UsersSignInPost
     */
    readonly body?: SigninInputSchema

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersSignInPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersSubNotePatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersSubNotePatchRequest
 */
export interface UserApiApiV1UsersSubNotePatchRequest {
    /**
     * 
     * @type {InlineObject151}
     * @memberof UserApiApiV1UsersSubNotePatch
     */
    readonly body?: InlineObject151

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersSubNotePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersUnlinkSubUserPatch operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersUnlinkSubUserPatchRequest
 */
export interface UserApiApiV1UsersUnlinkSubUserPatchRequest {
    /**
     * 
     * @type {UnLinkSubuserInputSchema}
     * @memberof UserApiApiV1UsersUnlinkSubUserPatch
     */
    readonly body?: UnLinkSubuserInputSchema

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersUnlinkSubUserPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1UsersUserSettingsAvailableGet operation in UserApi.
 * @export
 * @interface UserApiApiV1UsersUserSettingsAvailableGetRequest
 */
export interface UserApiApiV1UsersUserSettingsAvailableGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof UserApiApiV1UsersUserSettingsAvailableGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserApiApiV1UsersUserSettingsAvailableGet
     */
    readonly acceptEncoding?: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * ## Поменять пароль, если его забыли
     * @summary Поменять пароль, если его забыли
     * @param {UserApiApiV1UsersChangeForgottenPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersChangeForgottenPasswordPost(requestParameters: UserApiApiV1UsersChangeForgottenPasswordPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersChangeForgottenPasswordPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Сменить пароль
     * @summary Сменить пароль
     * @param {UserApiApiV1UsersChangePasswordPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersChangePasswordPatch(requestParameters: UserApiApiV1UsersChangePasswordPatchRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersChangePasswordPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Выдача массива перечень всех контактов пользователя.   
     * @summary Выдача массива перечень всех контактов пользователя.
     * @param {UserApiApiV1UsersContactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersContactsGet(requestParameters: UserApiApiV1UsersContactsGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersContactsGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получение всех устройств
     * @summary # Получение всех устройств
     * @param {UserApiApiV1UsersDevicesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersDevicesGet(requestParameters: UserApiApiV1UsersDevicesGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersDevicesGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Редактирование сабюзера мастер юзером.  Только мастер пользователь может редактировать Запрешено редактировать мастер юзера Мастер может редактировать только своих сабов Пермишены должны принадлежать роли сабюзера
     * @summary Редактирование сабюзера мастер юзером.
     * @param {UserApiApiV1UsersEditMySubUsersGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersEditMySubUsersGuidPatch(requestParameters: UserApiApiV1UsersEditMySubUsersGuidPatchRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersEditMySubUsersGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить отзыв
     * @summary Удалить отзыв
     * @param {UserApiApiV1UsersFeedbackGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFeedbackGuidDelete(requestParameters: UserApiApiV1UsersFeedbackGuidDeleteRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFeedbackGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить отзывы оставленые юзеру по его гуиду
     * @summary Получить отзывы оставленые юзеру по его гуиду
     * @param {UserApiApiV1UsersFeedbackGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFeedbackGuidGet(requestParameters: UserApiApiV1UsersFeedbackGuidGetRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFeedbackGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.role, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить отзыв
     * @summary Изменить отзыв
     * @param {UserApiApiV1UsersFeedbackGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFeedbackGuidPatch(requestParameters: UserApiApiV1UsersFeedbackGuidPatchRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFeedbackGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Оставить юзеру отзыв
     * @summary Оставить юзеру отзыв
     * @param {UserApiApiV1UsersFeedbackGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFeedbackGuidPost(requestParameters: UserApiApiV1UsersFeedbackGuidPostRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFeedbackGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить отзывы оставленые юзеру
     * @summary Получить отзывы оставленые юзеру
     * @param {UserApiApiV1UsersFeedbackMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFeedbackMyGet(requestParameters: UserApiApiV1UsersFeedbackMyGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFeedbackMyGet(requestParameters.noCache, requestParameters.role, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Запросить смену пароля
     * @summary Запросить смену пароля
     * @param {UserApiApiV1UsersForgotPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersForgotPasswordPost(requestParameters: UserApiApiV1UsersForgotPasswordPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersForgotPasswordPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить freelance-notices.  
     * @summary Получить freelance-notices.
     * @param {UserApiApiV1UsersFreelanceNoticesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFreelanceNoticesGet(requestParameters: UserApiApiV1UsersFreelanceNoticesGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFreelanceNoticesGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список доступных спеков freelance_specs
     * @summary Получить список доступных спеков freelance_specs
     * @param {UserApiApiV1UsersFreelanceSpecsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersFreelanceSpecsGet(requestParameters: UserApiApiV1UsersFreelanceSpecsGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersFreelanceSpecsGet(requestParameters.archive, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
     * @summary # Получение токена авторизации.
     * @param {UserApiApiV1UsersGetAccessTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersGetAccessTokenPost(requestParameters: UserApiApiV1UsersGetAccessTokenPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersGetAccessTokenPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить счетчики-информации пользователя.  
     * @summary Получить счетчики-информации пользователя.
     * @param {UserApiApiV1UsersInfoCountersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersInfoCountersGet(requestParameters: UserApiApiV1UsersInfoCountersGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersInfoCountersGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить информацию от текущем пользователе.   
     * @summary Получить информацию от текущем пользователе.
     * @param {UserApiApiV1UsersInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersInfoGet(requestParameters: UserApiApiV1UsersInfoGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersInfoGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить информацию от текущем пользователе.   
     * @summary Получить информацию от текущем пользователе.
     * @param {UserApiApiV1UsersInfoGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersInfoGuidGet(requestParameters: UserApiApiV1UsersInfoGuidGetRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersInfoGuidGet(requestParameters.guid, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Этот эндпоинт может быть вызван из любой роли кроме админа.  По email пользователя которого к себе хочет привязать мастер пользователь.  Проверки: у админа не может быть сабюзера, сабюзер не может иметь сабюзера,  Может ли данный пользователь быть мастер юзером, такую возможность дает только администратор. только кандидата можно привязать к качестве субпользователя
     * @summary # Привязка субпользователя.
     * @param {UserApiApiV1UsersLinkSubUserPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersLinkSubUserPatch(requestParameters: UserApiApiV1UsersLinkSubUserPatchRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersLinkSubUserPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Отозвать токены
     * @summary # Отозвать токены
     * @param {UserApiApiV1UsersLogoutPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersLogoutPost(requestParameters: UserApiApiV1UsersLogoutPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersLogoutPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список мастеров       role - Для клиента - 35 и 40, для админа - все       specs - Необязательный, может быть CSV       
     * @summary Получить список мастеров
     * @param {UserApiApiV1UsersMastersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersMastersGet(requestParameters: UserApiApiV1UsersMastersGetRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersMastersGet(requestParameters.role, requestParameters.guid, requestParameters.specs, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Сейчас возможно только редактирование поля role.  ## Можно выбрать роль из массива allowedRoles.  Данный метод не доступен для сабюзера и админа   новое имя или почта должна быть уникальной.
     * @summary # Обновления информации о себе самим пользователем.
     * @param {UserApiApiV1UsersMePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersMePatch(requestParameters: UserApiApiV1UsersMePatchRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersMePatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список сабюзеров мастер пользователя.   
     * @summary Получить список сабюзеров мастер пользователя.
     * @param {UserApiApiV1UsersMySubUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersMySubUsersGet(requestParameters: UserApiApiV1UsersMySubUsersGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersMySubUsersGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Архивировать нотификации пользователя.   
     * @summary Архивировать нотификации пользователя.
     * @param {UserApiApiV1UsersNotificationsArchivePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersNotificationsArchivePatch(requestParameters: UserApiApiV1UsersNotificationsArchivePatchRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersNotificationsArchivePatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить нотификации пользователя.   
     * @summary Получить нотификации пользователя.
     * @param {UserApiApiV1UsersNotificationsPagMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersNotificationsPagMyGet(requestParameters: UserApiApiV1UsersNotificationsPagMyGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersNotificationsPagMyGet(requestParameters.filters, requestParameters.archive, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить patch_note-ы   
     * @summary Получить patch_note-ы
     * @param {UserApiApiV1UsersPatchNotesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPatchNotesGet(requestParameters: UserApiApiV1UsersPatchNotesGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPatchNotesGet(requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить patch_note по GUID   
     * @summary Получить patch_note по GUID
     * @param {UserApiApiV1UsersPatchNotesGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPatchNotesGuidGet(requestParameters: UserApiApiV1UsersPatchNotesGuidGetRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPatchNotesGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Выдача настроек сервера.   
     * @summary Выдача настроек сервера.
     * @param {UserApiApiV1UsersPlatformSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPlatformSettingsGet(requestParameters: UserApiApiV1UsersPlatformSettingsGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPlatformSettingsGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создание нового пользователя. Регистрация.   
     * @summary Создание нового пользователя. Регистрация.
     * @param {UserApiApiV1UsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPost(requestParameters: UserApiApiV1UsersPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получение пресетов юзера
     * @summary # Получение пресетов юзера
     * @param {UserApiApiV1UsersPresetsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsGet(requestParameters: UserApiApiV1UsersPresetsGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удаление пресета по guid.
     * @summary # Удаление пресета по guid.
     * @param {UserApiApiV1UsersPresetsGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsGuidDelete(requestParameters: UserApiApiV1UsersPresetsGuidDeleteRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменение пресета
     * @summary # Изменение пресета
     * @param {UserApiApiV1UsersPresetsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsGuidPatch(requestParameters: UserApiApiV1UsersPresetsGuidPatchRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создание нового пресета
     * @summary # Создание нового пресета
     * @param {UserApiApiV1UsersPresetsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsPost(requestParameters: UserApiApiV1UsersPresetsPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменение preset-settings
     * @summary # Изменение preset-settings
     * @param {UserApiApiV1UsersPresetsSettingsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsSettingsGuidPatch(requestParameters: UserApiApiV1UsersPresetsSettingsGuidPatchRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsSettingsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получение preset-settings юзера
     * @summary # Получение preset-settings юзера
     * @param {UserApiApiV1UsersPresetsSettingsMyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsSettingsMyGet(requestParameters: UserApiApiV1UsersPresetsSettingsMyGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsSettingsMyGet(requestParameters.filters, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать новый preset-settings
     * @summary # Создать новый preset-settings
     * @param {UserApiApiV1UsersPresetsSettingsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersPresetsSettingsPost(requestParameters: UserApiApiV1UsersPresetsSettingsPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersPresetsSettingsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Добавление определенных специализаций сабам фрилансера Принимает массив специализаций
     * @summary #  Добавление определенных специализаций сабам фрилансера
     * @param {UserApiApiV1UsersShareSpecSubGuidPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersShareSpecSubGuidPost(requestParameters: UserApiApiV1UsersShareSpecSubGuidPostRequest, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersShareSpecSubGuidPost(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получение токена авторизации.   ## Время жизни токена 96 часов   
     * @summary # Получение токена авторизации.
     * @param {UserApiApiV1UsersSignInPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersSignInPost(requestParameters: UserApiApiV1UsersSignInPostRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersSignInPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создание/изменение subNote, если null, то удаляется
     * @summary Создание/изменение subNote
     * @param {UserApiApiV1UsersSubNotePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersSubNotePatch(requestParameters: UserApiApiV1UsersSubNotePatchRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersSubNotePatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  По guid саб пользователя которого хочет отвязать мастер пользователь.  Саб пользователь просто блокируется. Проверки: по guid должен существовать пользователь,    У суб пользователя поле masterUser должно совпадать с id мастер пользователя.
     * @summary # Отвязка суб пользователя.
     * @param {UserApiApiV1UsersUnlinkSubUserPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersUnlinkSubUserPatch(requestParameters: UserApiApiV1UsersUnlinkSubUserPatchRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersUnlinkSubUserPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Deprecated!  Выдача массива доступных настроек пользователя..   
     * @summary Deprecated! Выдача массива доступных настроек пользователя.
     * @param {UserApiApiV1UsersUserSettingsAvailableGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiV1UsersUserSettingsAvailableGet(requestParameters: UserApiApiV1UsersUserSettingsAvailableGetRequest = {}, options?: any) {
        return UserApiFp(this.configuration).apiV1UsersUserSettingsAvailableGet(requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
