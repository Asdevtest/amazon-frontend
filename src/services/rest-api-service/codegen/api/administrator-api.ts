/* tslint:disable */
/* eslint-disable */
/**
 * Test swagger
 * testing the fastify swagger api
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiV1BatchesOrder } from '../models';
// @ts-ignore
import { ApiV1BatchesProduct } from '../models';
// @ts-ignore
import { BadRequestError } from '../models';
// @ts-ignore
import { ConflictInTheState } from '../models';
// @ts-ignore
import { InlineObject27 } from '../models';
// @ts-ignore
import { InlineObject28 } from '../models';
// @ts-ignore
import { InlineObject29 } from '../models';
// @ts-ignore
import { InlineObject30 } from '../models';
// @ts-ignore
import { InlineObject31 } from '../models';
// @ts-ignore
import { InlineObject32 } from '../models';
// @ts-ignore
import { InlineObject33 } from '../models';
// @ts-ignore
import { InlineObject34 } from '../models';
// @ts-ignore
import { InlineObject35 } from '../models';
// @ts-ignore
import { InlineObject36 } from '../models';
// @ts-ignore
import { InlineObject37 } from '../models';
// @ts-ignore
import { InlineObject38 } from '../models';
// @ts-ignore
import { InlineObject39 } from '../models';
// @ts-ignore
import { InlineObject40 } from '../models';
// @ts-ignore
import { InlineObject41 } from '../models';
// @ts-ignore
import { InlineObject42 } from '../models';
// @ts-ignore
import { InlineResponse20016 } from '../models';
// @ts-ignore
import { InlineResponse20017 } from '../models';
// @ts-ignore
import { InlineResponse20018 } from '../models';
// @ts-ignore
import { InlineResponse20019 } from '../models';
// @ts-ignore
import { InlineResponse20020 } from '../models';
// @ts-ignore
import { InlineResponse20021 } from '../models';
// @ts-ignore
import { InlineResponse20022 } from '../models';
// @ts-ignore
import { InlineResponse20023 } from '../models';
// @ts-ignore
import { InlineResponse20024 } from '../models';
// @ts-ignore
import { InlineResponse20025 } from '../models';
// @ts-ignore
import { InlineResponse20026 } from '../models';
// @ts-ignore
import { InlineResponse20027 } from '../models';
// @ts-ignore
import { InternalServerError } from '../models';
// @ts-ignore
import { NotFoundError } from '../models';
// @ts-ignore
import { SuccessResponseBodyWithGuid } from '../models';
// @ts-ignore
import { UserAdminFullSchema } from '../models';
/**
 * AdministratorApi - axios parameter creator
 * @export
 */
export const AdministratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ## Редактировать склад назначения.   
         * @summary #  Редактировать склад назначения.
         * @param {string} guid 
         * @param {InlineObject38} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsDestinationEditGuidPatch: async (guid: string, body?: InlineObject38, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsDestinationEditGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/destination_edit/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактировать склад назначения.   
         * @summary #  Редактировать склад назначения.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsDestinationGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsDestinationGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/admins/destination/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать склад назначения.   
         * @summary #  Создать склад назначения.
         * @param {InlineObject37} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsDestinationPost: async (body?: InlineObject37, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/destination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список отзывов/жалоб   
         * @summary #  Получить список отзывов/жалоб
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFeedbackGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удаление freelance spec
         * @summary # Удаление freelance spec
         * @param {string} guid GUID freelance спека в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFreelanceSpecsGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsFreelanceSpecsGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/admins/freelance/specs/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактирование freelance spec
         * @summary # Редактирование freelance spec
         * @param {string} guid GUID freelance спека в БД.
         * @param {InlineObject34} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFreelanceSpecsGuidPatch: async (guid: string, body?: InlineObject34, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsFreelanceSpecsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/freelance/specs/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создание freelance spec
         * @summary # Создание freelance spec
         * @param {InlineObject33} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFreelanceSpecsPost: async (body?: InlineObject33, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/freelance/specs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров, которые находятся на проверке.   ## У таких товаров clientId != null && paidat = null   ## !!! Тоже из тех времен когда директор что-то проверял.   ## !!! Думаю надо деприкнуть его.   
         * @summary # Получить список товаров, которые находятся на проверке. 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetCheckingProductsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/get_checking_products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список оплаченных товаров.   
         * @summary # Получить список оплаченных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetPaidProductsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/get_paid_products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список продуктов с фильтром по статусу.   
         * @summary # Получить список продуктов с фильтром по статусу.
         * @param {number} [status] Статус заказа для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetProductsByStatusGet: async (status?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/get_products_by_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все актуальные настройки.   
         * @summary Получить все настройки.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetSettingsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/get_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров, которые ожидают проверку.   ## У таких товаров status = 0   
         * @summary # Получить список товаров, которые ожидают проверку. 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetWaitingProductsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/get_waiting_products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Создать оплату или штраф для пользователя.   
         * @summary # Создать оплату или штраф для пользователя.
         * @param {InlineObject28} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsMakePaymentPost: async (body?: InlineObject28, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/make_payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Оплатить товары.   ## Переводит статус на 110 (принадлежит платформе. распространяется бесплатно)    Вся информация о ресерчере удается: createdById меняется на id админа isCreatedByClient меняется true needCheckBySupervisor меняется true  Проверки: Нельзя повторно купить продукт (product.status === 70 && product.paidById !== null) Админ не может купить товар который уже принадлежит платформе (product.status === 110)
         * @summary # Оплатить товары.
         * @param {InlineObject36} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsMakePaymentsPost: async (body?: InlineObject36, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/make_payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список заказов.   
         * @summary # Получить список заказов.
         * @param {number} [status] Статус заказа для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsOrdersGet: async (status?: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список заказов с пагинацией.   
         * @summary # Получить список заказов с пагинацией.
         * @param {string} [status] Статусы заказа (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля:  asin, amazonTitle, skuByClient, id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsOrdersPagGet: async (status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/orders/pag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    ## Удалить patch_note по гуиду, доступно админу и модератору 
         * @summary # Удалить patch_note по гуиду.
         * @param {string} guid GUID патч_ноты в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsPatchNotesGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/admins/patch_notes/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    ## Обновление patch_note-ов по гуиду 
         * @summary # Обновить patch_note.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject30} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesGuidPatch: async (guid: string, body?: InlineObject30, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsPatchNotesGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/patch_notes/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   ## Создание patch_note, доступно админу и модератору.   
         * @summary # Создать patch_note.
         * @param {InlineObject29} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesPost: async (body?: InlineObject29, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/patch_notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    ## Получить все уникальные версии patch_note-ов.   
         * @summary # Получить версии patch_note.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesVersionsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/patch_notes/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Внести изменения в продукт (снять с биржи).   
         * @summary # Внести изменения в продукт (снять с биржи).
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject27} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchProductsGuidPatch: async (guid: string, body?: InlineObject27, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsPatchProductsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/patch_products/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удаление PaymentMethod   
         * @summary #  Удаление PaymentMethod
         * @param {string} guid GUID красного флага в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPaymentMethodGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsPaymentMethodGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/admins/payment_method/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить все оплаты, которые были начислены всем ролям.  
         * @summary # Получить все оплаты, которые были начислены всем ролям.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPaymentsGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Собрать пермишены.  На выход отдает json file с пермишенами
         * @summary # Собрать пермишены.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPermissionGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/permission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Привязать/отвязать юзера к товару   
         * @summary #  Привязать/отвязать юзера к товару
         * @param {InlineObject42} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProductLinkOrUnlinkUserRolePatch: async (body?: InlineObject42, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/product/link_or_unlink_user_role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список товаров c пагинацией.  
         * @summary # Получить список товаров c пагинацией.
         * @param {string} [status] Статусы продукта (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, skuByClient               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProductsPagGet: async (status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/products/pag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список  вакантных товаров. статусы 70 и 110  
         * @summary # Получить список вакантных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProductsVacGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/products/vac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список прокси   
         * @summary #  Получить список прокси
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProxyGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/proxy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить список прокси   
         * @summary #  Изменить список прокси
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProxyPost: async (body?: Array<string>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/proxy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить новый красный флаг
         * @summary # Удалить новый красный флаг
         * @param {string} guid GUID красного флага в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsRedFlagsGuidDelete: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsRedFlagsGuidDelete', 'guid', guid)
            const localVarPath = `/api/v1/admins/red_flags/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить красный флаг   
         * @summary #  Изменить красный флаг
         * @param {string} guid GUID красного флага в БД.
         * @param {InlineObject40} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsRedFlagsGuidPatch: async (guid: string, body?: InlineObject40, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsRedFlagsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/red_flags/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Создать новый красный флаг  
         * @summary #  Создать новый красный флаг
         * @param {InlineObject39} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsRedFlagsPost: async (body?: InlineObject39, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/red_flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить интервал нотификаций касательно product_listing_launches
         * @summary # Изменить интервал нотификаций касательно product_listing_launches
         * @param {number} value интервал нотификаций касательно product_listing_launches (в Секундах)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsSetLaunchPreDeadlineValuePatch: async (value: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'value' is not null or undefined
            assertParamExists('apiV1AdminsSetLaunchPreDeadlineValuePatch', 'value', value)
            const localVarPath = `/api/v1/admins/set_launch_pre_deadline/{value}`
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Установить динамические настройки.   
         * @summary # Установить динамические настройки.
         * @param {InlineObject32} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsSetSettingPatch: async (body?: InlineObject32, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/set_setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Изменить интервал нотификаций касательно дедлайна ордера
         * @summary # Изменить интервал нотификаций касательно дедлайна ордера
         * @param {number} value интервал нотификаций касательно дедлайна ордера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch: async (value: number, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'value' is not null or undefined
            assertParamExists('apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch', 'value', value)
            const localVarPath = `/api/v1/admins/set_timeToDeadlinePendingOrder/{value}`
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Удалить массив тегов   
         * @summary #  Удалить массив тегов
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTagsDelete: async (body?: Array<string>, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Редактирование тега   
         * @summary #  Редактирование тега
         * @param {string} guid GUID тега в БД.
         * @param {InlineObject41} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTagsGuidPatch: async (guid: string, body?: InlineObject41, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsTagsGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/tags/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить задачи.   
         * @summary #  Облегченная версия. Получить задачи.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [status] если указать статус - отфильтрует, нет - выведет все.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTasksLightGet: async (noCache?: boolean, status?: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/tasks_light`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить список задач c пагинацией.  
         * @summary # Получить список задач c пагинацией.
         * @param {string} [status] Статус задачи (можно указать несколько через запятую).
         * @param {string} [operationType] Тип задачи (можно указать несколько через запятую).
         * @param {string} [priority] Приоритет задачи (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, skuByClient, Id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTasksPagGet: async (status?: string, operationType?: string, priority?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/tasks/pag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Включить/выключить сервер   
         * @summary # Включить/выключить сервер
         * @param {InlineObject35} [body] 
         * @param {'on' | 'off'} [turn] Включатель сервера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsToggleServerPatch: async (body?: InlineObject35, turn?: 'on' | 'off', acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/toggle_server`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (turn !== undefined) {
                localVarQueryParameter['turn'] = turn;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Обновить пермишены.  На вход надо загрузить json file из роута admins/permission
         * @summary # Обновить пермишены.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUpdatePermissionPatch: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/update_permission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить пользователей по роли без сабов   
         * @summary #  Получить пользователей по роли
         * @param {number} role Роль юзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersByRoleGet: async (role: number, noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('apiV1AdminsUsersByRoleGet', 'role', role)
            const localVarPath = `/api/v1/admins/users_by_role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить всех пользователей или сабюзеров через query параметр   
         * @summary Получить всех пользователей. (DEPRECATED)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersGet: async (acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить пользователя по GUID.   
         * @summary Получить пользователя по GUID.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersGuidGet: async (guid: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsUsersGuidGet', 'guid', guid)
            const localVarPath = `/api/v1/admins/users/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ##  Изменить пользователя.  
         * @summary Изменить пользователя.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject31} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersGuidPatch: async (guid: string, body?: InlineObject31, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('apiV1AdminsUsersGuidPatch', 'guid', guid)
            const localVarPath = `/api/v1/admins/users/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Получить всех пользователей с пагинацией   
         * @summary Получить всех пользователей с пагинацией.
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersPagGet: async (filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/admins/users/pag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessTokenBearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortField !== undefined) {
                localVarQueryParameter['sortField'] = sortField;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['noCache'] = noCache;
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdministratorApi - functional programming interface
 * @export
 */
export const AdministratorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdministratorApiAxiosParamCreator(configuration)
    return {
        /**
         * ## Редактировать склад назначения.   
         * @summary #  Редактировать склад назначения.
         * @param {string} guid 
         * @param {InlineObject38} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsDestinationEditGuidPatch(guid: string, body?: InlineObject38, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsDestinationEditGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактировать склад назначения.   
         * @summary #  Редактировать склад назначения.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsDestinationGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsDestinationGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать склад назначения.   
         * @summary #  Создать склад назначения.
         * @param {InlineObject37} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsDestinationPost(body?: InlineObject37, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBodyWithGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsDestinationPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список отзывов/жалоб   
         * @summary #  Получить список отзывов/жалоб
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsFeedbackGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20026>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsFeedbackGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удаление freelance spec
         * @summary # Удаление freelance spec
         * @param {string} guid GUID freelance спека в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsFreelanceSpecsGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsFreelanceSpecsGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактирование freelance spec
         * @summary # Редактирование freelance spec
         * @param {string} guid GUID freelance спека в БД.
         * @param {InlineObject34} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsFreelanceSpecsGuidPatch(guid: string, body?: InlineObject34, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsFreelanceSpecsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создание freelance spec
         * @summary # Создание freelance spec
         * @param {InlineObject33} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsFreelanceSpecsPost(body?: InlineObject33, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBodyWithGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsFreelanceSpecsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров, которые находятся на проверке.   ## У таких товаров clientId != null && paidat = null   ## !!! Тоже из тех времен когда директор что-то проверял.   ## !!! Думаю надо деприкнуть его.   
         * @summary # Получить список товаров, которые находятся на проверке. 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsGetCheckingProductsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1BatchesProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsGetCheckingProductsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список оплаченных товаров.   
         * @summary # Получить список оплаченных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsGetPaidProductsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1BatchesProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsGetPaidProductsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список продуктов с фильтром по статусу.   
         * @summary # Получить список продуктов с фильтром по статусу.
         * @param {number} [status] Статус заказа для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsGetProductsByStatusGet(status?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1BatchesProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsGetProductsByStatusGet(status, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все актуальные настройки.   
         * @summary Получить все настройки.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsGetSettingsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsGetSettingsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров, которые ожидают проверку.   ## У таких товаров status = 0   
         * @summary # Получить список товаров, которые ожидают проверку. 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsGetWaitingProductsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1BatchesProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsGetWaitingProductsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Создать оплату или штраф для пользователя.   
         * @summary # Создать оплату или штраф для пользователя.
         * @param {InlineObject28} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsMakePaymentPost(body?: InlineObject28, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsMakePaymentPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Оплатить товары.   ## Переводит статус на 110 (принадлежит платформе. распространяется бесплатно)    Вся информация о ресерчере удается: createdById меняется на id админа isCreatedByClient меняется true needCheckBySupervisor меняется true  Проверки: Нельзя повторно купить продукт (product.status === 70 && product.paidById !== null) Админ не может купить товар который уже принадлежит платформе (product.status === 110)
         * @summary # Оплатить товары.
         * @param {InlineObject36} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsMakePaymentsPost(body?: InlineObject36, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsMakePaymentsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список заказов.   
         * @summary # Получить список заказов.
         * @param {number} [status] Статус заказа для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsOrdersGet(status?: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1BatchesOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsOrdersGet(status, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список заказов с пагинацией.   
         * @summary # Получить список заказов с пагинацией.
         * @param {string} [status] Статусы заказа (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля:  asin, amazonTitle, skuByClient, id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsOrdersPagGet(status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsOrdersPagGet(status, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *    ## Удалить patch_note по гуиду, доступно админу и модератору 
         * @summary # Удалить patch_note по гуиду.
         * @param {string} guid GUID патч_ноты в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPatchNotesGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPatchNotesGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *    ## Обновление patch_note-ов по гуиду 
         * @summary # Обновить patch_note.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject30} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPatchNotesGuidPatch(guid: string, body?: InlineObject30, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPatchNotesGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *   ## Создание patch_note, доступно админу и модератору.   
         * @summary # Создать patch_note.
         * @param {InlineObject29} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPatchNotesPost(body?: InlineObject29, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBodyWithGuid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPatchNotesPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *    ## Получить все уникальные версии patch_note-ов.   
         * @summary # Получить версии patch_note.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPatchNotesVersionsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPatchNotesVersionsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Внести изменения в продукт (снять с биржи).   
         * @summary # Внести изменения в продукт (снять с биржи).
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject27} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPatchProductsGuidPatch(guid: string, body?: InlineObject27, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPatchProductsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удаление PaymentMethod   
         * @summary #  Удаление PaymentMethod
         * @param {string} guid GUID красного флага в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPaymentMethodGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPaymentMethodGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить все оплаты, которые были начислены всем ролям.  
         * @summary # Получить все оплаты, которые были начислены всем ролям.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPaymentsGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20019>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPaymentsGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Собрать пермишены.  На выход отдает json file с пермишенами
         * @summary # Собрать пермишены.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsPermissionGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsPermissionGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Привязать/отвязать юзера к товару   
         * @summary #  Привязать/отвязать юзера к товару
         * @param {InlineObject42} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsProductLinkOrUnlinkUserRolePatch(body?: InlineObject42, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsProductLinkOrUnlinkUserRolePatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список товаров c пагинацией.  
         * @summary # Получить список товаров c пагинацией.
         * @param {string} [status] Статусы продукта (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, skuByClient               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsProductsPagGet(status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsProductsPagGet(status, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список  вакантных товаров. статусы 70 и 110  
         * @summary # Получить список вакантных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsProductsVacGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20023>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsProductsVacGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список прокси   
         * @summary #  Получить список прокси
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsProxyGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsProxyGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить список прокси   
         * @summary #  Изменить список прокси
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsProxyPost(body?: Array<string>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsProxyPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить новый красный флаг
         * @summary # Удалить новый красный флаг
         * @param {string} guid GUID красного флага в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsRedFlagsGuidDelete(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsRedFlagsGuidDelete(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить красный флаг   
         * @summary #  Изменить красный флаг
         * @param {string} guid GUID красного флага в БД.
         * @param {InlineObject40} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsRedFlagsGuidPatch(guid: string, body?: InlineObject40, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsRedFlagsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Создать новый красный флаг  
         * @summary #  Создать новый красный флаг
         * @param {InlineObject39} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsRedFlagsPost(body?: InlineObject39, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsRedFlagsPost(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить интервал нотификаций касательно product_listing_launches
         * @summary # Изменить интервал нотификаций касательно product_listing_launches
         * @param {number} value интервал нотификаций касательно product_listing_launches (в Секундах)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsSetLaunchPreDeadlineValuePatch(value: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsSetLaunchPreDeadlineValuePatch(value, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Установить динамические настройки.   
         * @summary # Установить динамические настройки.
         * @param {InlineObject32} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsSetSettingPatch(body?: InlineObject32, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsSetSettingPatch(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Изменить интервал нотификаций касательно дедлайна ордера
         * @summary # Изменить интервал нотификаций касательно дедлайна ордера
         * @param {number} value интервал нотификаций касательно дедлайна ордера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch(value: number, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch(value, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Удалить массив тегов   
         * @summary #  Удалить массив тегов
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsTagsDelete(body?: Array<string>, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsTagsDelete(body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Редактирование тега   
         * @summary #  Редактирование тега
         * @param {string} guid GUID тега в БД.
         * @param {InlineObject41} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsTagsGuidPatch(guid: string, body?: InlineObject41, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsTagsGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить задачи.   
         * @summary #  Облегченная версия. Получить задачи.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [status] если указать статус - отфильтрует, нет - выведет все.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsTasksLightGet(noCache?: boolean, status?: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20020>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsTasksLightGet(noCache, status, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить список задач c пагинацией.  
         * @summary # Получить список задач c пагинацией.
         * @param {string} [status] Статус задачи (можно указать несколько через запятую).
         * @param {string} [operationType] Тип задачи (можно указать несколько через запятую).
         * @param {string} [priority] Приоритет задачи (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, skuByClient, Id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsTasksPagGet(status?: string, operationType?: string, priority?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsTasksPagGet(status, operationType, priority, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Включить/выключить сервер   
         * @summary # Включить/выключить сервер
         * @param {InlineObject35} [body] 
         * @param {'on' | 'off'} [turn] Включатель сервера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsToggleServerPatch(body?: InlineObject35, turn?: 'on' | 'off', acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsToggleServerPatch(body, turn, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Обновить пермишены.  На вход надо загрузить json file из роута admins/permission
         * @summary # Обновить пермишены.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsUpdatePermissionPatch(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsUpdatePermissionPatch(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить пользователей по роли без сабов   
         * @summary #  Получить пользователей по роли
         * @param {number} role Роль юзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsUsersByRoleGet(role: number, noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20027>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsUsersByRoleGet(role, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить всех пользователей или сабюзеров через query параметр   
         * @summary Получить всех пользователей. (DEPRECATED)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsUsersGet(acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAdminFullSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsUsersGet(acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить пользователя по GUID.   
         * @summary Получить пользователя по GUID.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsUsersGuidGet(guid: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsUsersGuidGet(guid, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ##  Изменить пользователя.  
         * @summary Изменить пользователя.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject31} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsUsersGuidPatch(guid: string, body?: InlineObject31, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsUsersGuidPatch(guid, body, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Получить всех пользователей с пагинацией   
         * @summary Получить всех пользователей с пагинацией.
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminsUsersPagGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdminsUsersPagGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdministratorApi - factory interface
 * @export
 */
export const AdministratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdministratorApiFp(configuration)
    return {
        /**
         * ## Редактировать склад назначения.   
         * @summary #  Редактировать склад назначения.
         * @param {string} guid 
         * @param {InlineObject38} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsDestinationEditGuidPatch(guid: string, body?: InlineObject38, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsDestinationEditGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактировать склад назначения.   
         * @summary #  Редактировать склад назначения.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsDestinationGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsDestinationGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать склад назначения.   
         * @summary #  Создать склад назначения.
         * @param {InlineObject37} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsDestinationPost(body?: InlineObject37, acceptEncoding?: string, options?: any): AxiosPromise<SuccessResponseBodyWithGuid> {
            return localVarFp.apiV1AdminsDestinationPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список отзывов/жалоб   
         * @summary #  Получить список отзывов/жалоб
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFeedbackGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20026>> {
            return localVarFp.apiV1AdminsFeedbackGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удаление freelance spec
         * @summary # Удаление freelance spec
         * @param {string} guid GUID freelance спека в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFreelanceSpecsGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsFreelanceSpecsGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактирование freelance spec
         * @summary # Редактирование freelance spec
         * @param {string} guid GUID freelance спека в БД.
         * @param {InlineObject34} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFreelanceSpecsGuidPatch(guid: string, body?: InlineObject34, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsFreelanceSpecsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создание freelance spec
         * @summary # Создание freelance spec
         * @param {InlineObject33} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsFreelanceSpecsPost(body?: InlineObject33, acceptEncoding?: string, options?: any): AxiosPromise<SuccessResponseBodyWithGuid> {
            return localVarFp.apiV1AdminsFreelanceSpecsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров, которые находятся на проверке.   ## У таких товаров clientId != null && paidat = null   ## !!! Тоже из тех времен когда директор что-то проверял.   ## !!! Думаю надо деприкнуть его.   
         * @summary # Получить список товаров, которые находятся на проверке. 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetCheckingProductsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1BatchesProduct>> {
            return localVarFp.apiV1AdminsGetCheckingProductsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список оплаченных товаров.   
         * @summary # Получить список оплаченных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetPaidProductsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1BatchesProduct>> {
            return localVarFp.apiV1AdminsGetPaidProductsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список продуктов с фильтром по статусу.   
         * @summary # Получить список продуктов с фильтром по статусу.
         * @param {number} [status] Статус заказа для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetProductsByStatusGet(status?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1BatchesProduct>> {
            return localVarFp.apiV1AdminsGetProductsByStatusGet(status, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все актуальные настройки.   
         * @summary Получить все настройки.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetSettingsGet(acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1AdminsGetSettingsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров, которые ожидают проверку.   ## У таких товаров status = 0   
         * @summary # Получить список товаров, которые ожидают проверку. 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsGetWaitingProductsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1BatchesProduct>> {
            return localVarFp.apiV1AdminsGetWaitingProductsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Создать оплату или штраф для пользователя.   
         * @summary # Создать оплату или штраф для пользователя.
         * @param {InlineObject28} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsMakePaymentPost(body?: InlineObject28, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsMakePaymentPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Оплатить товары.   ## Переводит статус на 110 (принадлежит платформе. распространяется бесплатно)    Вся информация о ресерчере удается: createdById меняется на id админа isCreatedByClient меняется true needCheckBySupervisor меняется true  Проверки: Нельзя повторно купить продукт (product.status === 70 && product.paidById !== null) Админ не может купить товар который уже принадлежит платформе (product.status === 110)
         * @summary # Оплатить товары.
         * @param {InlineObject36} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsMakePaymentsPost(body?: InlineObject36, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsMakePaymentsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список заказов.   
         * @summary # Получить список заказов.
         * @param {number} [status] Статус заказа для фильтра.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsOrdersGet(status?: number, acceptEncoding?: string, options?: any): AxiosPromise<Array<ApiV1BatchesOrder>> {
            return localVarFp.apiV1AdminsOrdersGet(status, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список заказов с пагинацией.   
         * @summary # Получить список заказов с пагинацией.
         * @param {string} [status] Статусы заказа (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля:  asin, amazonTitle, skuByClient, id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsOrdersPagGet(status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.apiV1AdminsOrdersPagGet(status, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *    ## Удалить patch_note по гуиду, доступно админу и модератору 
         * @summary # Удалить patch_note по гуиду.
         * @param {string} guid GUID патч_ноты в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsPatchNotesGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *    ## Обновление patch_note-ов по гуиду 
         * @summary # Обновить patch_note.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject30} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesGuidPatch(guid: string, body?: InlineObject30, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsPatchNotesGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *   ## Создание patch_note, доступно админу и модератору.   
         * @summary # Создать patch_note.
         * @param {InlineObject29} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesPost(body?: InlineObject29, acceptEncoding?: string, options?: any): AxiosPromise<SuccessResponseBodyWithGuid> {
            return localVarFp.apiV1AdminsPatchNotesPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         *    ## Получить все уникальные версии patch_note-ов.   
         * @summary # Получить версии patch_note.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchNotesVersionsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiV1AdminsPatchNotesVersionsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Внести изменения в продукт (снять с биржи).   
         * @summary # Внести изменения в продукт (снять с биржи).
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject27} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPatchProductsGuidPatch(guid: string, body?: InlineObject27, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsPatchProductsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удаление PaymentMethod   
         * @summary #  Удаление PaymentMethod
         * @param {string} guid GUID красного флага в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPaymentMethodGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsPaymentMethodGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить все оплаты, которые были начислены всем ролям.  
         * @summary # Получить все оплаты, которые были начислены всем ролям.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPaymentsGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20019>> {
            return localVarFp.apiV1AdminsPaymentsGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Собрать пермишены.  На выход отдает json file с пермишенами
         * @summary # Собрать пермишены.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsPermissionGet(acceptEncoding?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AdminsPermissionGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Привязать/отвязать юзера к товару   
         * @summary #  Привязать/отвязать юзера к товару
         * @param {InlineObject42} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProductLinkOrUnlinkUserRolePatch(body?: InlineObject42, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsProductLinkOrUnlinkUserRolePatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список товаров c пагинацией.  
         * @summary # Получить список товаров c пагинацией.
         * @param {string} [status] Статусы продукта (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, skuByClient               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProductsPagGet(status?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.apiV1AdminsProductsPagGet(status, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список  вакантных товаров. статусы 70 и 110  
         * @summary # Получить список вакантных товаров.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProductsVacGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20023>> {
            return localVarFp.apiV1AdminsProductsVacGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список прокси   
         * @summary #  Получить список прокси
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProxyGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiV1AdminsProxyGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить список прокси   
         * @summary #  Изменить список прокси
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsProxyPost(body?: Array<string>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsProxyPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить новый красный флаг
         * @summary # Удалить новый красный флаг
         * @param {string} guid GUID красного флага в БД.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsRedFlagsGuidDelete(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsRedFlagsGuidDelete(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить красный флаг   
         * @summary #  Изменить красный флаг
         * @param {string} guid GUID красного флага в БД.
         * @param {InlineObject40} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsRedFlagsGuidPatch(guid: string, body?: InlineObject40, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsRedFlagsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Создать новый красный флаг  
         * @summary #  Создать новый красный флаг
         * @param {InlineObject39} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsRedFlagsPost(body?: InlineObject39, acceptEncoding?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.apiV1AdminsRedFlagsPost(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить интервал нотификаций касательно product_listing_launches
         * @summary # Изменить интервал нотификаций касательно product_listing_launches
         * @param {number} value интервал нотификаций касательно product_listing_launches (в Секундах)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsSetLaunchPreDeadlineValuePatch(value: number, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsSetLaunchPreDeadlineValuePatch(value, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Установить динамические настройки.   
         * @summary # Установить динамические настройки.
         * @param {InlineObject32} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsSetSettingPatch(body?: InlineObject32, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsSetSettingPatch(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Изменить интервал нотификаций касательно дедлайна ордера
         * @summary # Изменить интервал нотификаций касательно дедлайна ордера
         * @param {number} value интервал нотификаций касательно дедлайна ордера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch(value: number, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch(value, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Удалить массив тегов   
         * @summary #  Удалить массив тегов
         * @param {Array<string>} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTagsDelete(body?: Array<string>, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsTagsDelete(body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Редактирование тега   
         * @summary #  Редактирование тега
         * @param {string} guid GUID тега в БД.
         * @param {InlineObject41} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTagsGuidPatch(guid: string, body?: InlineObject41, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsTagsGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить задачи.   
         * @summary #  Облегченная версия. Получить задачи.
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [status] если указать статус - отфильтрует, нет - выведет все.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTasksLightGet(noCache?: boolean, status?: string, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20020>> {
            return localVarFp.apiV1AdminsTasksLightGet(noCache, status, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить список задач c пагинацией.  
         * @summary # Получить список задач c пагинацией.
         * @param {string} [status] Статус задачи (можно указать несколько через запятую).
         * @param {string} [operationType] Тип задачи (можно указать несколько через запятую).
         * @param {string} [priority] Приоритет задачи (можно указать несколько через запятую).
         * @param {string} [filters]                Возможные поля: asin, amazonTitle, skuByClient, Id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsTasksPagGet(status?: string, operationType?: string, priority?: string, filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.apiV1AdminsTasksPagGet(status, operationType, priority, filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Включить/выключить сервер   
         * @summary # Включить/выключить сервер
         * @param {InlineObject35} [body] 
         * @param {'on' | 'off'} [turn] Включатель сервера
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsToggleServerPatch(body?: InlineObject35, turn?: 'on' | 'off', acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.apiV1AdminsToggleServerPatch(body, turn, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Обновить пермишены.  На вход надо загрузить json file из роута admins/permission
         * @summary # Обновить пермишены.
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUpdatePermissionPatch(acceptEncoding?: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AdminsUpdatePermissionPatch(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить пользователей по роли без сабов   
         * @summary #  Получить пользователей по роли
         * @param {number} role Роль юзера
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersByRoleGet(role: number, noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<Array<InlineResponse20027>> {
            return localVarFp.apiV1AdminsUsersByRoleGet(role, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить всех пользователей или сабюзеров через query параметр   
         * @summary Получить всех пользователей. (DEPRECATED)
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersGet(acceptEncoding?: string, options?: any): AxiosPromise<Array<UserAdminFullSchema>> {
            return localVarFp.apiV1AdminsUsersGet(acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить пользователя по GUID.   
         * @summary Получить пользователя по GUID.
         * @param {string} guid 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersGuidGet(guid: string, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.apiV1AdminsUsersGuidGet(guid, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ##  Изменить пользователя.  
         * @summary Изменить пользователя.
         * @param {string} guid GUID продукта в БД.
         * @param {InlineObject31} [body] 
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersGuidPatch(guid: string, body?: InlineObject31, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AdminsUsersGuidPatch(guid, body, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Получить всех пользователей с пагинацией   
         * @summary Получить всех пользователей с пагинацией.
         * @param {string} [filters]                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
         * @param {number} [limit] Лимит записей для пагинации
         * @param {number} [offset] Смещение для пагинации
         * @param {string} [sortField] Название поля
         * @param {'ASC' | 'DESC'} [sortType] Тип сортировки
         * @param {boolean} [noCache] Игнорировать данные в кеше
         * @param {string} [acceptEncoding] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminsUsersPagGet(filters?: string, limit?: number, offset?: number, sortField?: string, sortType?: 'ASC' | 'DESC', noCache?: boolean, acceptEncoding?: string, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.apiV1AdminsUsersPagGet(filters, limit, offset, sortField, sortType, noCache, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1AdminsDestinationEditGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsDestinationEditGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsDestinationEditGuidPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsDestinationEditGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject38}
     * @memberof AdministratorApiApiV1AdminsDestinationEditGuidPatch
     */
    readonly body?: InlineObject38

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsDestinationEditGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsDestinationGuidDelete operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsDestinationGuidDeleteRequest
 */
export interface AdministratorApiApiV1AdminsDestinationGuidDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsDestinationGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsDestinationGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsDestinationPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsDestinationPostRequest
 */
export interface AdministratorApiApiV1AdminsDestinationPostRequest {
    /**
     * 
     * @type {InlineObject37}
     * @memberof AdministratorApiApiV1AdminsDestinationPost
     */
    readonly body?: InlineObject37

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsDestinationPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsFeedbackGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsFeedbackGetRequest
 */
export interface AdministratorApiApiV1AdminsFeedbackGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsFeedbackGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsFreelanceSpecsGuidDelete operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsFreelanceSpecsGuidDeleteRequest
 */
export interface AdministratorApiApiV1AdminsFreelanceSpecsGuidDeleteRequest {
    /**
     * GUID freelance спека в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsFreelanceSpecsGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsFreelanceSpecsGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsFreelanceSpecsGuidPatchRequest {
    /**
     * GUID freelance спека в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject34}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsGuidPatch
     */
    readonly body?: InlineObject34

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsFreelanceSpecsPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsFreelanceSpecsPostRequest
 */
export interface AdministratorApiApiV1AdminsFreelanceSpecsPostRequest {
    /**
     * 
     * @type {InlineObject33}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsPost
     */
    readonly body?: InlineObject33

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsFreelanceSpecsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsGetCheckingProductsGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsGetCheckingProductsGetRequest
 */
export interface AdministratorApiApiV1AdminsGetCheckingProductsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsGetCheckingProductsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsGetPaidProductsGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsGetPaidProductsGetRequest
 */
export interface AdministratorApiApiV1AdminsGetPaidProductsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsGetPaidProductsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsGetProductsByStatusGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsGetProductsByStatusGetRequest
 */
export interface AdministratorApiApiV1AdminsGetProductsByStatusGetRequest {
    /**
     * Статус заказа для фильтра.
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsGetProductsByStatusGet
     */
    readonly status?: number

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsGetProductsByStatusGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsGetSettingsGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsGetSettingsGetRequest
 */
export interface AdministratorApiApiV1AdminsGetSettingsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsGetSettingsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsGetWaitingProductsGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsGetWaitingProductsGetRequest
 */
export interface AdministratorApiApiV1AdminsGetWaitingProductsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsGetWaitingProductsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsMakePaymentPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsMakePaymentPostRequest
 */
export interface AdministratorApiApiV1AdminsMakePaymentPostRequest {
    /**
     * 
     * @type {InlineObject28}
     * @memberof AdministratorApiApiV1AdminsMakePaymentPost
     */
    readonly body?: InlineObject28

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsMakePaymentPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsMakePaymentsPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsMakePaymentsPostRequest
 */
export interface AdministratorApiApiV1AdminsMakePaymentsPostRequest {
    /**
     * 
     * @type {InlineObject36}
     * @memberof AdministratorApiApiV1AdminsMakePaymentsPost
     */
    readonly body?: InlineObject36

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsMakePaymentsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsOrdersGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsOrdersGetRequest
 */
export interface AdministratorApiApiV1AdminsOrdersGetRequest {
    /**
     * Статус заказа для фильтра.
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsOrdersGet
     */
    readonly status?: number

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsOrdersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsOrdersPagGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsOrdersPagGetRequest
 */
export interface AdministratorApiApiV1AdminsOrdersPagGetRequest {
    /**
     * Статусы заказа (можно указать несколько через запятую).
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly status?: string

    /**
     *                Возможные поля:  asin, amazonTitle, skuByClient, id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsOrdersPagGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPatchNotesGuidDelete operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPatchNotesGuidDeleteRequest
 */
export interface AdministratorApiApiV1AdminsPatchNotesGuidDeleteRequest {
    /**
     * GUID патч_ноты в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchNotesGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchNotesGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPatchNotesGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPatchNotesGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsPatchNotesGuidPatchRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchNotesGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject30}
     * @memberof AdministratorApiApiV1AdminsPatchNotesGuidPatch
     */
    readonly body?: InlineObject30

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchNotesGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPatchNotesPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPatchNotesPostRequest
 */
export interface AdministratorApiApiV1AdminsPatchNotesPostRequest {
    /**
     * 
     * @type {InlineObject29}
     * @memberof AdministratorApiApiV1AdminsPatchNotesPost
     */
    readonly body?: InlineObject29

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchNotesPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPatchNotesVersionsGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPatchNotesVersionsGetRequest
 */
export interface AdministratorApiApiV1AdminsPatchNotesVersionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchNotesVersionsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPatchProductsGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPatchProductsGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsPatchProductsGuidPatchRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchProductsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject27}
     * @memberof AdministratorApiApiV1AdminsPatchProductsGuidPatch
     */
    readonly body?: InlineObject27

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPatchProductsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPaymentMethodGuidDelete operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPaymentMethodGuidDeleteRequest
 */
export interface AdministratorApiApiV1AdminsPaymentMethodGuidDeleteRequest {
    /**
     * GUID красного флага в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPaymentMethodGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPaymentMethodGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPaymentsGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPaymentsGetRequest
 */
export interface AdministratorApiApiV1AdminsPaymentsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPaymentsGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsPermissionGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsPermissionGetRequest
 */
export interface AdministratorApiApiV1AdminsPermissionGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsPermissionGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsProductLinkOrUnlinkUserRolePatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsProductLinkOrUnlinkUserRolePatchRequest
 */
export interface AdministratorApiApiV1AdminsProductLinkOrUnlinkUserRolePatchRequest {
    /**
     * 
     * @type {InlineObject42}
     * @memberof AdministratorApiApiV1AdminsProductLinkOrUnlinkUserRolePatch
     */
    readonly body?: InlineObject42

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProductLinkOrUnlinkUserRolePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsProductsPagGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsProductsPagGetRequest
 */
export interface AdministratorApiApiV1AdminsProductsPagGetRequest {
    /**
     * Статусы продукта (можно указать несколько через запятую).
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly status?: string

    /**
     *                Возможные поля: asin, amazonTitle, skuByClient               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProductsPagGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsProductsVacGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsProductsVacGetRequest
 */
export interface AdministratorApiApiV1AdminsProductsVacGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProductsVacGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsProxyGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsProxyGetRequest
 */
export interface AdministratorApiApiV1AdminsProxyGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProxyGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsProxyPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsProxyPostRequest
 */
export interface AdministratorApiApiV1AdminsProxyPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AdministratorApiApiV1AdminsProxyPost
     */
    readonly body?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsProxyPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsRedFlagsGuidDelete operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsRedFlagsGuidDeleteRequest
 */
export interface AdministratorApiApiV1AdminsRedFlagsGuidDeleteRequest {
    /**
     * GUID красного флага в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsRedFlagsGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsRedFlagsGuidDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsRedFlagsGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsRedFlagsGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsRedFlagsGuidPatchRequest {
    /**
     * GUID красного флага в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsRedFlagsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject40}
     * @memberof AdministratorApiApiV1AdminsRedFlagsGuidPatch
     */
    readonly body?: InlineObject40

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsRedFlagsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsRedFlagsPost operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsRedFlagsPostRequest
 */
export interface AdministratorApiApiV1AdminsRedFlagsPostRequest {
    /**
     * 
     * @type {InlineObject39}
     * @memberof AdministratorApiApiV1AdminsRedFlagsPost
     */
    readonly body?: InlineObject39

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsRedFlagsPost
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsSetLaunchPreDeadlineValuePatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsSetLaunchPreDeadlineValuePatchRequest
 */
export interface AdministratorApiApiV1AdminsSetLaunchPreDeadlineValuePatchRequest {
    /**
     * интервал нотификаций касательно product_listing_launches (в Секундах)
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsSetLaunchPreDeadlineValuePatch
     */
    readonly value: number

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsSetLaunchPreDeadlineValuePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsSetSettingPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsSetSettingPatchRequest
 */
export interface AdministratorApiApiV1AdminsSetSettingPatchRequest {
    /**
     * 
     * @type {InlineObject32}
     * @memberof AdministratorApiApiV1AdminsSetSettingPatch
     */
    readonly body?: InlineObject32

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsSetSettingPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsSetTimeToDeadlinePendingOrderValuePatchRequest
 */
export interface AdministratorApiApiV1AdminsSetTimeToDeadlinePendingOrderValuePatchRequest {
    /**
     * интервал нотификаций касательно дедлайна ордера
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsSetTimeToDeadlinePendingOrderValuePatch
     */
    readonly value: number

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsSetTimeToDeadlinePendingOrderValuePatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsTagsDelete operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsTagsDeleteRequest
 */
export interface AdministratorApiApiV1AdminsTagsDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AdministratorApiApiV1AdminsTagsDelete
     */
    readonly body?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTagsDelete
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsTagsGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsTagsGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsTagsGuidPatchRequest {
    /**
     * GUID тега в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTagsGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject41}
     * @memberof AdministratorApiApiV1AdminsTagsGuidPatch
     */
    readonly body?: InlineObject41

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTagsGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsTasksLightGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsTasksLightGetRequest
 */
export interface AdministratorApiApiV1AdminsTasksLightGetRequest {
    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof AdministratorApiApiV1AdminsTasksLightGet
     */
    readonly noCache?: boolean

    /**
     * если указать статус - отфильтрует, нет - выведет все.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksLightGet
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksLightGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsTasksPagGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsTasksPagGetRequest
 */
export interface AdministratorApiApiV1AdminsTasksPagGetRequest {
    /**
     * Статус задачи (можно указать несколько через запятую).
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly status?: string

    /**
     * Тип задачи (можно указать несколько через запятую).
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly operationType?: string

    /**
     * Приоритет задачи (можно указать несколько через запятую).
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly priority?: string

    /**
     *                Возможные поля: asin, amazonTitle, skuByClient, Id               Поиск для полей продукта идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Продукт               Поиск для полей заказа идет через схему Задача -&gt; Коробка -&gt; Айтем коробки -&gt; Заказ               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsTasksPagGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsToggleServerPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsToggleServerPatchRequest
 */
export interface AdministratorApiApiV1AdminsToggleServerPatchRequest {
    /**
     * 
     * @type {InlineObject35}
     * @memberof AdministratorApiApiV1AdminsToggleServerPatch
     */
    readonly body?: InlineObject35

    /**
     * Включатель сервера
     * @type {'on' | 'off'}
     * @memberof AdministratorApiApiV1AdminsToggleServerPatch
     */
    readonly turn?: 'on' | 'off'

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsToggleServerPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsUpdatePermissionPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsUpdatePermissionPatchRequest
 */
export interface AdministratorApiApiV1AdminsUpdatePermissionPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUpdatePermissionPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsUsersByRoleGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsUsersByRoleGetRequest
 */
export interface AdministratorApiApiV1AdminsUsersByRoleGetRequest {
    /**
     * Роль юзера
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsUsersByRoleGet
     */
    readonly role: number

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof AdministratorApiApiV1AdminsUsersByRoleGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersByRoleGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsUsersGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsUsersGetRequest
 */
export interface AdministratorApiApiV1AdminsUsersGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsUsersGuidGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsUsersGuidGetRequest
 */
export interface AdministratorApiApiV1AdminsUsersGuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersGuidGet
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsUsersGuidPatch operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsUsersGuidPatchRequest
 */
export interface AdministratorApiApiV1AdminsUsersGuidPatchRequest {
    /**
     * GUID продукта в БД.
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersGuidPatch
     */
    readonly guid: string

    /**
     * 
     * @type {InlineObject31}
     * @memberof AdministratorApiApiV1AdminsUsersGuidPatch
     */
    readonly body?: InlineObject31

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersGuidPatch
     */
    readonly acceptEncoding?: string
}

/**
 * Request parameters for apiV1AdminsUsersPagGet operation in AdministratorApi.
 * @export
 * @interface AdministratorApiApiV1AdminsUsersPagGetRequest
 */
export interface AdministratorApiApiV1AdminsUsersPagGetRequest {
    /**
     *                Возможные поля - любые поля продукта               2 варианта использования:                 1. Фильтр по одному полю:                   [amazonTitle][$eq]&#x3D;some_title                 2. Фильтр по нескольким полям:                   or[0][amazonTitle][$eq]&#x3D;some_title;or[1][asin][$eq]&#x3D;some_asin                     Возвращает партии с коробками с продуктами, в которых amazonTitle равен some_title или asin равен some_asin               2 оператора совпадения:                 $eq - полное совпадение, нечувствителен к регистру                 $contains - наличие данной подстроки в поле, нечувствителен к регистру, предназначен только для строк                 $lt - less than (меньше)                 $gt - greater than (больше)                 $lte - less than or equal to (меньше или равно)                 $gte - greater than or equal to (больше или равно)                 $null - является ли поле NULL                 $notnull - не является ли поле NULL                 $any - значение поля соответствует любому из значений в массиве (Строка с разделителем -&gt; \&#39;,\&#39; example&#x3D;3,5,6,null)             
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly filters?: string

    /**
     * Лимит записей для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly limit?: number

    /**
     * Смещение для пагинации
     * @type {number}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly offset?: number

    /**
     * Название поля
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly sortField?: string

    /**
     * Тип сортировки
     * @type {'ASC' | 'DESC'}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly sortType?: 'ASC' | 'DESC'

    /**
     * Игнорировать данные в кеше
     * @type {boolean}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly noCache?: boolean

    /**
     * 
     * @type {string}
     * @memberof AdministratorApiApiV1AdminsUsersPagGet
     */
    readonly acceptEncoding?: string
}

/**
 * AdministratorApi - object-oriented interface
 * @export
 * @class AdministratorApi
 * @extends {BaseAPI}
 */
export class AdministratorApi extends BaseAPI {
    /**
     * ## Редактировать склад назначения.   
     * @summary #  Редактировать склад назначения.
     * @param {AdministratorApiApiV1AdminsDestinationEditGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsDestinationEditGuidPatch(requestParameters: AdministratorApiApiV1AdminsDestinationEditGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsDestinationEditGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактировать склад назначения.   
     * @summary #  Редактировать склад назначения.
     * @param {AdministratorApiApiV1AdminsDestinationGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsDestinationGuidDelete(requestParameters: AdministratorApiApiV1AdminsDestinationGuidDeleteRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsDestinationGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать склад назначения.   
     * @summary #  Создать склад назначения.
     * @param {AdministratorApiApiV1AdminsDestinationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsDestinationPost(requestParameters: AdministratorApiApiV1AdminsDestinationPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsDestinationPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список отзывов/жалоб   
     * @summary #  Получить список отзывов/жалоб
     * @param {AdministratorApiApiV1AdminsFeedbackGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsFeedbackGet(requestParameters: AdministratorApiApiV1AdminsFeedbackGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsFeedbackGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удаление freelance spec
     * @summary # Удаление freelance spec
     * @param {AdministratorApiApiV1AdminsFreelanceSpecsGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsFreelanceSpecsGuidDelete(requestParameters: AdministratorApiApiV1AdminsFreelanceSpecsGuidDeleteRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsFreelanceSpecsGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактирование freelance spec
     * @summary # Редактирование freelance spec
     * @param {AdministratorApiApiV1AdminsFreelanceSpecsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsFreelanceSpecsGuidPatch(requestParameters: AdministratorApiApiV1AdminsFreelanceSpecsGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsFreelanceSpecsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создание freelance spec
     * @summary # Создание freelance spec
     * @param {AdministratorApiApiV1AdminsFreelanceSpecsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsFreelanceSpecsPost(requestParameters: AdministratorApiApiV1AdminsFreelanceSpecsPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsFreelanceSpecsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров, которые находятся на проверке.   ## У таких товаров clientId != null && paidat = null   ## !!! Тоже из тех времен когда директор что-то проверял.   ## !!! Думаю надо деприкнуть его.   
     * @summary # Получить список товаров, которые находятся на проверке. 
     * @param {AdministratorApiApiV1AdminsGetCheckingProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsGetCheckingProductsGet(requestParameters: AdministratorApiApiV1AdminsGetCheckingProductsGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsGetCheckingProductsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список оплаченных товаров.   
     * @summary # Получить список оплаченных товаров.
     * @param {AdministratorApiApiV1AdminsGetPaidProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsGetPaidProductsGet(requestParameters: AdministratorApiApiV1AdminsGetPaidProductsGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsGetPaidProductsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список продуктов с фильтром по статусу.   
     * @summary # Получить список продуктов с фильтром по статусу.
     * @param {AdministratorApiApiV1AdminsGetProductsByStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsGetProductsByStatusGet(requestParameters: AdministratorApiApiV1AdminsGetProductsByStatusGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsGetProductsByStatusGet(requestParameters.status, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все актуальные настройки.   
     * @summary Получить все настройки.
     * @param {AdministratorApiApiV1AdminsGetSettingsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsGetSettingsGet(requestParameters: AdministratorApiApiV1AdminsGetSettingsGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsGetSettingsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров, которые ожидают проверку.   ## У таких товаров status = 0   
     * @summary # Получить список товаров, которые ожидают проверку. 
     * @param {AdministratorApiApiV1AdminsGetWaitingProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsGetWaitingProductsGet(requestParameters: AdministratorApiApiV1AdminsGetWaitingProductsGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsGetWaitingProductsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Создать оплату или штраф для пользователя.   
     * @summary # Создать оплату или штраф для пользователя.
     * @param {AdministratorApiApiV1AdminsMakePaymentPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsMakePaymentPost(requestParameters: AdministratorApiApiV1AdminsMakePaymentPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsMakePaymentPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Оплатить товары.   ## Переводит статус на 110 (принадлежит платформе. распространяется бесплатно)    Вся информация о ресерчере удается: createdById меняется на id админа isCreatedByClient меняется true needCheckBySupervisor меняется true  Проверки: Нельзя повторно купить продукт (product.status === 70 && product.paidById !== null) Админ не может купить товар который уже принадлежит платформе (product.status === 110)
     * @summary # Оплатить товары.
     * @param {AdministratorApiApiV1AdminsMakePaymentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsMakePaymentsPost(requestParameters: AdministratorApiApiV1AdminsMakePaymentsPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsMakePaymentsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список заказов.   
     * @summary # Получить список заказов.
     * @param {AdministratorApiApiV1AdminsOrdersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsOrdersGet(requestParameters: AdministratorApiApiV1AdminsOrdersGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsOrdersGet(requestParameters.status, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список заказов с пагинацией.   
     * @summary # Получить список заказов с пагинацией.
     * @param {AdministratorApiApiV1AdminsOrdersPagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsOrdersPagGet(requestParameters: AdministratorApiApiV1AdminsOrdersPagGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsOrdersPagGet(requestParameters.status, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    ## Удалить patch_note по гуиду, доступно админу и модератору 
     * @summary # Удалить patch_note по гуиду.
     * @param {AdministratorApiApiV1AdminsPatchNotesGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPatchNotesGuidDelete(requestParameters: AdministratorApiApiV1AdminsPatchNotesGuidDeleteRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPatchNotesGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    ## Обновление patch_note-ов по гуиду 
     * @summary # Обновить patch_note.
     * @param {AdministratorApiApiV1AdminsPatchNotesGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPatchNotesGuidPatch(requestParameters: AdministratorApiApiV1AdminsPatchNotesGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPatchNotesGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *   ## Создание patch_note, доступно админу и модератору.   
     * @summary # Создать patch_note.
     * @param {AdministratorApiApiV1AdminsPatchNotesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPatchNotesPost(requestParameters: AdministratorApiApiV1AdminsPatchNotesPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPatchNotesPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    ## Получить все уникальные версии patch_note-ов.   
     * @summary # Получить версии patch_note.
     * @param {AdministratorApiApiV1AdminsPatchNotesVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPatchNotesVersionsGet(requestParameters: AdministratorApiApiV1AdminsPatchNotesVersionsGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPatchNotesVersionsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Внести изменения в продукт (снять с биржи).   
     * @summary # Внести изменения в продукт (снять с биржи).
     * @param {AdministratorApiApiV1AdminsPatchProductsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPatchProductsGuidPatch(requestParameters: AdministratorApiApiV1AdminsPatchProductsGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPatchProductsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удаление PaymentMethod   
     * @summary #  Удаление PaymentMethod
     * @param {AdministratorApiApiV1AdminsPaymentMethodGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPaymentMethodGuidDelete(requestParameters: AdministratorApiApiV1AdminsPaymentMethodGuidDeleteRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPaymentMethodGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить все оплаты, которые были начислены всем ролям.  
     * @summary # Получить все оплаты, которые были начислены всем ролям.
     * @param {AdministratorApiApiV1AdminsPaymentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPaymentsGet(requestParameters: AdministratorApiApiV1AdminsPaymentsGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPaymentsGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Собрать пермишены.  На выход отдает json file с пермишенами
     * @summary # Собрать пермишены.
     * @param {AdministratorApiApiV1AdminsPermissionGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsPermissionGet(requestParameters: AdministratorApiApiV1AdminsPermissionGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsPermissionGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Привязать/отвязать юзера к товару   
     * @summary #  Привязать/отвязать юзера к товару
     * @param {AdministratorApiApiV1AdminsProductLinkOrUnlinkUserRolePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsProductLinkOrUnlinkUserRolePatch(requestParameters: AdministratorApiApiV1AdminsProductLinkOrUnlinkUserRolePatchRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsProductLinkOrUnlinkUserRolePatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список товаров c пагинацией.  
     * @summary # Получить список товаров c пагинацией.
     * @param {AdministratorApiApiV1AdminsProductsPagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsProductsPagGet(requestParameters: AdministratorApiApiV1AdminsProductsPagGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsProductsPagGet(requestParameters.status, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список  вакантных товаров. статусы 70 и 110  
     * @summary # Получить список вакантных товаров.
     * @param {AdministratorApiApiV1AdminsProductsVacGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsProductsVacGet(requestParameters: AdministratorApiApiV1AdminsProductsVacGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsProductsVacGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список прокси   
     * @summary #  Получить список прокси
     * @param {AdministratorApiApiV1AdminsProxyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsProxyGet(requestParameters: AdministratorApiApiV1AdminsProxyGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsProxyGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить список прокси   
     * @summary #  Изменить список прокси
     * @param {AdministratorApiApiV1AdminsProxyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsProxyPost(requestParameters: AdministratorApiApiV1AdminsProxyPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsProxyPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить новый красный флаг
     * @summary # Удалить новый красный флаг
     * @param {AdministratorApiApiV1AdminsRedFlagsGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsRedFlagsGuidDelete(requestParameters: AdministratorApiApiV1AdminsRedFlagsGuidDeleteRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsRedFlagsGuidDelete(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить красный флаг   
     * @summary #  Изменить красный флаг
     * @param {AdministratorApiApiV1AdminsRedFlagsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsRedFlagsGuidPatch(requestParameters: AdministratorApiApiV1AdminsRedFlagsGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsRedFlagsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Создать новый красный флаг  
     * @summary #  Создать новый красный флаг
     * @param {AdministratorApiApiV1AdminsRedFlagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsRedFlagsPost(requestParameters: AdministratorApiApiV1AdminsRedFlagsPostRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsRedFlagsPost(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить интервал нотификаций касательно product_listing_launches
     * @summary # Изменить интервал нотификаций касательно product_listing_launches
     * @param {AdministratorApiApiV1AdminsSetLaunchPreDeadlineValuePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsSetLaunchPreDeadlineValuePatch(requestParameters: AdministratorApiApiV1AdminsSetLaunchPreDeadlineValuePatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsSetLaunchPreDeadlineValuePatch(requestParameters.value, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Установить динамические настройки.   
     * @summary # Установить динамические настройки.
     * @param {AdministratorApiApiV1AdminsSetSettingPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsSetSettingPatch(requestParameters: AdministratorApiApiV1AdminsSetSettingPatchRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsSetSettingPatch(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Изменить интервал нотификаций касательно дедлайна ордера
     * @summary # Изменить интервал нотификаций касательно дедлайна ордера
     * @param {AdministratorApiApiV1AdminsSetTimeToDeadlinePendingOrderValuePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch(requestParameters: AdministratorApiApiV1AdminsSetTimeToDeadlinePendingOrderValuePatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsSetTimeToDeadlinePendingOrderValuePatch(requestParameters.value, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Удалить массив тегов   
     * @summary #  Удалить массив тегов
     * @param {AdministratorApiApiV1AdminsTagsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsTagsDelete(requestParameters: AdministratorApiApiV1AdminsTagsDeleteRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsTagsDelete(requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Редактирование тега   
     * @summary #  Редактирование тега
     * @param {AdministratorApiApiV1AdminsTagsGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsTagsGuidPatch(requestParameters: AdministratorApiApiV1AdminsTagsGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsTagsGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить задачи.   
     * @summary #  Облегченная версия. Получить задачи.
     * @param {AdministratorApiApiV1AdminsTasksLightGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsTasksLightGet(requestParameters: AdministratorApiApiV1AdminsTasksLightGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsTasksLightGet(requestParameters.noCache, requestParameters.status, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить список задач c пагинацией.  
     * @summary # Получить список задач c пагинацией.
     * @param {AdministratorApiApiV1AdminsTasksPagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsTasksPagGet(requestParameters: AdministratorApiApiV1AdminsTasksPagGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsTasksPagGet(requestParameters.status, requestParameters.operationType, requestParameters.priority, requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Включить/выключить сервер   
     * @summary # Включить/выключить сервер
     * @param {AdministratorApiApiV1AdminsToggleServerPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsToggleServerPatch(requestParameters: AdministratorApiApiV1AdminsToggleServerPatchRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsToggleServerPatch(requestParameters.body, requestParameters.turn, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Обновить пермишены.  На вход надо загрузить json file из роута admins/permission
     * @summary # Обновить пермишены.
     * @param {AdministratorApiApiV1AdminsUpdatePermissionPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsUpdatePermissionPatch(requestParameters: AdministratorApiApiV1AdminsUpdatePermissionPatchRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsUpdatePermissionPatch(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить пользователей по роли без сабов   
     * @summary #  Получить пользователей по роли
     * @param {AdministratorApiApiV1AdminsUsersByRoleGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsUsersByRoleGet(requestParameters: AdministratorApiApiV1AdminsUsersByRoleGetRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsUsersByRoleGet(requestParameters.role, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить всех пользователей или сабюзеров через query параметр   
     * @summary Получить всех пользователей. (DEPRECATED)
     * @param {AdministratorApiApiV1AdminsUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsUsersGet(requestParameters: AdministratorApiApiV1AdminsUsersGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsUsersGet(requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить пользователя по GUID.   
     * @summary Получить пользователя по GUID.
     * @param {AdministratorApiApiV1AdminsUsersGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsUsersGuidGet(requestParameters: AdministratorApiApiV1AdminsUsersGuidGetRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsUsersGuidGet(requestParameters.guid, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ##  Изменить пользователя.  
     * @summary Изменить пользователя.
     * @param {AdministratorApiApiV1AdminsUsersGuidPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsUsersGuidPatch(requestParameters: AdministratorApiApiV1AdminsUsersGuidPatchRequest, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsUsersGuidPatch(requestParameters.guid, requestParameters.body, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Получить всех пользователей с пагинацией   
     * @summary Получить всех пользователей с пагинацией.
     * @param {AdministratorApiApiV1AdminsUsersPagGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministratorApi
     */
    public apiV1AdminsUsersPagGet(requestParameters: AdministratorApiApiV1AdminsUsersPagGetRequest = {}, options?: any) {
        return AdministratorApiFp(this.configuration).apiV1AdminsUsersPagGet(requestParameters.filters, requestParameters.limit, requestParameters.offset, requestParameters.sortField, requestParameters.sortType, requestParameters.noCache, requestParameters.acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
